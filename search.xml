<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>强联通分量分解算法</title>
    <url>/2022/03/28/TCS/StrongCC/</url>
    <content><![CDATA[<h1 id="强联通分量定义"><a href="#强联通分量定义" class="headerlink" title="强联通分量定义"></a>强联通分量定义</h1><blockquote>
<p><strong>定义1.</strong>（强联通）：我们说有向图中两个顶点 $u, v$ 是强联通的当且仅当存在一条有向路径从 $u$ 到 $v$，同时也存在一条有向路径从 $v$ 到 &gt; $u$。一个顶点和自己也是强联通的。<br><strong>定义2.</strong>（强联通图）：我们说有向图 $G$ 是强联通图当且仅当图中任何一对顶点都是强联通的。<br><strong>定义3.</strong>（强联通分量）：对于任意有向图 $G$，我们将 $G$ 中任意一个极大强联通子图称为 $G$ 的强联通分量。</p>
</blockquote>
<p>什么是极大强联通子图？其实就是说对于一个强联通子图，我们往其中增加任何额外的顶点都会使该子图失去强联通性质，也就是符合强联通性质的一个最大顶点集合。</p>
<a id="more"></a>

<p>我们可以看出来（证明略），对于任何一个有向图 $G$，它的强联通分量们之间不会重叠，于是我们可以认为，一个有向图的所有强联通分量顶点集合的并就是 $G$ 的所有顶点。反过来说就是，一个有向图可以拆分成多个互不重叠的强联通分量。</p>
<p>而今天要介绍的就是将这个有向图的强联通分量分解出来的算法，即强联通分量分解算法。本篇主要介绍两个算法：Kosaraju 算法和 Tarjan 算法。</p>
<hr>
<h1 id="Kosaraju-算法"><a href="#Kosaraju-算法" class="headerlink" title="Kosaraju 算法"></a>Kosaraju 算法</h1><p>Kosaraju 算法分解强联通分量是通过两次 DFS 实现的。第一次 DFS 负责给原图的顶点标号，这里我们要用后序遍历的方式给顶点标号，即先访问子节点，再对当前节点标号。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kosaraju_dfs1</span><span class="params">(<span class="keyword">int</span> u)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    vis[u] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : G.V[u])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!vis[v])</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            kosaraju_dfs1(v);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    order.push_back(u);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>第二次 DFS 我们要在反图上按照之前标号<strong>从大到小</strong>的顺序对顶点执行 DFS， 我们要标记当前顶点所能到达的所有顶点，此时，这些被标记的顶点和当前顶点组成的顶点集合就是一个强联通分量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kosaraju_dfs2</span><span class="params">(<span class="keyword">int</span> u)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    vis[u] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    visited.push_back(u);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : GRev.V[u])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!vis[v])</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            kosaraju_dfs2(v);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>这个算法有这么几个奇怪的地方：</p>
<ol>
<li>为什么要使用后序遍历标号，而不是前序遍历？</li>
<li>为什么需要建反图？</li>
</ol>
<p>为了回答这几个问题，我们需要再重新看一下强联通分量的定义，同时证明这个算法是正确的。</p>
<hr>
<h1 id="Kosaraju-算法正确性"><a href="#Kosaraju-算法正确性" class="headerlink" title="Kosaraju 算法正确性"></a>Kosaraju 算法正确性</h1><p>假设我们有一个强连通分量，其中两个顶点 $A, B$。根据定义，$A$ 一定在正向图有一条路径到 $B$，同时 $A$ 也一定在反向图上有一条路径到 $B$。</p>
<p><img src="/images/SCC_Kosar1.png" width="80%" height="80%"></img><br><img src="/images/SCC_Kosar2.png" width="80%" height="80%"></img></p>
<p>这个结论是很显然的，但是我们可以更进一步：</p>
<blockquote>
<p><strong>引理1.</strong> 顶点 $A$ 在正图和反图都能访问到的顶点和构成了顶点 $A$ 所在的强连通分量。</p>
</blockquote>
<p>证明很显然，正图和反图都能访问意味着互相之间存在有向路径，那它必和 $A$ 强连通，同时根据强连通性质的传递性，这些顶点必然也互相之间强连通。因此，得到的顶点集合为原有向图的强连通子图，并且不存在其他顶点也能和 $A$ 强连通了，所以该顶点集合为原图的强连通分量。</p>
<p>有了这个引理以后，我们可以得到一个简易的算法求出强连通分量，即对于每一个顶点，找出其正图和反图都能访问到的顶点集合，然后将其标记为同一强连通分量。但是这个算法时间复杂度略高，可以达到 $O(N^2+NM)$ 级别，所以我们需要更快的做法。</p>
<p>Kosaraju 算法所使用的 DFS 序就是为了减少判定所需要的操作数量。那么怎么判重呢？我们先分析一下正图和反图都会访问到哪些顶点：</p>
<ol>
<li>正图和反图都访问到的顶点，很明显它是强连通分量中的顶点</li>
<li>正图访问到但是反图没有访问到的节点，即下图橙色区域的顶点</li>
<li>正图没有访问到但是反图访问到了，即下图绿色区域的顶点</li>
</ol>
<p><img src="/images/SCC_Kosar3.png" width="80%" height="80%"></img></p>
<p>对于第二种情况，我们可以在反图上把它消掉，因为反图从 $A$ 出发无法访问到这部分顶点。但是对于第三种情况，我们就没法这样消除了，但是这也是 Kosaraju 算法聪明的地方。如果在反图上从 $A$ 出发，我们必然会访问到绿色区域，但是假如我们已经把绿色区域的强联通分量们都算完了呢？</p>
<p>在反图上，如果我们的 DFS 访问是从绿色区域开始的，那么绿色区域计算完成以后是无法到达顶点 $A$ 所在的强联通分量的，也就不会导致 $A$ 所在的强联通分量被错误的计算。由此我们可以得出，绿色区域的计算应该比顶点 $A$ 所在的区域提前，或者说，我们的计算顺序应该是原图的拓扑序。</p>
<p>然而，原图并不一定是个 DAG，所以也并不一定存在拓扑序，但是如果我们把环看成一个顶点，把环上顶点的出边和入边都加在这个顶点上（即缩点操作）以后，得到的这个图就是一个 DAG 了（见下图），所以我们是完全可以按照正确的顺序去计算强联通分量的。那么现在就是那个诡异的后序遍历标号派上用场的时候了。</p>
<p><img src="/images/SCC_Kosar4.png" width="50%" height="50%"></img></p>
<blockquote>
<p><strong>引理2.</strong> 一个图中后序遍历标号最大的顶点所在的强连通分量一定在缩点后的 DAG 没有入度。</p>
</blockquote>
<p>假设一个有向图中后续遍历标号最大的顶点 $x$ 所在的强连通分量在 DAG 中存在入度，那么其上游节点要么已经搜索过，要么还没搜索。如果已经搜索过，但是没有访问过 $x$，根据 DFS 定义，下游顶点的编号一定小于上游顶点编号，所以条件不成立。如果没有被搜索过，那么上游顶点还没有标号，下一次搜索必将导致标号大于 $x$，所以 $x$ 所在强连通分量必定不存在上游顶点。</p>
<p>由此我们可以进行一个过程：先在反图中计算正图后序遍历标号最大的顶点所能访问到的顶点，并且将其合并成一个强连通分量，因为顶点不存在入度，所以没有绿色区域，我们得到的是个正确的强连通分量。然后把这部分顶点从图中移除。此时，剩下的图相当于原缩点后 DAG 移除掉一个没有入度的顶点。新的图中标号最高的顶点必然也是没有入度的，我们可以继续这个过程。不难发现，最终我们相当于在缩点后的图中进行了一次拓扑排序，每次在反图计算能访问到的顶点的时候，我们都把绿色区域移除了，所以每次计算的强连通分量都是正确的，由此可得最终算出的强连通分量分解也是正确的。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>算法</category>
        <category>图论</category>
      </categories>
      <tags>
        <tag>强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>第52回周末休闲赛部分题解</title>
    <url>/2021/01/27/Turorial/ContestTutorial1/</url>
    <content><![CDATA[<p>感谢出题&amp;验题人@baobaobear的贡献</p>
<a id="more"></a>
<hr>
<h1 id="GYM-270074F-Mr-Skirt-and-Cake"><a href="#GYM-270074F-Mr-Skirt-and-Cake" class="headerlink" title="[GYM 270074F] Mr.Skirt and Cake"></a>[GYM 270074F] Mr.Skirt and Cake</h1><p><strong>Idea By：裙子</strong></p>
<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>平面上给你$n(n\leq 2000)$个点，求只用一条直线，有多少种方法将这些点分成数量相等的两部分。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>如图所示，假设红色直线是一条能均分点集的直线</p>
<p><img src="/images/cake1.png" alt="两点确定一条直线"></p>
<p>那么我们可以把它看成是某两个点所确定的直线（图中 <strong>AB</strong> 所得直线）绕两点中间的某个位置旋转一个细微的角度得到。根据旋转的方向，我们可以使得这条线上的点中，<strong>A</strong> 以前的点和 <strong>B</strong> 以后的点分居两侧。于是我们可以得到一个朴素的 $O(n^3)$，即枚举两个点，然后暴力判断这条线是否能把点集分成两半。很可惜，由于 $n$ 可以达到2000，无法在时限内得出结果，我们需要使用更巧妙的方法。</p>
<p>我们可以使用<strong>极角扫描</strong>这个技巧来降低复杂度，具体做法是枚举起始点，然后把剩下的点按照极角排序，然后我们按照相对于起始点的极角从小到大的扫过这些点，动态维护左右两边各有多少个点。由于本题存在多点共线的情况，方便起见，我们可以把扫描过程中极角相同的点都看作一个权值为 $w_i$ 的点，其中 $w_i$ 就是共线点的数量。这样统计两侧数量的时候我们只要统计两侧权值和就可以了。</p>
<p>同时我们可以假设，在扫描线上起始点之前的点和之后的点分别属于两侧，这样就可以保证每次扫描的直线都只对结果贡献一次。</p>
<p><img src="/images/cake2.png" alt="前后向的点"></p>
<p>如图所示，点 <strong>E</strong> 可以看做在点 <strong>B</strong> 的后面，而点 <strong>A,F</strong> 在点 <strong>B</strong> 的前面，这种情况就等同于使用了图中的红线进行点集划分。如果我们的起始点是 <strong>A</strong>，那么左右侧就会反过来，根据题意这也算是一种不同划分方案。</p>
<p><img src="/images/cake3.png" alt="划分直线"></p>
<p>具体怎么用极角扫描维护两边的点数可以参考网上的教程或者下面的代码，不在本题解的范围内。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(n^2\log{n})$</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">read</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    T X = <span class="number">0</span>, w = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> ch = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        w |= ch == <span class="string">'-'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ch = getchar();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) X = (X &lt;&lt; <span class="number">3</span>) + (X &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="number">48</span>), ch = getchar();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> w ? -X : X;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">5005</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXV = <span class="number">3</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, k;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll x, y, cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> rad;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Point() = <span class="keyword">default</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Point(<span class="keyword">int</span> x, <span class="keyword">int</span> y) : x(x), y(y) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Point <span class="keyword">operator</span>+(<span class="keyword">const</span> Point&amp; vec) <span class="keyword">const</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> Point(x + vec.x, y + vec.y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Point <span class="keyword">operator</span>-(<span class="keyword">const</span> Point&amp; vec) <span class="keyword">const</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> Point(x - vec.x, y - vec.y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">static</span> ll <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Point&amp; a, <span class="keyword">const</span> Point&amp; b)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> a.x * b.y - a.y * b.x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">static</span> ll <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Point&amp; a, <span class="keyword">const</span> Point&amp; b)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> a.x * b.x + a.y * b.y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x * (<span class="keyword">double</span>)x + y * (<span class="keyword">double</span>)y; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Point&amp; B) <span class="keyword">const</span> &#123; <span class="keyword">return</span> rad &lt; B.rad; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">test</span><span class="params">(<span class="keyword">const</span> Point&amp; a, <span class="keyword">const</span> Point&amp; b)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll d = Point::cross(a, b);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> (d == <span class="number">0</span> &amp;&amp; Point::dot(a, b) &gt; <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Point pts[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pts[i].x = read&lt;ll&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pts[i].y = read&lt;ll&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"2\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Point&gt; cur, tmp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cur.clear();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        tmp.clear();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (j != i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                tmp.push_back(pts[j] - pts[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : tmp) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            p.rad = <span class="built_in">atan2</span>(p.y, p.x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 极角排序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::sort(tmp.begin(), tmp.end());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> sz = tmp.size();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 把极角相同的点看成一个整体</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; sz; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cnt++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (j == sz - <span class="number">1</span> || !test(tmp[j], tmp[j + <span class="number">1</span>])) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                tmp[j].cnt = cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                cur.push_back(tmp[j]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                cnt = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sz = cur.size();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 维护直线两侧的权值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> cntL = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (l &lt; sz) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (l == r) r = (r + <span class="number">1</span>) % sz;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">while</span> (l != r &amp;&amp; Point::cross(cur[l], cur[r]) &gt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                cntL += cur[r].cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                r = (r + <span class="number">1</span>) % sz;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (cntL + cur[l].cnt == n / <span class="number">2</span>) ans++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            l++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (Point::cross(cur[l - <span class="number">1</span>], cur[l]) &gt; <span class="number">0</span>) cntL -= cur[l].cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
    </div>
</div>

<hr>
<h1 id="GYM-270074G-Mr-Skirt-and-Bubble-Sort"><a href="#GYM-270074G-Mr-Skirt-and-Bubble-Sort" class="headerlink" title="[GYM 270074G] Mr.Skirt and Bubble Sort"></a>[GYM 270074G] Mr.Skirt and Bubble Sort</h1><p><strong>Idea By：baobaobear</strong></p>
<h2 id="题意-1"><a href="#题意-1" class="headerlink" title="题意"></a>题意</h2><p>给你一个包含$n(n\leq 2\times 10^5)$个数字的序列，可以随意对每个数取相反数，求最少可以让这个序列有多少个逆序对。</p>
<h2 id="题解-1"><a href="#题解-1" class="headerlink" title="题解"></a>题解</h2><p>可以从按照绝对值大到小考虑每个数，对于绝对值最大的那个数，假设是 $a_i$，如果变成正数，那么 $|a_i|$ 一定是全局最大的数，剩下的数无论如何都不可能比它大，所以对逆序对的贡献即为下标大于 $i$ 的数的数量。</p>
<p>反之，如果我们让 $a_i$ 变成负数，那么它一定是全局最小的数，它对逆序对的贡献就是下标小于 $i$ 的那些数，对于正负两种情况，我们贪心的取对逆序对贡献最小的那种情况即可，因为随后考虑的每个数都不会影响 $a_i$ 对逆序对的贡献。由于这个数对逆序对的贡献已经算完了，所以随后的数不能考虑 $a_i$ 的影响，即我们要把 $a_i$ 从序列中删除。我们可以用线段树或者树状数组来动态计算有多少个数下标大于/小于 $i$，具体见代码。</p>
<p>注意一下如果有多个数绝对值相同的情况，此时我们需要先把绝对值相同的这些数先从序列中删去，再一个个统计贡献。</p>
<h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(n\log{n})$</p>
<h2 id="参考代码-1"><a href="#参考代码-1" class="headerlink" title="参考代码"></a>参考代码</h2><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> N&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FenwickTree</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    FenwickTree() &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">(<span class="keyword">int</span> t, T x)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i &lt;= N; i += lowbit(i)) _arr[i] += x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">inline</span> T <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        T s = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = t; i; i -= lowbit(i)) s += _arr[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    T _arr[N + <span class="number">5</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> x &amp; (-x); &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">FenwickTree&lt;<span class="keyword">int</span>, MAXN - <span class="number">5</span>&gt; tree;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;pii&gt; nodes;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> x = read&lt;<span class="keyword">int</span>&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        nodes.push_back(&#123;<span class="built_in">std</span>::<span class="built_in">abs</span>(x), i&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        tree.increase(i, <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::sort(nodes.rbegin(), nodes.rend());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll ans = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> sz = nodes.size();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sz; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ++cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 注意考虑绝对值相等的多个数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i == sz - <span class="number">1</span> || nodes[i].first != nodes[i + <span class="number">1</span>].first) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - cnt + <span class="number">1</span>; j &lt;= i; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                tree.increase(nodes[j].second, <span class="number">-1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i - cnt + <span class="number">1</span>; j &lt;= i; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> greater = tree.getSum(n) - tree.getSum(nodes[j].second);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> smaller = tree.getSum(nodes[j].second - <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ans += <span class="built_in">std</span>::min(greater, smaller);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cnt = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
    </div>
</div>

<hr>
<h1 id="GYM-270074H-Mr-Skirt-and-Marksman-Easy-Version"><a href="#GYM-270074H-Mr-Skirt-and-Marksman-Easy-Version" class="headerlink" title="[GYM 270074H] Mr. Skirt and Marksman (Easy Version)"></a>[GYM 270074H] Mr. Skirt and Marksman (Easy Version)</h1><p><strong>Idea By：裙子</strong></p>
<h2 id="题意-2"><a href="#题意-2" class="headerlink" title="题意"></a>题意</h2><p>你可以从原点发射一个速度大小为 $x$ 的向量，问能否在 $10^6$ 秒内击中一个初始位置为 <strong>B</strong> ，且以速度向量 <strong>V</strong> 匀速移动的物体。</p>
<h2 id="题解-2"><a href="#题解-2" class="headerlink" title="题解"></a>题解</h2><p>本题有多种解法，但是在这之前，要先把边界条件判掉，由于发射速度，敌人移动速度可能是0，所以要先处理这种情况，之后就是判断能否有一个向量在规定时间内追上敌人。<br>这个判断有两种解法，且精度都比较优秀：</p>
<h3 id="公式法"><a href="#公式法" class="headerlink" title="公式法"></a>公式法</h3><p>设发射向量为 <strong>S</strong> ，由题意可列出方程：<br>$$<br>t\textbf{S} = \textbf{B} + t\textbf{V}<br>$$<br>两边同时平方<br>$$<br>(t\textbf{S})^2 = (\textbf{B} + t\textbf{V})^2<br>$$<br>等等！为什么这个式子是对的，距离的平方相等不代表这两个向量就在一个点上。但是注意，我们只限制了发射速度，但是发射方向可以任意选取，所以只要距离是相等的，我们就认为向正确的方向发射了向量。</p>
<p>于是接下来我们移项，然后展开公式<br>$$<br>\begin{align}<br>(t\textbf{S})^2 - (\textbf{B} + t\textbf{V})^2 &amp;= 0 \\<br>t^2\textbf{S}^2 - (\textbf{B}^2 + 2t\textbf{B} \circ \textbf{V}+ t^2\textbf{V}^2) &amp;= 0 \\<br>(\textbf{S}^2 - \textbf{V}^2)t^2 - (2\textbf{B} \circ \textbf{V})t - \textbf{B}^2 &amp;= 0<br>\end{align}<br>$$<br>这里向量的平方就是与自己的<strong>点积</strong>，$\textbf{B} \circ \textbf{V}$ 代表 <strong>B</strong> 和 <strong>V</strong> 的点积。于是这个式子就变成了一个一元二次方程，解出$t$然后判断是否有大于等于0且小于等于 $10^6$ 的解即可。</p>
<p>无解的情况也很好处理，只要看看判别式是否小于0即可。值得注意的是 $(\textbf{S}^2 - \textbf{V}^2) = 0$ 的情况，此时整个方程变成一次方程，直接得出答案即可。</p>
<h4 id="时间复杂度-2"><a href="#时间复杂度-2" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>$O(q)$</p>
<h4 id="参考代码-2"><a href="#参考代码-2" class="headerlink" title="参考代码"></a>参考代码</h4><div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">onRay</span><span class="params">(ll Bx, ll By, ll Vx, ll Vy)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (Vx == <span class="number">0</span> || Vy == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> -By * Vx == -Bx * Vy &amp;&amp; (-Bx * Vx &gt;= <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll Bx, By, Vx, Vy;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; Bx &gt;&gt; By &gt;&gt; Vx &gt;&gt; Vy;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (Bx == <span class="number">0</span> &amp;&amp; By == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 弹幕不能动就要判定是否会撞上原点了</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> onRay(Bx, By, Vx, Vy);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll a = x * x - Vx * Vx - Vy * Vy;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll b = <span class="number">-2L</span>L * (Bx * Vx + By * Vy);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll c = -(Bx * Bx + By * By);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll delta = b * b - <span class="number">4L</span>L * a * c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (delta &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!b || -c * b &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// t = -c / b;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> -c &lt;= <span class="number">1000000</span> * b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 方程有两个解的情况</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> t0 = (-b - <span class="built_in">std</span>::<span class="built_in">sqrt</span>(delta)) / (<span class="number">2.0</span> * a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> t1 = (-b + <span class="built_in">std</span>::<span class="built_in">sqrt</span>(delta)) / (<span class="number">2.0</span> * a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (t0 &lt; <span class="number">0</span> &amp;&amp; t1 &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (t1 &lt; t0) <span class="built_in">std</span>::swap(t0, t1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (t0 &lt; <span class="number">0</span>) <span class="keyword">return</span> t1 &lt;= <span class="number">1e6</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::ios::sync_with_stdio(<span class="literal">false</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.tie(<span class="literal">nullptr</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> m;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; m;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (m--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (solve()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"YES\n"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"NO\n"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
    </div>
</div>

<h3 id="三分法"><a href="#三分法" class="headerlink" title="三分法"></a>三分法</h3><p>我们可以对时间进行三分，设函数 $f(t)$ 为在 $t$ 时刻，最优发射向量与敌人的位置的距离平方大小。这个最优发射向量的方向很明显是从原点朝向 $\textbf{B} + t\textbf{V}$ 这个位置。</p>
<p>从上一个方法的公式我们可以推出这个函数是存在一些局部最低点的，如果这个点存在且值为0，并且在 $[0, 10^6]$ 这个范围内那么就是有解的。幸运的是，虽然这个函数可能存在多个局部最低点，但是只有值为0的局部最低点能出现多次，所以找到的任意一个局部最低点都可以确定是否有解。剩下的工作就是用三分法找这个局部最低点了，这道题我特意放宽了精度限制，只要距离小于 $10^{-3}$ 我们就可以认为有解然后跳出了。</p>
<p>值得注意的是，如果函数 $f(t)$ 的返回值是<strong>距离</strong>大小而不是<strong>距离平方</strong>我也放过了，但是使用距离作为指标因为使用了<code>sqrt</code>函数，所以精度比较差，如果时间是$10^9$可能就过不了了。</p>
<p>本题精度限制放的很宽，基本上只要方向对了就能过。</p>
<h4 id="时间复杂度-3"><a href="#时间复杂度-3" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>$O(q\log{\varepsilon^{-1}})$</p>
<h4 id="参考代码-3"><a href="#参考代码-3" class="headerlink" title="参考代码"></a>参考代码</h4><p>baobaobear大佬的写法</p>
<div class='spoiler collapsed'>
    <div class='spoiler-title'>
        Code
    </div>
    <div class='spoiler-content'>
        <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_dis</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> vx, <span class="keyword">int</span> vy, <span class="keyword">int</span> v, <span class="keyword">double</span> d)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> dx = x + vx * d, dy = y + vy * d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> dx * dx + dy * dy - d * d * v * v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fastio</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        fastio() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cin</span>.tie(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ios::sync_with_stdio(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; fio;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (t--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> x, y, vx, vy, v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">double</span> ld = <span class="number">0</span>, rd = <span class="number">1e6</span>, md = <span class="number">10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y &gt;&gt; vx &gt;&gt; vy &gt;&gt; v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (v == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (x * vy - y * vx == <span class="number">0</span> &amp;&amp; (vx != <span class="number">0</span> || vy != <span class="number">0</span>) &amp;&amp; (vx != <span class="number">0</span> &amp;&amp; vx * x &lt; <span class="number">0</span> || vy != <span class="number">0</span> &amp;&amp; vy * y &lt; <span class="number">0</span>)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">bool</span> ok = <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">double</span> eps = <span class="number">1e-3</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (get_dis(x, y, vx, vy, v, rd) &lt;= eps)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ok = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!ok) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">while</span> (rd &gt; <span class="number">1e-6</span> &amp;&amp; (rd - ld) / rd &gt; <span class="number">1e-6</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">double</span> md1 = (rd - ld) / <span class="number">5</span> * <span class="number">2</span> + ld, md2 = rd - (rd - ld) / <span class="number">5</span> * <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">double</span> d1 = get_dis(x, y, vx, vy, v, md1), d2 = get_dis(x, y, vx, vy, v, md2);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (d1 &lt;= eps || d2 &lt;= eps) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    ok = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (d1 &lt; d2) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    rd = md2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    ld = md1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (ok) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO"</span> &lt;&lt; <span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
    </div>
</div>                                                                            

<p>对于题目有任何问题欢迎提出</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
        <category>原创题</category>
      </categories>
  </entry>
  <entry>
    <title>最小圆覆盖问题</title>
    <url>/2021/01/19/MinimumCircle/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你平面上$n(n\leq 10^5)$个点，求覆盖所有点的最小圆。</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>最小圆覆盖：Welzl’s 算法。</p>
<p>在介绍这个算法之前，我们先考虑最暴力的算法，就是枚举三个点，然后计算其外接圆，判断能否覆盖所有点取最小半径的那个即可，此外我们还要枚举两点围成的圆，他们也有可能是答案，时间复杂度$O(n^4)$。因为我们枚举了组成圆的所有可能性，所以这个算法是正确的。</p>
<p>显然这个方法时间复杂度太高了，我们通过观察可以发现，假设我们知道前$i$个点的最小覆盖圆，那么如果第$i+1$个点不在之前的最小覆盖圆上，那么覆盖前$i+1$个点的圆的边界必定包含第$i+1$个点。</p>
<p>根据这个结论可以推出，假如我们能够根据之前的点计算出3个必在边界上的点，那么覆盖这三个点的最小圆必然是覆盖之前所有点集的最小覆盖圆。</p>
<p>Welzl’s 算法就是根据这个结论实现的，我们考虑递归的进行这个过程：</p>
<ol>
<li>假设我们已经得到前$i$个点的最小覆盖圆$C$，对于点$i+1$来说，如果它在$C$内部，那么我们就忽略这个点。</li>
<li>否则，我们知道点$i+1$必在边界上，把点$i+1$加入边界列表，然后重新求出带有边界列表的最小覆盖圆。</li>
</ol>
<p>伪代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x 代表前面的点集数量，R是边界列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Circle <span class="title">solve</span><span class="params">(<span class="keyword">int</span> x, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; R)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 如果前面没有点了，或者边界点的数量等于3了，就直接暴力求边界点的最小覆盖圆</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(R.size() == <span class="number">3</span> || x == <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> minCircle(R);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 求出前面点的最小覆盖圆</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Circle c = solve(x - <span class="number">1</span>, R);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 如果点不在之前的最小覆盖圆上</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(!c.test(x))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        R.push_back(x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 求出带有 x 的最小覆盖圆</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        solve(x + <span class="number">1</span>, R);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>那么它的复杂度如何呢？我们知道，如果$R$的数量为3，或者已经用完所有点集，我们就可以立即得出最小覆盖圆，否则我们有可能需要重新计算最小覆盖圆，那么在最坏情况下我们对于每个点要重复计算3轮，状态空间为$(x, 3)$，复杂度为$O(n^3)$。</p>
<p>但是，如果我们主动打乱点集的顺序，就可以做到期望$O(n)$的时间复杂度。<br>这个结论如何推出来的呢？设$f(n, i)$为调用这个函数在$n$个点上，且边界点数量为$i$的期望步数，假设随机打乱输入点，那么显然有<br>$$<br>\begin{align}<br>f(n, i) &amp;= 1 + f(n - 1, i) + P(p_n \notin C_{n-1}) \times f(n - 1, i + 1)\\<br>f(n, 3) &amp;= O(1)<br>\end{align}<br>$$<br>问题的关键在于如何求出$P(p_n \notin C_{n-1})$，也就是新的点不在之前点集的最小覆盖圆内的概率。假设我们已经知道$n$个点的最小覆盖圆$C_n$，那么如果前$n-1$个点的最小覆盖圆$C_{n-1}$和$C_n$不同，那么第$n$个点必须是$C_n$的边界，这样的点最多有3个，所以随机选一个点能选到边界的概率只有$\frac{3}{n}$。所以$P(p_n \notin C_{n-1}) = \frac{3}{n}$，然后就有<br>$$<br>\begin{align}<br>f(n, 0) &amp;= 1 + f(n - 1, 0) + \frac{3f(n - 1, 1)}{n}\\<br>f(n, 1) &amp;= 1 + f(n - 1, 1) + \frac{3f(n - 1, 2)}{n}\\<br>f(n, 2) &amp;= 1 + f(n - 1, 2) + \frac{3f(n - 1, 3)}{n}\\<br>f(n, 3) &amp;= O(1)<br>\end{align}<br>$$<br>逆序解出<br>$$<br>\begin{align}<br>f(n, 2) &amp;= 1 + f(n - 1, 2) + \frac{3}{n}\\<br>f(n, 2) &amp;= O(n)\\<br>f(n, 1) &amp;= 1 + f(n - 1, 1) + \frac{3n}{n}\\<br>f(n, 1) &amp;= O(n)\\<br>f(n, 0) &amp;= 1 + f(n - 1, 0) + \frac{3n}{n}\\<br>f(n, 0) &amp;= O(n)\\<br>\end{align}<br>$$</p>
<p>Welzl 算法的原论文出自<a href="https://www.stsci.edu/~RAB/Backup%20Oct%2022%202011/f_3_CalculationForWFIRSTML/Bob1.pdf" target="_blank" rel="noopener">Smallest enclosing disks (balls and ellipsoids)</a>。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>$O(n)$</p>
<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Circle <span class="title">MCC2</span><span class="params">(<span class="keyword">int</span> x, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; R)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (R.size() == <span class="number">3</span> || !x) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (R.empty())</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> Circle(Vector2(<span class="number">0</span>, <span class="number">0</span>), <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (R.size() == <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> Circle(P[R[<span class="number">0</span>]], <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (R.size() == <span class="number">2</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> Circle((P[R[<span class="number">0</span>]] + P[R[<span class="number">1</span>]]) * <span class="number">0.5</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                          (P[R[<span class="number">0</span>]] - P[R[<span class="number">1</span>]]).lengthSq() * <span class="number">0.25</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; <span class="number">3</span>; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">auto</span> c = Circle((P[R[i]] + P[R[j]]) * <span class="number">0.5</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                    (P[R[i]] - P[R[j]]).lengthSq() * <span class="number">0.25</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">bool</span> can = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">3</span>; k++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="keyword">if</span> (!c.test(P[R[k]])) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            can = <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (can) <span class="keyword">return</span> c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> getCircumscribedCircle(P[R[<span class="number">0</span>]], P[R[<span class="number">1</span>]], P[R[<span class="number">2</span>]]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Circle c = MCC2(x - <span class="number">1</span>, R);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!c.test(P[x - <span class="number">1</span>])) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        R.push_back(x - <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        c = MCC2(x - <span class="number">1</span>, R);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">double</span> x, y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x, &amp;y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        P.push_back(Vector2(x, y));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::random_shuffle(P.begin(), P.end(), [](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> mt() % x; &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; R;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Circle c = MCC2(n, R);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.10lf\n"</span>, <span class="built_in">std</span>::<span class="built_in">sqrt</span>(c.r2));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.10lf %.10lf\n"</span>, c.center.x, c.center.y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>算法</category>
        <category>计算几何</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
      </tags>
  </entry>
  <entry>
    <title>[洛谷P6362] 平面欧几里得最小生成树</title>
    <url>/2021/01/16/delaunay/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>求平面上$n(n\leq 10^5)$个点的最小生成树。</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>平面欧几里得最小生成树（EMST）问题的解即是在点集的Delaunay三角剖分上的最小生成树，那么解题的关键就是求出点集的Delaunay三角剖分。</p>
<p>其中一个算法是 Bowyer-Watson 算法的期望$O(n\log{n})$实现方案。朴素的 Bowyer-Watson 算法实现复杂度是$O(n^2)$的，而我使用的这个算法基于的是随机增量方法，虽然时间复杂度看起来不对，但由于我们是随机的选择插入顺序，超过$n\log{n}$的情况几乎不存在。</p>
<h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><p>整个算法的流程是这样的</p>
<ol>
<li>一开始先构造一个极大三角形，然后打乱插入点集的顺序。</li>
<li>每次插入一个点 $p$，确定这个点在哪个三角形，同时把这个三角形三个顶点连接插入点分成三份，分别命名为 $a,b,c$。<br><img src="/images/Delauany1.png" alt="确定三角形"></li>
<li>对于 $a,b,c$ 三个三角形，我们把所有不包含 $p$ 的边标记为可疑边。</li>
<li>对于所有可疑边，我们选择与插入点 $p$ 根据可疑边对立的顶点 $q$。设可疑边两个顶点为 $x, y$。此时 $p,x,q,y$ 组成了一个四边形，如果 $q$ 在 $p, x, y$ 组成的圆里，那么我们要对四边形 $p,x,q,y$ 进行<strong>边翻转</strong>操作。<br><img src="/images/Delauany2.png" alt="可疑边与对立顶点"></li>
<li>如果进行了边翻转操作，我们要把 $qx$, $qy$ 也标记为可疑边。</li>
<li>对所有可疑边都进行<strong>边翻转</strong>操作，当不存在任何可疑边的时候插入就结束了。<br><img src="/images/Delauany3.png" alt="边翻转操作"></li>
<li>插入完所有点后算法就结束了。</li>
</ol>
<h1 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h1><p>这个算法本身包含几个难点：</p>
<ol>
<li>如何高效的找到可疑边和对立点？</li>
<li>如果高效的进行点定位（Point Location）操作？即确定插入点落在哪个三角形内部？</li>
<li>如何判断点是否在某三个点的外接圆内部？</li>
</ol>
<p>第三个问题在@Tweetuzki的题解里已经解释的非常详细了，我这里就直接引用他的方法了。</p>
<h2 id="平面图表示方法"><a href="#平面图表示方法" class="headerlink" title="平面图表示方法"></a>平面图表示方法</h2><p>第一个问题可以使用一个叫做<strong>DCEL</strong>（doubly connected edge list，即双向链接边表）的结构实现，对于这个问题我进行了一点简化，使用的是单向链接边表。</p>
<p>这个数据结构是由三个基本结构组成的，我们知道在平面图中有三个重要组成元素：<strong>顶点，边，面</strong>。</p>
<p>顶点很好表示，我们只关心它的位置。</p>
<p>对于边和面来说，我们需要记录更多信息。为了能够知道这个边组成了哪个面，我们需要对边进行定向，如果某一些边逆时针可以组成一个面，那么就说这些边是这个面的<strong>组成边</strong>，这个面就成为这些边的<strong>组成面</strong>，如图所示<br><img src="/images/Delauany4.png" alt="边链表"><br>$A$ 面是由红色的边所组成的，$B$ 面是由蓝色的边组成的，注意 $ac$ 和 $ca$ 组成的面是不同的。</p>
<p>除此之外，为了能够遍历一个面的所有组成边，对于每一个边我们规定它的<strong>前驱</strong>指针指向构成这个面的逆时针下一条边。比如说，$ca$ 这条边的<strong>前驱</strong>就是边 $ab$。</p>
<p>最后，为了能够获取对立顶点，我们需要由一个跨面的操作，即从面 $A$ 跨越到它的邻接面 $B$，我们只需要知道 $ac$ 边的<strong>孪生边</strong> $ca$ 即可。 $ca$ 的组成面就是 $B$。我们要对每条边都维护这么一个<strong>孪生边</strong>。</p>
<p>假设我们想要获得 $b$ 对于边 $ac$ 的对立顶点，只需要先获得 $ac$ 边，然后找到其<strong>孪生边</strong>的前驱即可。</p>
<p>至此，我们就完成了对于这么一个平面的图的表示，以下是这三个结构的抽象表示方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 边的起点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Vertex* from;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 边的终点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Vertex* to;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 孪生边</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Edge* twin;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 组成面</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Face* face;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 前驱边</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Edge* next;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Face</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 其中一个组成边</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Edge* edge;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Vector2 pos;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr></table></figure>

<h2 id="高效点定位"><a href="#高效点定位" class="headerlink" title="高效点定位"></a>高效点定位</h2><p>在线的点定位（Point Location）问题通常需要复杂的数据结构，比如Kirpatrick的算法和梯形图（Trapezoidal Map）算法。这些算法可以实现单点期望 $O(\log{n})$ 的查询效率，但是代码极其难写且边界条件众多。（当年上计算几何课写这个差点没把我送走QAQ</p>
<p>对于这道题来说，我们有个优势就是可以使用离线的算法，而且出乎意料的是，这个算法极其简单，复杂度和随即增量算法一样看起来很高，但是由于随机性，这个点定位可以在期望均摊 $O(n)$ 的时间解决。</p>
<p>这个方法就是，对于所有三角形的面我们用一个列表记录哪些点在这个三角形内，每次三角形有变动的时候我们暴力重新分配这些点，仅此而已。看起来很暴力，但是效率奇高（并不是因为数据弱哦）。</p>
<p>这样我们对每个顶点维护一下它落在属于哪个面即可。</p>
<h1 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h1><h2 id="输入点扰动"><a href="#输入点扰动" class="headerlink" title="输入点扰动"></a>输入点扰动</h2><p>为了避免重点、三点共线、四点共圆等等的边界条件，我们要先对输入点进行微小扰动。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::mt19937 mt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shake</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pos.x += (mt.max() / <span class="number">2</span> - mt()) / (<span class="keyword">double</span>)mt.max() * <span class="number">2</span> * EPS;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pos.y += (mt.max() / <span class="number">2</span> - mt()) / (<span class="keyword">double</span>)mt.max() * <span class="number">2</span> * EPS;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="遍历可疑边"><a href="#遍历可疑边" class="headerlink" title="遍历可疑边"></a>遍历可疑边</h2><p>每次插入一个点，我们确认了落在哪个三角形内部以后，分裂出来的三个三角形的向外的边都会被标记为可疑边，为了能够按照顺序处理，我们维护一个队列即可，进行边翻转以后加入新的可疑边进队列即可，伪代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Edge*&gt; Q;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!Q.empty()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">auto</span> curEdge = Q.front();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Q.pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 如果没有孪生边就略过</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">auto</span> twin = curEdge-&gt;twin;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!twin) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">auto</span> target = twin-&gt;next-&gt;to;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 判断对立顶点是否在外接圆内</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (inCircumcircle(curEdge-&gt;from, curEdge-&gt;to, P, target)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 进行边翻转，同时加入新的可疑边</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="边翻转"><a href="#边翻转" class="headerlink" title="边翻转"></a>边翻转</h2><p>我们只需要把两个对立顶点的边翻转到另外两个对立顶点即可，注意在这个过程中我们并不需要增加和删除面，我们可以在原来的边和面上进行操作，首先把边的两个顶点换掉，然后对于这两个面，重新连接边，以及前驱。</p>
<p>在这个过程中也别忘了把之前两个面覆盖的顶点拿出来，并且在边翻转结束后重新更新每个顶点的所属面。<br><img src="/images/Delauany5.png" alt="边翻转流程"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> A = curEdge -&gt; face;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> B = twin -&gt; face;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 提取出覆盖了的顶点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Vertex*&gt; cover;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> vs : A-&gt;owned) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cover.push_back(vs);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> vs : B-&gt;owned) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cover.push_back(vs);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 重组AB面</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// ......</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 这部分代码略去留给读者自己思考 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> vs : cover) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 剔除掉没必要更新的点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (vs-&gt;id == P-&gt;id) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 每个顶点重新判断所属面</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (!vs-&gt;testInTriangle(A)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        vs-&gt;belong = B;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        B-&gt;owned.push_back(vs);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h2 id="打碎原三角形"><a href="#打碎原三角形" class="headerlink" title="打碎原三角形"></a>打碎原三角形</h2><p>与上面的边翻转一样，这里我们也没必要生成三个新的三角形，而是只生成两个，然后另一个使用原三角形。更新顶点所属面和上面一样暴力。</p>
<p>至此这个随机增量算法的大部分细节就都介绍完毕了，对于这题剩下的只要遍历所有边然后求最小生成树即可。截止目前，这个“纯暴力”算法是跑的最快的提交，我的代码还有很多地方没有优化，比如把指针替换为数组下标，以及比较优雅的判断点是否在面内的算法。</p>
<p>由此可以看出，随机化思想在计算几何中的重要性，它允许了我们用极其优雅和简单的方式解决困难的问题。</p>
<p>算法本身实现非常简单，但是时间复杂度直到1992年的论文<a href="http://www.wias-berlin.de/people/si/course/files/Guibas92-RandomizeIncr.pdf" target="_blank" rel="noopener">Randomized Incremental Construction of Delaunay and Voronoi Diagrams</a>才真正的确认为期望$O(n\log{n})$。</p>
<p>参考代码（很长，但是大部分代码都是数据结构的表示以及向量的板子，核心就是insert函数）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> LD;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">2147483647</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF2 = <span class="number">0x3f3f3f3f</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ll INF64 = <span class="number">1e18</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> INFD = <span class="number">1e30</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> PI = <span class="built_in">acos</span>(<span class="number">-1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">read</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    T X = <span class="number">0</span>, w = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">char</span> ch = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(ch)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        w |= ch == <span class="string">'-'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ch = getchar();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(ch)) X = (X &lt;&lt; <span class="number">3</span>) + (X &lt;&lt; <span class="number">1</span>) + (ch ^ <span class="number">48</span>), ch = getchar();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> w ? -X : X;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dr[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dc[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dr2[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dc2[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">-1</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> CASE = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> MAXN = <span class="number">100010</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">double</span> EPS = <span class="number">1e-10</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::mt19937 mt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dcmp</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(x) &lt; EPS) <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vector2</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> x, y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Vector2() : x(<span class="number">0</span>), y(<span class="number">0</span>) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Vector2(<span class="keyword">double</span> x, <span class="keyword">double</span> y) : x(x), y(y) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Vector2(<span class="keyword">double</span> rad) : x(<span class="built_in">cos</span>(rad)), y(<span class="built_in">sin</span>(rad)) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">dot</span><span class="params">(<span class="keyword">const</span> Vector2&amp; a, <span class="keyword">const</span> Vector2&amp; b)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> a.x * b.x + a.y * b.y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">angle</span><span class="params">(<span class="keyword">const</span> Vector2&amp; a, <span class="keyword">const</span> Vector2&amp; b)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="built_in">acos</span>(dot(a, b) / a.length() / b.length());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">cross</span><span class="params">(<span class="keyword">const</span> Vector2&amp; a, <span class="keyword">const</span> Vector2&amp; b)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> a.x * b.y - a.y * b.x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">area2</span><span class="params">(<span class="keyword">const</span> Vector2&amp; a, <span class="keyword">const</span> Vector2&amp; b, <span class="keyword">const</span> Vector2&amp; c)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> cross(b - a, c - a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">sqrt</span>(x * x + y * y); &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">lengthSq</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> x * x + y * y; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">getRad</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">atan2</span>(y, x); &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">Vector2 <span class="title">rotate</span><span class="params">(<span class="keyword">double</span> rad)</span> <span class="keyword">const</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> Vector2(x * <span class="built_in">cos</span>(rad) - y * <span class="built_in">sin</span>(rad),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                       x * <span class="built_in">sin</span>(rad) + y * <span class="built_in">cos</span>(rad));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">Vector2 <span class="title">unit</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">double</span> l = <span class="keyword">this</span>-&gt;length();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> Vector2(x / l, y / l);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">Vector2 <span class="title">normal</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">double</span> l = <span class="keyword">this</span>-&gt;length();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> Vector2(-y / l, x / l);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Vector2&amp; other) <span class="keyword">const</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> x &lt; other.x || (x == other.x &amp;&amp; y &lt; other.y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Vector2&amp; other) <span class="keyword">const</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> !dcmp(x - other.x) &amp;&amp; !dcmp(y - other.y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Vector2&amp; <span class="keyword">operator</span>+=(<span class="keyword">const</span> Vector2&amp; vec) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>-&gt;x += vec.x, <span class="keyword">this</span>-&gt;y += vec.y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Vector2 <span class="keyword">operator</span>+(<span class="keyword">const</span> Vector2&amp; vec) <span class="keyword">const</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> Vector2(<span class="keyword">this</span>-&gt;x + vec.x, <span class="keyword">this</span>-&gt;y + vec.y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Vector2&amp; <span class="keyword">operator</span>-=(<span class="keyword">const</span> Vector2&amp; vec) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>-&gt;x -= vec.x, <span class="keyword">this</span>-&gt;y -= vec.y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Vector2 <span class="keyword">operator</span>-(<span class="keyword">const</span> Vector2&amp; vec) <span class="keyword">const</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> Vector2(<span class="keyword">this</span>-&gt;x - vec.x, <span class="keyword">this</span>-&gt;y - vec.y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Vector2&amp; <span class="keyword">operator</span>*=(<span class="keyword">double</span> v) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>-&gt;x *= v, <span class="keyword">this</span>-&gt;y *= v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Vector2&amp; <span class="keyword">operator</span>*=(<span class="keyword">const</span> Vector2&amp; v) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>-&gt;x *= v.x, <span class="keyword">this</span>-&gt;y *= v.y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Vector2 <span class="keyword">operator</span>*(<span class="keyword">double</span> v) <span class="keyword">const</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> Vector2(<span class="keyword">this</span>-&gt;x * v, <span class="keyword">this</span>-&gt;y * v);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Vector2 <span class="keyword">operator</span>*(<span class="keyword">const</span> Vector2&amp; vec) <span class="keyword">const</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> Vector2(<span class="keyword">this</span>-&gt;x * vec.x, <span class="keyword">this</span>-&gt;y * vec.y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Vector2&amp; <span class="keyword">operator</span>/=(<span class="keyword">double</span> v) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>-&gt;x /= v, <span class="keyword">this</span>-&gt;y /= v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Vector2&amp; <span class="keyword">operator</span>/=(<span class="keyword">const</span> Vector2&amp; vec) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>-&gt;x /= vec.x, <span class="keyword">this</span>-&gt;y /= vec.y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Vector2 <span class="keyword">operator</span>/(<span class="keyword">double</span> v) <span class="keyword">const</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> Vector2(<span class="keyword">this</span>-&gt;x / v, <span class="keyword">this</span>-&gt;y / v);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Vector2 <span class="keyword">operator</span>/(<span class="keyword">const</span> Vector2&amp; vec) <span class="keyword">const</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> Vector2(<span class="keyword">this</span>-&gt;x / vec.x, <span class="keyword">this</span>-&gt;y / vec.y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Face</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Vertex* from;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Vertex* to;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Edge* twin;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Face* face;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Edge* next;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> id;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Edge()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        : from(<span class="literal">nullptr</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          to(<span class="literal">nullptr</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          twin(<span class="literal">nullptr</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          face(<span class="literal">nullptr</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          next(<span class="literal">nullptr</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          id(<span class="number">0</span>) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Edge(Vertex* fr, Vertex* to)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        : from(fr),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          to(to),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          twin(<span class="literal">nullptr</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          face(<span class="literal">nullptr</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          next(<span class="literal">nullptr</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">          id(<span class="number">0</span>) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Face</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Edge* edge;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Vertex*&gt; owned;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Face() : id(<span class="number">0</span>), edge(<span class="literal">nullptr</span>) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Face(<span class="keyword">int</span> id, Edge* edge) : id(id), edge(edge) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Face* belong;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Vector2 pos;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Vertex() : id(<span class="number">0</span>), belong(<span class="literal">nullptr</span>), pos() &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Vertex(<span class="keyword">int</span> id, <span class="keyword">double</span> x, <span class="keyword">double</span> y) : id(id), belong(<span class="literal">nullptr</span>), pos(x, y) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shake</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pos.x += (mt.max() / <span class="number">2</span> - mt()) / (<span class="keyword">double</span>)mt.max() * <span class="number">2</span> * EPS;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pos.y += (mt.max() / <span class="number">2</span> - mt()) / (<span class="keyword">double</span>)mt.max() * <span class="number">2</span> * EPS;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 非常暴力地判断点是否在面内部</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">testInTriangle</span><span class="params">(Face* face)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">auto</span> e = face-&gt;edge;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">auto</span> dir = e-&gt;to-&gt;pos - e-&gt;from-&gt;pos;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">auto</span> p = pos - e-&gt;from-&gt;pos;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (Vector2::cross(dir, p) &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e = e-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        belong = face;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        face-&gt;owned.push_back(<span class="keyword">this</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Vertex vPool[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> totV;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Face fPool[MAXN * <span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> totF;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Edge ePool[MAXN * <span class="number">6</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> totE;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">vec3_t</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> x, y, z;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">vec3_t</span>(<span class="keyword">double</span> _x = <span class="number">0</span>, <span class="keyword">double</span> _y = <span class="number">0</span>, <span class="keyword">double</span> _z = <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        x = _x, y = _y, z = _z;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">inline</span> <span class="keyword">friend</span> <span class="keyword">vec3_t</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">vec3_t</span>&amp; a, <span class="keyword">const</span> <span class="keyword">vec3_t</span>&amp; b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">vec3_t</span>(a.x + b.x, a.y + b.y, a.z + b.z);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">inline</span> <span class="keyword">friend</span> <span class="keyword">vec3_t</span> <span class="keyword">operator</span>-(<span class="keyword">const</span> <span class="keyword">vec3_t</span>&amp; a, <span class="keyword">const</span> <span class="keyword">vec3_t</span>&amp; b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">vec3_t</span>(a.x - b.x, a.y - b.y, a.z - b.z);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">inline</span> <span class="keyword">friend</span> <span class="keyword">vec3_t</span> <span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="keyword">vec3_t</span>&amp; a, <span class="keyword">double</span> k) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">vec3_t</span>(a.x * k, a.y * k, a.z * k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">friend</span> vec3_t <span class="title">cross</span><span class="params">(<span class="keyword">const</span> <span class="keyword">vec3_t</span>&amp; a, <span class="keyword">const</span> <span class="keyword">vec3_t</span>&amp; b)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">vec3_t</span>(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                      a.x * b.y - a.y * b.x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">friend</span> <span class="keyword">double</span> <span class="title">dot</span><span class="params">(<span class="keyword">const</span> <span class="keyword">vec3_t</span>&amp; a, <span class="keyword">const</span> <span class="keyword">vec3_t</span>&amp; b)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> a.x * b.x + a.y * b.y + a.z * b.z;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">node3_t</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">inCircumcircle</span><span class="params">(Vertex* a, Vertex* b, Vertex* c, Vertex* d)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">vec3_t</span> A = <span class="keyword">vec3_t</span>(a-&gt;pos.x, a-&gt;pos.y, Vector2::dot(a-&gt;pos, a-&gt;pos));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">vec3_t</span> B = <span class="keyword">vec3_t</span>(b-&gt;pos.x, b-&gt;pos.y, Vector2::dot(b-&gt;pos, b-&gt;pos));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">vec3_t</span> C = <span class="keyword">vec3_t</span>(c-&gt;pos.x, c-&gt;pos.y, Vector2::dot(c-&gt;pos, c-&gt;pos));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">vec3_t</span> D = <span class="keyword">vec3_t</span>(d-&gt;pos.x, d-&gt;pos.y, Vector2::dot(d-&gt;pos, d-&gt;pos));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (Vector2::cross(b-&gt;pos - a-&gt;pos, c-&gt;pos - a-&gt;pos) &lt; <span class="number">0</span>) <span class="built_in">std</span>::swap(B, C);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">node3_t</span> normal = cross(B - A, C - A);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (dot(normal, D - A) &gt; EPS)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Vertex* <span class="title">newVertex</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ++totV;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    vPool[totV] = Vertex(totV, x, y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> &amp;vPool[totV];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Edge* <span class="title">newEdge</span><span class="params">(Vertex* fr, Vertex* to)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ++totE;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ePool[totE] = Edge(fr, to);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ePool[totE].id = totE;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> &amp;ePool[totE];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 创造一个以abc为逆时针顶点的三角形面</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">constructNewFace</span><span class="params">(Face* face, Vertex* a, Vertex* b, Vertex* c)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Edge* edges[<span class="number">3</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    edges[<span class="number">0</span>] = newEdge(a, b);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    edges[<span class="number">1</span>] = newEdge(b, c);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    edges[<span class="number">2</span>] = newEdge(c, a);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        edges[i]-&gt;next = edges[(i + <span class="number">1</span>) % <span class="number">3</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        edges[i]-&gt;face = face;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    face-&gt;edge = edges[<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 创造一个以边abc为逆时针顺序的组成面</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">constructFace</span><span class="params">(Face* face, Edge* a, Edge* b, Edge* c)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Edge* edges[<span class="number">3</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    edges[<span class="number">0</span>] = a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    edges[<span class="number">1</span>] = b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    edges[<span class="number">2</span>] = c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        edges[i]-&gt;next = edges[(i + <span class="number">1</span>) % <span class="number">3</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        edges[i]-&gt;face = face;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    face-&gt;edge = a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Face* <span class="title">newFace</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    totF++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    fPool[totF].id = totF;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> &amp;fPool[totF];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Vector2 PT[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Vertex* v = &amp;vPool[x];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Face* face = v-&gt;belong;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 打碎原三角形，生成三个新的三角形</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">auto</span> fEdge = face-&gt;edge;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Face* nFaces[<span class="number">3</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    nFaces[<span class="number">0</span>] = face;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    nFaces[<span class="number">1</span>] = newFace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    nFaces[<span class="number">2</span>] = newFace();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// nEdges 是逆时针的第一条边，cEdges是组成面的逆时针最后一条边</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Edge* nEdges[<span class="number">3</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Edge* cEdges[<span class="number">3</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Edge* oEdges[<span class="number">3</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        nEdges[i] = newEdge(v, fEdge-&gt;from);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cEdges[i] = newEdge(fEdge-&gt;to, v);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        oEdges[i] = fEdge;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        fEdge = fEdge-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        constructFace(nFaces[i], nEdges[i], oEdges[i], cEdges[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        nEdges[i]-&gt;twin = cEdges[(i + <span class="number">2</span>) % <span class="number">3</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cEdges[(i + <span class="number">2</span>) % <span class="number">3</span>]-&gt;twin = nEdges[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Vertex*&gt; children(nFaces[<span class="number">0</span>]-&gt;owned.begin(),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                  nFaces[<span class="number">0</span>]-&gt;owned.end());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        nFaces[i]-&gt;owned.clear();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> vs : children) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (vs-&gt;id == v-&gt;id) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (vs-&gt;testInTriangle(nFaces[i])) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Edge*&gt; Q;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Q.push(oEdges[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">auto</span> curEdge = Q.front();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Q.pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">auto</span> twin = curEdge-&gt;twin;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!twin) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">auto</span> targetV = twin-&gt;next-&gt;to;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (targetV == v) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (inCircumcircle(curEdge-&gt;from, curEdge-&gt;to, v, targetV)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">auto</span> nxt1 = twin-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 添加可疑边</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            Q.push(nxt1), Q.push(nxt1-&gt;next);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">auto</span> A = curEdge-&gt;face;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">auto</span> B = twin-&gt;face;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            assert(A != B);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            children.clear();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> vs : A-&gt;owned) children.push_back(vs);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> vs : B-&gt;owned) children.push_back(vs);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            A-&gt;owned.clear();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            B-&gt;owned.clear();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">auto</span> lastNxt = curEdge-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">auto</span> lastPrev = lastNxt-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// Do edge flip</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            curEdge-&gt;from = v, curEdge-&gt;to = targetV;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            twin-&gt;from = targetV, twin-&gt;to = v;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            constructFace(A, curEdge, nxt1-&gt;next, lastNxt);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            constructFace(B, twin, lastPrev, nxt1);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> vs : children) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (vs-&gt;id == v-&gt;id) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (!vs-&gt;testInTriangle(A)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    vs-&gt;belong = B;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    B-&gt;owned.push_back(vs);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UnionFind</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) fa[i] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> a = find(x), b = find(y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        fa[a] = b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123; <span class="keyword">return</span> (fa[x] == x) ? x : fa[x] = find(fa[x]); &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> fa[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">UnionFind uf;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E2</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> x, y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> w;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> E2&amp; e) <span class="keyword">const</span> &#123; <span class="keyword">return</span> w &lt; e.w; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;E2&gt; edges;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    mt.seed(<span class="number">19260817</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    uf.clear(n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf %lf"</span>, &amp;PT[i].x, &amp;PT[i].y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        vPool[++totV] = Vertex(i, PT[i].x, PT[i].y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        vPool[totV].shake();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::random_shuffle(vPool + <span class="number">1</span>, vPool + totV + <span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        [](<span class="keyword">int</span> x) &#123; <span class="keyword">return</span> mt() % x; &#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">auto</span> a = newVertex(<span class="number">1e6</span>, <span class="number">1e6</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">auto</span> b = newVertex(<span class="number">-1e6</span>, <span class="number">1e6</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">auto</span> c = newVertex(<span class="number">-1e6</span>, <span class="number">-1e6</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">auto</span> d = newVertex(<span class="number">1e6</span>, <span class="number">-1e6</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">auto</span> f1 = newFace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">auto</span> f2 = newFace();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    constructNewFace(f1, a, b, d);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    constructNewFace(f2, d, b, c);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    f1-&gt;edge-&gt;next-&gt;twin = f2-&gt;edge;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    f2-&gt;edge-&gt;twin = f1-&gt;edge-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Vertex&amp; v = vPool[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!v.testInTriangle(f1)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            v.belong = f2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            f2-&gt;owned.push_back(&amp;vPool[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        insert(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= totF; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">auto</span> e = fPool[i].edge;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3</span>; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> u = e-&gt;from-&gt;id, v = e-&gt;to-&gt;id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (u &lt;= n &amp;&amp; v &lt;= n) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                edges.push_back(&#123;u, v, (PT[v] - PT[u]).length()&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            e = e-&gt;next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::sort(edges.begin(), edges.end());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> ans = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : edges) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (uf.find(e.x) != uf.find(e.y)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ans += e.w;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            uf.join(e.x, e.y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.6lf\n"</span>, ans);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>



<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>$O(n\log{n})$</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>计算几何</tag>
        <tag>Delaunay三角剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>[CF235B] Let&#39;s Play Osu!</title>
    <url>/2020/12/24/CF235B/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>有$n$个操作，每个操作有$p_i$几率成功，连续$k$次成功会给总分贡献$k^2$，求最后总分的期望。</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>前置：</p>
<ul>
<li>期望的线性性质：$E[aX+b] = aE[X]+b$。</li>
<li>区别：$E[X^2]$和$E[X]^2$</li>
</ul>
<p>先考虑线性情况，即每$i$个连击贡献$i$分值的这种情况。<br>设$X_i$为经过$i$个操作的<strong>总分</strong>，那么$E[X_i]$经过$i$个操作的<strong>期望总分</strong>，对于第$i$个操作而言，如果成功了，那么总贡献就是上一次的期望总分+1，如果失败了那么总分就不变。求$E[X_i]$可以写成<br>$$<br>\begin{align}<br>E[X_i] &amp;= p_iE[X_{i-1}+1] + (1-p_i)E[X_{i-1}] \\<br>E[X_i] &amp;= p_iE[X_{i-1}] + p_i + E[X_{i-1}] - p_iE[X_{i-1}] \\<br>E[X_i] &amp;= E[X_{i-1}]+p_i<br>\end{align}<br>$$</p>
<p>但是如果每个$i$连击贡献$i^2$个，那么此时对于期望总分的贡献就不能只是+1了。<br>假设经过$i-1$号操作后的连击数为$Y_{i-1}$，那么$i$号操作成功它会对<strong>总分</strong>的贡献是$(Y_{i-1}+1)^2-Y_{i-1}^2 = 2Y_{i-1} + 1$。则对于<strong>期望总分</strong>的贡献是$E[2Y_{i-1} + 1]$。<br>根据期望的线性性质，我们需要求的就是$2E[Y_{i-1}] + 1$。<br>$E[Y_i]$翻译成人话就是<strong>经过$i$号操作后的连击数的期望</strong>，这个东西很好求。从$i-1$开始推，如果$i$成功，那么期望连击数就是$E[Y_i]+1$，如果失败直接变成0。于是有：<br>$$<br>E[Y_i] = p_i(E[Y_{i - 1}] + 1)<br>$$<br>于是我们可以事先求出$E[Y_i]$，然后应用到平方贡献里。设$Z_i$为经过$i$个操作以后的<strong>总分</strong>（此时使用的是连击数的平方)，那么所求就是$E[Z_i]$，即经过$i$个操作以后的<strong>期望总分</strong><br>$$<br>\begin{align}<br>E[Z_i] &amp;= p_i(E[Z_{i-1}+2Y_i+1]) + (1-p_i)E[Z_{i-1}]\\<br>E[Z_i] &amp;= E[Z_{i-1}] + p_i(2E[Y_i] + 1)<br>\end{align}<br>$$<br>那么$E[Z_n]$就是答案了。</p>
<h1 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h1><p>假设每段长度为$i$的连击贡献$f(i)$的分数，那么设（我也不知道该用什么字母）$A_i$为为经过$i$个操作以后的<strong>总分</strong>，所求是$E[A_i]$<br>$$<br>E[A_i] = p_iE[A_{i-1} + f(Y_{i-1}+1)-f(Y_{i-1})] + (1-p_i)E[A_{i-1}]<br>$$<br>那么假设$f(i) =i^3$，展开后可得<br>$$<br>\begin{align}<br>E[A_i] &amp;= p_iE[A_{i-1} + (Y_{i-1}+1)^3 - Y_{i-1}^3] + (1-p_i)E[A_{i-1}] \\<br>E[A_i] &amp;= p_i(E[A_{i-1}] + E[(Y_{i-1}+1)^3 - Y_{i-1}^3]) + (1-p_i)E[A_{i-1}] \\<br>E[A_i] &amp;= E[A_{i-1}] + p_iE[Y_{i-1}^3+3Y_{i-1}^2+3Y_{i-1}+1-Y_{i-1}^3]\\<br>E[A_i] &amp;= E[A_{i-1}] + p_iE[3Y_{i-1}^2+3Y_{i-1}+1]\\<br>E[A_i] &amp;= E[A_{i-1}] + p_i(3E[Y_{i-1}^2]+3E[Y_{i-1}] + 1)<br>\end{align}<br>$$<br>$E[Y_{i-1}]$我们之前求过，那么问题就在于怎么求$E[Y_{i-1}^2]$。<br>$$<br>\begin{align}<br>E[Y_i^2] &amp;= p_i(E[(Y_{i-1}+1)^2])\\<br>E[Y_i^2] &amp;= p_i(E[Y_{i-1}^2+2Y_{i-1}+1])\\<br>E[Y_i^2] &amp;= p_i(E[Y_{i-1}^2]+2[Y_{i-1}]+1])<br>\end{align}<br>$$<br>然后我们就应该会求$E[Y_i^2]$了吧。<br>搞清楚到底是总分还是总分的期望应该就是这道题最关键的一点了。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>$O(n)$</p>
<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;p[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        EN[i] = (EN[i - <span class="number">1</span>] + <span class="number">1</span>) * p[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        E2[i] = E2[i - <span class="number">1</span>] + (<span class="number">2</span> * EN[i - <span class="number">1</span>] + <span class="number">1</span>) * p[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lf"</span>, E2[n]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>概率期望</tag>
      </tags>
  </entry>
  <entry>
    <title>[CF201C] Fragile Bridges</title>
    <url>/2020/12/22/CF201C/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你$n$个顶点和$n-1$条边组成的链，其中每条边都有一个脆弱度$a_i$，表示这条边最多能被经过$a_i$次。问你从任何一个顶点开始最多能走多少步。</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>对于任意个一个顶点$i$来说，要么我们往左右中的一个方向走，再也不回到顶点$i$，要么我们往一个方向走回到$i$，然后再往另一个方向走，可以选择回到或者不回到$i$。</p>
<p>于是对于顶点$i$来说，从它开始能走的最远步数就是</p>
<ol>
<li>往左边走再回来的最大步数+往右边走不一定回来的最大步数</li>
<li>往右边走再回来的最大步数+往左边走不一定回来的最大步数<br>其中取最大值就是答案。</li>
</ol>
<p>那么如何求这个最大步数呢，我们以往左边走再回来的最大次数为例，记为$LB_i$，假设我们在顶点$1$，左边是边$e_1$和顶点$0$。那么此时我们可以往左来回走最大的偶数步，所以$LB_1 = \text{maxEven}(a_1)$。继续推导，假设我们在顶点$i$，那么我们要往左走偶数步，并且加上从$i-1$这个点还能回来的最大步数。只要我们能在前一条边上走偶数步（不为0），那么我们一定用这么多步走到$i-1$再走回来。所以有$LB_i = LB_{i-1} + \text{maxOdd}(a_i)$，注意如果边上的脆弱度为$1$则我们到达不了前一个顶点。</p>
<p>如果是往左边走但是不一定回来的步数，记为$LN_i$，那么$LN_i$至少得是$LB_i$，然后我们用刚才的方法可以得知，如果想要不回来，那么往左走的步数一定是奇数步，所以$LN_i = \max(LB_i, LN_{i-1} + \text{maxOdd}(a_i))$。</p>
<p>往右走的最大步数也是依次类推，注意可以利用二进制来获取$\text{maxEven}(x)$和$\text{maxOdd}(x)$，具体见代码。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>$O(n)$</p>
<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        f[i] = read&lt;<span class="keyword">int</span>&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LB[<span class="number">1</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LN[<span class="number">1</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        LB[i] = (f[i - <span class="number">1</span>] == <span class="number">1</span>) ? <span class="number">0</span> : (LB[i - <span class="number">1</span>] + (f[i - <span class="number">1</span>] &amp; (~<span class="number">1</span>)));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        LN[i] = <span class="built_in">std</span>::max(((f[i - <span class="number">1</span>] - <span class="number">1</span>) | <span class="number">1</span>) + LN[i - <span class="number">1</span>], LB[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">    RB[n] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    RN[n] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        RB[i] = (f[i] == <span class="number">1</span>) ? <span class="number">0</span> : (RB[i + <span class="number">1</span>] + (f[i] &amp; (~<span class="number">1</span>)));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        RN[i] = <span class="built_in">std</span>::max(((f[i] - <span class="number">1</span>) | <span class="number">1</span>) + RN[i + <span class="number">1</span>], RB[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll ans = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ans = <span class="built_in">std</span>::max(&#123;ans, LB[i] + RN[i], RB[i] + LN[i]&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>[UVA11982] Fantasy Cricket</title>
    <url>/2020/12/18/UVA11982/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你一张名次表，以及每个队伍的名次变化，求上一轮队伍名次有多少种可能性。</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这题想要想清楚细节并不容易，首先，如果当前排名$i$的队伍名次上涨，就意味着上一轮这个队伍的排名一定在$[i-1. n]$这个范围内，如果下降就是$[1, i - 1]$这个范围内。如果名次不变那么只有一种选择就是上一轮也排在第$i$名。</p>
<p>假设<strong>这一轮</strong>队伍的排名情况是数组$A$，<strong>上一轮</strong>队伍的排名情况是数组$B$，那么可以通过刚才推出的关系在$A,B$之间连边，具体来说假设$A_i$是上涨的，那么连接$A_i$和$B_j(j \in [i-1, n])$这几条边。最后这两个集合所组成的图一定构成一个二分图，则答案是二分图完美匹配的个数。</p>
<p>二分图完美匹配计数本身是个NP-hard问题，但是对于这道题来说，我们可以利用一些特殊性质来有效的求解。</p>
<p>我们不妨从第i名开始，分析$A,B$之间的匹配都有哪些可能。</p>
<p>如果$A_i$是上涨的，那么与$A_i$匹配的某个$B_j$一定是在$i$后面，而此时的$B_i$可以选择：</p>
<ol>
<li>匹配之前的某个$A_i$，并且这个$A_i$一定是上涨状态</li>
<li>或者不匹配任何一个之前的$A_i$，把自己留给后面的某个$A_j$去匹配</li>
</ol>
<p>如果$A_i$是下降的，那么$A_i$<strong>必须</strong>匹配某个在$i$之前的$B_j$，此时$B_i$的选择和上涨情况是一样的。<br>如果$A_i$不变，那么$A_i$只能匹配$B_i$，$B_i$也是一样。</p>
<p>我们可以发现，对于$A$集合中的元素，不考虑相等我们的决策只有：要么必须与之前某个$B_j$匹配，要么必须留到后面。<br>对于$B$中的元素，可以选择往前面某个上涨$A_i$匹配，或者留到后面。</p>
<p>我们不妨设状态为$f(i, j, k)$，代表考虑到两个集合的前$i$个元素的时候，$B$中在$i$以及$i$以前有$j$个未匹配的元素，且$A$中$i$以及$i$以前有$k$个未匹配的上涨元素。</p>
<p>那么我们分别让$A_i,B_i$做出决策：</p>
<ol>
<li>当$A_i$是上涨状态时，$A_i$留到后面匹配，因为$k$包含自己，所以不变，$B_i$在此时可以选择匹配之前某个$A_j$，这个时候$B_i$因为匹配了值，所以$j$减少1，$k$也减少1，$B_i$可以匹配之前的$k-1$个上涨元素（不包含$A_i$）中的任意一个，有$k-1$种情况。如果$B_i$也不匹配，那么$j,k$的值都不变，这种情况只有一种。</li>
<li>当$A_i$是下降状态时，$A_i$<strong>必须</strong>匹配之前的任意一个$B_j$，$B_j$被匹配了，所以$j$减少1，总共有$j-1$种可能性。而$B_i$情况和之前相同，如果选择匹配之前某个$A_j$，那么仍然有$k-1$种情况，匹配后$j,k$再减少1，而如果不匹配$j,k$不变，有一种情况。</li>
<li>当$A_i$不变时，$A_i$与$B_i$匹配，$j,k$都减少1，只有一种情况。</li>
</ol>
<p>但是这样考虑我们需要记录$i,j,k$三个状态，在题目数据范围下显然不可行，但是刚才的思考$i,j,k$都是已经算好的，如果我们考虑从之前的$i-1,j,k$中转移呢？假设这时候的$j, k$都是从$i-1$中得出的，那么在每种操作结束后的$j,k$状态会变化：</p>
<ol>
<li>当$A_i$是上涨状态时，因为多了个上涨的$A_i$，所以状态变成$i, j+1, k+1$，后续操作会生成$i, j, k$或者$i, j+1, k+1$。</li>
<li>当$A_i$是下降状态时，只多了个$B_i$，所以状态变成$i, j+1, k$，后续操作会生成$i, j, k$或者$i, j-1, k-1$。</li>
<li>当$A_i$不变时，$A_i$与$B_i$匹配，所以状态是$i, j, k$。</li>
</ol>
<p>我们可以发现$j,k$的值<strong>在任何时候都相等</strong>，于是我们可以把它合并，最终状态为$f(i, j)$代表考虑两个集合前$i$个元素的匹配，此时$i$和$i$之前的$A,B$有$j$个上涨的$A$和没匹配的$B$。</p>
<p>转移只要常数时间就可以做到，注意合并后$j，k$的偏移，到底是$j$还是$j+1$要想清楚了，至此这题就算解决了。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>$O(n^2)$</p>
<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">(<span class="keyword">int</span>&amp; d, <span class="keyword">int</span> v)</span> </span>&#123; d = (d + v) % MOD; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, S + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">n = <span class="built_in">strlen</span>(S + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dp[i][j] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (S[i] == <span class="string">'E'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            increase(dp[i][j], dp[i - <span class="number">1</span>][j]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S[i] == <span class="string">'U'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            increase(dp[i][j], (ll)dp[i - <span class="number">1</span>][j] * j % MOD);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (j) increase(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            increase(dp[i][j], (ll)dp[i - <span class="number">1</span>][j + <span class="number">1</span>] * (j + <span class="number">1</span>) * (j + <span class="number">1</span>) % MOD);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            increase(dp[i][j], (ll)dp[i - <span class="number">1</span>][j] * j % MOD);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
        <category>UVA</category>
      </categories>
      <tags>
        <tag>思维</tag>
        <tag>数学</tag>
        <tag>计数</tag>
      </tags>
  </entry>
  <entry>
    <title>软光栅化渲染器【1】</title>
    <url>/2020/12/10/Graphics/Rasterizer-1/</url>
    <content><![CDATA[<p>最近准备趁这个寒假写一个软件光栅化渲染器，重新学习图形学渲染知识的同时，也要练习自己的软件开发能力。<br>就用这个博客记录一下自己学习的过程和一些重要的知识点吧。</p>
<a id="more"></a>

<h1 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h1><h2 id="投影矩阵"><a href="#投影矩阵" class="headerlink" title="投影矩阵"></a>投影矩阵</h2><p>投影矩阵的作用就是把三维空间的物体投影到另一个三维空间中，如果物体能够被显示在屏幕内，那么投影以后的物体会在目标三维空间的一个单位立方体内。此文以OpenGL的投影方式为例，目标物体会被投影到一个由$(-1,-1,-1)$和$(1,1,1)$为顶点的正方形内。</p>
<h3 id="正交投影矩阵的推导"><a href="#正交投影矩阵的推导" class="headerlink" title="正交投影矩阵的推导"></a>正交投影矩阵的推导</h3><p>正交投影（Orthographic Projection）矩阵物体的z坐标并不会影响最终在屏幕上的成像，除非越过远近平面。整个过程其实就是将某个点$p$，如果$x$坐标在$[l, r]$内，$y$坐标在$[b, t]$内且$z$坐标在$[n, f]$范围内的点投影到$[-1, 1]^3$这个空间下。比如说某个点$x$坐标为$\frac{l+r}{2}$，那么会被映射到$0$这个值。</p>
<p>我们不妨从每个分量来考虑，假设我们考虑$x$分量，那么也就是存在一个变换$\textbf{T}_x: \mathbb{R} \to \mathbb{R}$，进行变换后$x$分量处于正确的投影位置。那么有<br>$$<br>\begin{cases}<br>\textbf{T}_x(l) = -1 \\<br>\textbf{T}_x(r) = 1<br>\end{cases}<br>$$</p>
<img src="/images/Ortho.png" class="" width="600" title="正交投影x分量示意图">
<p>显然（？）$\textbf{T}_x$是个线性变换，也就是说：<br>$$<br>\begin{cases}<br>\textbf{T}_x(l) = al + b = -1 \\<br>\textbf{T}_x(r) = ar + b = 1<br>\end{cases}<br>$$<br>解得<br>$$<br>\begin{cases}<br>a = \dfrac{2}{r - l} \\<br>b = -\dfrac{l + r}{r-l}<br>\end{cases}<br>$$<br>因为有$a, b$两个参数，所以我们不妨将原变换拓展一下，使得输入可以是一个4维向量，也就是我们的位置向量，则$\textbf{T}_x: \mathbb{R}^4 \to \mathbb{R}^4$，假设有一个向量$\vec{x} = (x\ y\ z\ 1)^{T}$，那么$\textbf{T}_x$可以表示为：<br>$$<br>\begin{align}<br>\textbf{T}_x(\vec{x}) &amp;= \begin{bmatrix}<br>\dfrac{2}{r-l}&amp;0&amp;0&amp;-\dfrac{l + r}{r-l}\\<br>0&amp;1&amp;0&amp;0\\<br>0&amp;0&amp;1&amp;0\\<br>0&amp;0&amp;0&amp;1\\<br>\end{bmatrix}\begin{bmatrix}<br>x\\<br>y\\<br>z\\<br>1<br>\end{bmatrix}\\<br>&amp;=\begin{bmatrix}<br>\dfrac{2}{r-l}x - \dfrac{l + r}{r-l}\\<br>y\\<br>z\\<br>1<br>\end{bmatrix}<br>\end{align}<br>$$<br>此时$\textbf{T}_x$的作用就是仅仅进行x分量的映射，同理可得$y,z$分量的映射矩阵：<br>$$<br>\begin{align}<br>\textbf{T}_y &amp;= \begin{bmatrix}<br>1&amp;0&amp;0&amp;0\\<br>0&amp;\dfrac{2}{t-b}&amp;0&amp;-\dfrac{t+b}{t-b}\\<br>0&amp;0&amp;1&amp;0\\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}\\<br>\textbf{T}_z &amp;= \begin{bmatrix}<br>1&amp;0&amp;0&amp;0\\<br>0&amp;1&amp;0&amp;0\\<br>0&amp;0&amp;\dfrac{2}{f-n}&amp;-\dfrac{f+n}{f-n}\\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>\end{align}<br>$$<br>正交投影矩阵其实就是对每个分量都进行这么一个线性变换，那么我们定义<br>$\textbf{T}_o$为以上三个变换的组合：<br>$$<br>\textbf{T}_o = \textbf{T}_x\textbf{T}_y\textbf{T}_z<br>$$<br>注意到这三个变换都是独立的，所以组合起来就是<br>$$<br>\begin{equation}<br>\textbf{T}_o = \begin{bmatrix}<br>\dfrac{2}{r-l}&amp;0&amp;0&amp;-\dfrac{l + r}{r-l}\\<br>0&amp;\dfrac{2}{t-b}&amp;0&amp;-\dfrac{t+b}{t-b}\\<br>0&amp;0&amp;\dfrac{2}{f-n}&amp;-\dfrac{f+n}{f-n}\\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>\end{equation}<br>$$<br>然后这就是完整的正交投影矩阵了。</p>
<h3 id="透视投影矩阵的推导"><a href="#透视投影矩阵的推导" class="headerlink" title="透视投影矩阵的推导"></a>透视投影矩阵的推导</h3><p>透视投影（Perspective Projection）矩阵和正交投影的区别在于此时物体的$z$坐标会影响其在投影空间下$x,y$坐标的值，就像人眼所看到的那样，如果离视点得近，那么物体会变大，而离得远会变小。</p>
<img src="/images/Persp.png" class="" title="100% 透视投影示意图">
<p>如图所示，这时候的映射就不像之前那么简单了，假设我们还是有一个$\vec{x}$，原先正交投影变换$\textbf{T}_o(x)$会映射$x$到一个值$\alpha$，但是在透视中，映射的值会跟$z$有关系，变成$\alpha f(z)$。</p>
<img src="/images/PerspLR.png" class="" title="100% 透视投影示意图">
<img src="/images/PerspSim.png" class="" title="100% 透视投影示意图">
<p>跟之前那幅图对比，此时不再是对$l,r$这个范围进行映射，而是对$l’, r’$进行映射。根据蓝绿两个相似三角形的原理，我们可以推出$x$和$x’$的关系：<br>$$<br>\frac{x}{x’} = \frac{z}{n} \implies x’ = x\frac{n}{z}<br>$$<br>也就是说，我们要使用这个关系还原出$x’$，再让它在$l,r$范围内进行之前的映射。问题在于，透视投影的 $x,y$ 并不在线性空间，而是有一个 $\frac{n}{z}$ 的系数，没法直接用正交投影的插值方法。于是我们可以考虑把原坐标转换到线性空间，然后在线性空间内进行正交投影，那么设 $\textbf{P}$ 为变换到线性空间的矩阵，$\textbf{T}_o$ 仍然是正交投影变换，所求变换即：<br>$$<br>\textbf{T}_o<br>\textbf{P}<br>\begin{bmatrix}<br>x\\<br>y\\<br>z\\<br>1<br>\end{bmatrix}<br>$$<br>那么现在的问题就是如何求出这个变换到线性空间的矩阵了，首先我们知道 $x, y$ 坐标都要乘以 $\frac{n}{z}$ 才能变成线性，那么不妨把 $x, y$ 都乘以 $n$，除以 $z$ 的操作可以看成把齐次坐标 $w$ 变成 $z$（否则没法表示为线性变换），即<br>$$<br>\begin{bmatrix}<br>x\\<br>y\\<br>z\\<br>1<br>\end{bmatrix}<br>\implies<br>\begin{bmatrix}<br>nx\\<br>ny\\<br>z\\<br>z<br>\end{bmatrix}<br>$$<br>这个矩阵并不难求，但是有个问题，我们并不知道 $z$ 坐标是怎么变换的。我们可能认为 $z$ 也是按照同样的方式线性变换的，但是我们要注意 $w$ 坐标的值代表 $x,y,z$ 三个坐标的值都要除以 $z$，所以变换后 $z$ 的值就永远是1了，这显然是不正确的。那么考虑到这一点我们如何求出 $z$ 的变换呢？</p>
<p>我们希望 $z$ 经过变换以后除以 $w = z$ 得到的 $z’$ 仍然等于 $z$。很遗憾，我们为了描述为一个线性变换，没法使用 $z’ = z^2$ 这样的操作，所以不妨设 $z’ = Az + B$。</p>
<p>那么对于近平面上的点，我们希望 $z’ = An + B = n^2$，远平面上的点 $z’ = Af + B = f^2$。</p>
<p>于是有<br>$$<br>\begin{cases}<br>An + B = n^2\\<br>Af + B = f^2<br>\end{cases}<br>$$<br>解方程<br>$$<br>\begin{align}<br>(f-n)A &amp;= f^2 - n^2\\<br>(f-n)A &amp;= (f-n)(f+n)\\<br>A&amp;=(f+n)<br>\end{align}<br>$$<br>$$<br>\begin{align}<br>(f+n)n + B &amp;= n^2\\<br>B&amp;=-fn<br>\end{align}<br>$$<br>此时我们已经求出 $A，B$ 的值了，那么整个的线性变换也就能表示出来了。首先我们要对 $x,y$ 坐标乘以 $n$，然后对 $z$ 坐标应用 $Az + B$ 变换，最后把 $w$ 坐标设为原来的 $z$。那么此时矩阵就可以得到：<br>$$<br>\textbf{P} = \begin{bmatrix}<br>n&amp;0&amp;0&amp;0\\<br>0&amp;n&amp;0&amp;0\\<br>0&amp;0&amp;f+n&amp;-fn\\<br>0&amp;0&amp;1&amp;0<br>\end{bmatrix}<br>$$<br>最终的投影变换矩阵就是<br>$$<br>\begin{align}<br>\textbf{T}_p &amp;= \textbf{T}_o\textbf{P}\\<br>&amp;=\begin{bmatrix}<br>\dfrac{2}{r-l}&amp;0&amp;0&amp;-\dfrac{l + r}{r-l}\\<br>0&amp;\dfrac{2}{t-b}&amp;0&amp;-\dfrac{t+b}{t-b}\\<br>0&amp;0&amp;\dfrac{2}{f-n}&amp;-\dfrac{f+n}{f-n}\\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>\begin{bmatrix}<br>n&amp;0&amp;0&amp;0\\<br>0&amp;n&amp;0&amp;0\\<br>0&amp;0&amp;f+n&amp;-fn\\<br>0&amp;0&amp;1&amp;0<br>\end{bmatrix}\\<br>&amp;=\begin{bmatrix}<br>\dfrac{2n}{r-l}&amp;0&amp;-\dfrac{l + r}{r-l}&amp;0\\<br>0&amp;\dfrac{2n}{t-b}&amp;-\dfrac{t+b}{t-b}&amp;0\\<br>0&amp;0&amp;\dfrac{f+n}{f-n}&amp;-\dfrac{2fn}{f-n}\\<br>0&amp;0&amp;1&amp;0<br>\end{bmatrix}<br>\end{align}<br>$$<br>这就是透视投影变换的推导了。注意，由于 $z’ = z^2$ 这种变换不是线性的，所以我们用线性拟合了一个变换，除以 $z$ 以后深度值和原来并不成线性关系。如下图所示，是一个反比例函数。</p>
<img src="/images/ZCurve.png" class="" width="400" title="Z坐标变换图">

<h2 id="三角形光栅化"><a href="#三角形光栅化" class="headerlink" title="三角形光栅化"></a>三角形光栅化</h2><h3 id="重心坐标"><a href="#重心坐标" class="headerlink" title="重心坐标"></a>重心坐标</h3><p>重心坐标插值是光栅化中一个至关重要的概念，任何一个三角形内的像素点的可变参数都是由构成这个三角形的三个顶点数据的重心坐标插值得到的。具体来说，有一个点$\textbf{P}$，假设三角形三个顶点分别为$\textbf{A}, \textbf{B}, \textbf{C}$，那么我们可以得到<br>$$<br>\textbf{P} = \alpha\textbf{A} + \beta\textbf{B} + \gamma\textbf{C}<br>$$<br>其中$(\alpha, \beta, \gamma)$构成了点$\textbf{P}$对三角形$\textbf{ABC}$的重心坐标。如果点$\textbf{P}$在三角形内部，则$\alpha, \beta, \gamma$必须满足：</p>
<ul>
<li>$0 \leq \alpha, \beta, \gamma \leq 1$</li>
<li>$\alpha + \beta + \gamma = 1$</li>
</ul>
<p>那么给定一个$\textbf{P}$，如何求出重心坐标呢？我们可以看这幅图</p>
<img src="/images/barycentric.png" class="" width="400" title="中心坐标示意图">

<p>此时$\textbf{P}$可以视作为向量$\vec{AC}$和$\vec{AB}$的线性组合，即<br>$$<br>\begin{align}<br>\textbf{P} &amp;= \textbf{A} + u\vec{AB} + v\vec{AC}\\<br>\textbf{P} &amp;= \textbf{A} + u(\textbf{B}-\textbf{A}) + v(\textbf{C}-\textbf{A})\\<br>\textbf{P} &amp;= \textbf{A}(1 - u - v) + u\textbf{B} + v\textbf{C}<br>\end{align}<br>$$<br>于是我们可以令重心坐标$(\alpha, \beta, \gamma)$为$(1-u-v, u, v)$. 这样做可以保证$\alpha + \beta + \gamma = 1$，并且$u,v$定义完全符合$\beta, \gamma$. 那么现在问题在于如何求出$u,v$。我们可以把这个过程规约到求解线性方程组:<br>$$<br>    \begin{align}<br>    \textbf{P} &amp;= \textbf{A} + u(\textbf{B}-\textbf{A}) + v(\textbf{C}-\textbf{A}) \\<br>    \textbf{P} - \textbf{A} &amp;= u(\textbf{B}-\textbf{A}) + v(\textbf{C}-\textbf{A})<br>    \end{align}<br>$$<br>转换一下，令$\vec{E}$为原$\vec{AB}$向量，$\vec{F}$为$\vec{AC}$，那么有：<br>$$<br>    u\vec{E} + v\vec{F} = \textbf{P}-\textbf{A}<br>$$<br>转换为矩阵形式就是求解<br>$$<br>    \begin{bmatrix}<br>    \vec{E}  &amp; \vec{F} \<br>    \end{bmatrix}<br>    \vec{x} = \textbf{P}-\textbf{A}<br>$$<br>解法就很简单啦，只要求出左边这个矩阵的逆，然后乘以$\textbf{P}-\textbf{A}$，解出来$\vec{x}$，那么$\vec{x}$向量的每个分量就是$u,v$了。<br>接下来我们根据得到的$u,v$判断这个重心坐标是否合法即可，然后$(1-u-v, u, v)$就是我们想要的重心坐标。<br>这个方法适用于二维情形，尤其是光栅化阶段，只要预先求出左边$EF$矩阵的逆，然后对于每个进来的像素点乘以$\textbf{P}-\textbf{A}$就可以很轻松的计算重心坐标了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三角形三个顶点储存在 v 数组里</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 直接得到EF矩阵的逆</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">glm::<span class="function">mat2 <span class="title">interpTransform</span><span class="params">(v[<span class="number">1</span>] - v[<span class="number">0</span>], v[<span class="number">2</span>] - v[<span class="number">0</span>])</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">interpTransform = glm::inverse(interpTransform);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// ......</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 对于每个像素点计算重心坐标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">glm::vec2 x = interpTransform * (pos - v[<span class="number">0</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">glm::vec3 bary = glm::vec3(<span class="number">1</span> - x.x - x.y, x.x, x.y);</span></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>图形学</category>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round #688 (Div. 2) 选解</title>
    <url>/2020/12/04/CF/CF688/</url>
    <content><![CDATA[<h1 id="Problem-D"><a href="#Problem-D" class="headerlink" title="Problem D"></a>Problem D</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有$n$个关卡，每个关卡到达的时候可以有一个存档点，每次通过关卡失败可以回到最近存档点。每个关卡有$\dfrac{1}{2}$几率通过，你要构造一个期望$k$步能到终点的关卡设计方式。</p>
<a id="more"></a>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这题本质上是一个马尔可夫链模型，可以画出一个马尔可夫链转移模型。假设终点是$n$，我们要求的是到达第$n+1$关的期望步数。设$E[i]$为到达$i$点的期望步数，则有<br>$$<br>\begin{equation}<br>\label{T1}<br>E[n + 1] = E[n+1|n] + E[n|n+1] + \dots + E[2|1]<br>\end{equation}<br>$$<br>假设所有点都有存档点，我们从$E[2|1]$开始计算，有<br>$$<br>E[2|1] = \frac{E[2|1]}{2} + 1<br>$$<br>因为我们先要花一步闯关，然后有一半的几率回到第一关开始重新过，解得<br>$$<br>E[2|1] = 2<br>$$<br>而<br>$$<br>E[3|2] = \frac{E[3|2]}{2} + 1<br>$$<br>同理可得<br>$$<br>E[n+1|n] = \frac{E[n+1|n]}{2} + 1<br>$$<br>所以如果都有存档点，那么每个相邻转移期望都是$2$，通过式子$\ref{T1}$所有的期望加起来就是$2n$。</p>
<p>那如果存档点不在上一关，而是在之前得某一关呢？此时需要回到存档点的关卡，令最近存档点为$\alpha$，我们有如下期望公式<br>$$<br>\begin{align}<br>E[i|i-1] &amp;= \frac{E[i|\alpha]}{2} + 1\\<br>&amp;=\frac{\sum_{j=\alpha+1}^{i} E[j|j-1]}{2} + 1<br>\end{align}<br>$$<br>把熟悉的身影从求和符号中提取出来<br>$$<br>\begin{align}<br>E[i|i-1]&amp;=\frac{E[i|i-1]}{2} + \frac{\sum_{j=\alpha+1}^{i-1} E[j|j-1]}{2} + 1\\<br>\frac{E[i|i-1]}{2} &amp;= \frac{\sum_{j=\alpha+1}^{i-1} E[j|j-1]}{2} + 1 \\<br>E[i|i-1]&amp;=\sum_{j=\alpha+1}^{i-1} E[j|j-1]+2<br>\end{align}<br>$$<br>类比成以下的递推公式<br>$$<br>T(i) = \sum_{j=1}^{i-1} T(j) + 2<br>$$<br>代换，令$S(i) = \sum_{j=1}^{i} T(j)$，则有<br>$$<br>\begin{align}<br>S(i) - S(i - 1) &amp;= S(i - 1) + 2 \\<br>S(i) &amp;= 2S(i - 1) + 2<br>\end{align}<br>$$<br>再次令$G(i) = \frac{S(i)}{2^i}$<br>$$<br>G(i) = G(i-1)+2^{-i+1}<br>$$<br>则有<br>$$<br>G(i) = \sum_{j=1}^{i} 2^{-j+1} = 2 - (\frac{1}{2})^{i-1}<br>$$<br>此时<br>$$<br>S(i) = 2^{i+1} - 2<br>$$<br>则<br>$$<br>T(i) = S(i - 1) + 2 = 2^{i}<br>$$<br>好，花了一大堆功夫推出了个$T(i) = 2^{i}$，那么这个$i$其实就是期望式中的$i-\alpha$。所以<br>$$<br>E[i|i-1]=2^{i-\alpha}<br>$$<br>所以整体来讲，每一段连续的0区间，假设长度为$k=i-\alpha$，则贡献是<br>$$<br>E[i|i-1] + \dots + E[\alpha + 1 | \alpha] = \sum_{i = 1}^{k} 2^k = 2^{k+1} - 2<br>$$<br>注意，这里的$i$是有存档点的。我们假设有序列$1000$，那么全部通过的期望步数就是$2^{4+1} - 2$。我们可以构造这样的$10\dots$序列，每构造一次$n$的值就会减少$2^{k+1} - 2$，观察到无论怎么取0和1，我们的期望步数都只会增加个偶数，所以奇数一定构造不出来，至于为什么一定能把一个偶数构造出$2^{k+1} - 2$的分解，emmm</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(\log^2{n})$</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">60</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll c = (<span class="number">1L</span>L &lt;&lt; (i + <span class="number">1</span>)) - <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (n &gt;= c) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            n -= c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            v.push_back(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++) v.push_back(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, v.size());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> a : v) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<hr><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>比赛选解</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 99 选解</title>
    <url>/2020/12/02/CF/CFEDU99/</url>
    <content><![CDATA[<h1 id="Problem-A"><a href="#Problem-A" class="headerlink" title="Problem A"></a>Problem A</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>可以把$g(x)=\dfrac{x}{f(f(x))}$看成$x$除以去掉前后缀的0以后的数，由于$x$没有前导0，所以只会去掉后缀0。<br>考虑每个1到$n$的$x$，一般情况下$f(f(x))=x$，当$x$是$10^k$的倍数时，得到$f(f(x))=\dfrac{x}{10^k}$，所以$g(x)=10^k$。于是我们只需要知道1到$n$有多少个$10^k$，$k$互不相同，也就是$n$有多少位数。</p>
<a id="more"></a>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(1)$</p>
<hr>

<h1 id="Problem-B"><a href="#Problem-B" class="headerlink" title="Problem B"></a>Problem B</h1><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>假设我们一直使用操作1，会形成数列<br>$$1+2+3+\dots+x$$<br>如果此时我们进行操作2，有<br>$$1+2+3+\dots+x-1$$<br>然后下一步继续操作1，可以得到<br>$$1+2+3+\dots+x-1+(x+2) = 1+2+3+\dots+x+(x+1)$$<br>如果我们继续加到$n$，相比于一直用操作1，我们得到的是<br>$$1+2+3+\dots+x+(x+1)+(x+3)+\dots+n$$<br>我们会发现最终结果少了一个$x+2$。<br>由此得出结论，假设我们在第$x$次操作使用操作2，那么最终我们的结果会减少$x+1$。同时，假设我们一直使用操作1，最终结果超出$n$的时候，这个差值一定小于$n$，假设这个差值是$d$，那么我们可以在第$d-1$次操作使用操作2。有一个例外是如果刚好超出1，此时我们没有办法减少这个值，必须最后多使用一次操作2。</p>
<h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(n)$</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> x = read&lt;<span class="keyword">int</span>&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sum += i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cnt++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (sum &gt; x) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> d = sum - x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (d == <span class="number">1</span>) cnt++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>比赛选解</tag>
      </tags>
  </entry>
  <entry>
    <title>[UVA1642] 魔法GCD</title>
    <url>/2020/12/01/UVA1642/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你一个正整数数列，求<br>$$<br>\max_{1 \leq l\leq r \leq n} \left\{ \gcd(a_l,…,a_r) \times (r- l + 1) \right\}<br>$$</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>一开始想着枚举$gcd$然后计算左右边界，还猜了个错的结论，真正做法应该是枚举右边界，然后计算从右边界开始所有不同$gcd$值所在的左边界。</p>
<p>因为每个$gcd$的值我只关心最左边的那一个，所以我只需要知道有哪些不同的$gcd$即可，由于$gcd$必是右端点的一个约数，所以每次需要考察的左端点个数是在$\ln n$到$\sqrt{n}$这个级别的。</p>
<p>从左到右枚举右端点的时候，我们可以动态维护所有的$gcd$值，以及其最左端点。当加入一个新的右端点$x$时，所有之前的这些$gcd$值需要跟$x$取$gcd$，然后重新判断是否是最左的端点，假设有$k$个不同$gcd$值，那么这个操作可以$O(k\log n)$完成。也就是总体时间复杂度$O(n\log^2{n})$。但是实际情况远好于这个复杂度，为什么呢？假设$x=10$，且之前$gcd$为$1,2,5,10$。你会发现如果想要把他们都构造出来是做不到的，由于2和5的存在，10一定不会和他们同时出现，所以实际长度远小于约数个数。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>趋近于$O(n\log{n})$</p>
<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll A[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll gcd;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Node(ll g, <span class="keyword">int</span> i) : gcd(g), i(i) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> T = read&lt;<span class="keyword">int</span>&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (T--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) A[i] = read&lt;ll&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; G;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        G.push_back(&#123;A[<span class="number">1</span>], <span class="number">1</span>&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll ans = A[<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            G.push_back(&#123;A[i], i&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; newG;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : G) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (A[i] % v.gcd) v.gcd = <span class="built_in">std</span>::__gcd(v.gcd, A[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (newG.empty() || newG.back().gcd &lt; v.gcd) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    newG.push_back(v);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    ans = <span class="built_in">std</span>::max(ans, v.gcd * (i - v.i + <span class="number">1</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            G = newG;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
        <category>UVA</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>[UVA1393] Highways</title>
    <url>/2020/11/29/UVA1393/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>求一张$n\times m (n,m\leq 300)$的网格完全图里面，有多少条不同的直线是能够穿过至少两个顶点的，并且这个直线不能是水平或者竖直的。</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>先说一个比较直观的解法，既然要求直线，那么我们可以从枚举斜率和偏移入手。首先我们可以枚举任意两点，如果他们能组成符合条件的直线，假设这两个点之间的向量为$(x,y)$，那么$x,y$必定互质。否则我们就会重复记录这条直线，同时$x,y$不能有0。</p>
<p>于是我们可以枚举所有符合条件的$(x,y)$向量，这和Trees in a Wood那道题要求的东西很像。对于所有这样的向量，我们算出它的起点可能在网格图中的哪些坐标上。首先加上向量以后不能出界，否则这样的点对不会在原图中存在，其次不能叠加，否则会重复记录。不能出界很好计算，假设这个向量是$(x,y)$，那么在$(n-x,m-y)$之内的点都不会出界。不能叠加稍微有点难度，通过画图可以看出，对于在$(n-x, m-y)$这个范围内的点，只有左下角的第一层是可以取的，之后的点一定会存在一个斜率和偏移都相同的直线，也就总共有$(n-x-x)\times (m-y-y)$个点是不能取的，把这些点减去即可。</p>
<p>还有一个关键点是对于每一个这样的直线，一定存在一个与其中心对称的直线也符合要求，所以我们可以只用考虑射向右上角的直线，然后乘以2就是最终答案。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>$O(nm\log{n})$那个log是来自判定互质。</p>
<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">300</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">300</span>; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (<span class="built_in">std</span>::__gcd(i, j) != <span class="number">1</span>) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            G[i][j] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a, b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!a) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (!G[i][j]) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                n = a - i, m = b - j;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> c = <span class="built_in">std</span>::max(<span class="number">0</span>, a - i * <span class="number">2</span>) * <span class="built_in">std</span>::max(<span class="number">0</span>, b - j * <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ans += n * m - c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans * <span class="number">2</span> &lt;&lt; <span class="string">'\n'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
        <category>UVA</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>[UVA10214] Trees in a Wood</title>
    <url>/2020/11/29/UVA10214/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>求在一个$a\times b$的网格中，从原点看过去，能看到多少个没被遮挡的点。这题主要就是求这个数目*4+4的值除以总数。</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>画图可发现，如果某个点$(x,y)$从原点看过去会被遮挡，那么一定有一个点$(a,b)$存在某个正整数$k$使得$x=ka, y=kb$。也就是说，$(x,y)$是某个点放大后得到的，此时$\gcd(x,y)\neq 1$。所以问题转化为求<br>$$<br>\sum_{i=1}^{a}\sum_{j=1}^{b} [\gcd(i, j) = 1]<br>$$<br>通过数论函数定义把$[\gcd(i, j) = 1]$进行变换<br>$$<br>\begin{align}<br>&amp;\sum_{i=1}^{a}\sum_{j=1}^{b} \sum_{d|gcd(i,j)} \mu(d) \\<br>=&amp;\sum_{d=1}^{\min(a,b)} \mu(d) \sum_{i=1}^{\lfloor \frac{a}{d} \rfloor}\sum_{j=1}^{\lfloor \frac{b}{d}  \rfloor} \\<br>=&amp;\sum_{d=1}^{\min(a,b)} \mu(d) \lfloor \frac{a}{d} \rfloor \lfloor \frac{b}{d}  \rfloor<br>\end{align}<br>$$<br>我们可以预处理莫比乌斯$\mu$函数，此时求解每个询问只要计算从1到$\min(a,b)$以上公式的和即可，复杂度$O(\min(a,b))$。当然也可以优化到$O(\sqrt{\min(a,b)})$，使用整除分块即可。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>$O(\sqrt{\min(a,b)})$</p>
<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pref[<span class="number">1</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 预处理莫比乌斯函数以及其前缀和</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAXV - <span class="number">5</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!nop[i]) primes[++tot] = i, mu[i] = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * primes[j] &lt;= MAXV - <span class="number">5</span>; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            nop[i * primes[j]] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!(i % primes[j])) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                mu[i * primes[j]] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            mu[i * primes[j]] = -mu[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pref[i] = pref[i - <span class="number">1</span>] + mu[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a, b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!a) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> top = <span class="built_in">std</span>::min(a, b);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll K = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 计算公式，这里我用了整除分块</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= top; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> up = <span class="built_in">std</span>::min(&#123;top, a / (a / i), b / (b / i)&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            K += (ll)(pref[up] - pref[i - <span class="number">1</span>]) * (a / i) * (b / i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            i = up;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        K = K * <span class="number">4</span> + <span class="number">4</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll tot = (ll)(a * <span class="number">2</span> + <span class="number">1</span>) * (b * <span class="number">2</span> + <span class="number">1</span>) - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.8f\n"</span>, K / (<span class="keyword">double</span>)(tot));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
        <category>UVA</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>[UVA11440] Help Tomisu</title>
    <url>/2020/11/28/UVA11440/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你两个数$N,M (\leq 10^7, N-M\leq 10^5)$，求从2到$N!$有多少个数所有素因子都大于$M$。</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先从所有素因子都大于$M$入手，一个显而易见的结论就是它一定由大于$M$的素数组成，也就是说每个素因子都与$M$以及小于$M$的数互质，那么也一定和$M!$互质。<br>那么有引理：一个非1的数与$M!$互质，当且仅当它的最小素因子大于$M$。<br>证明：反向显然，因为$M!$没有任何一个数能成为一个大于$M$的质数的约数。正向则说明这个数并不包含任何1到$M$的约数，那么这个数只能是一个质数，并且一定大于$M$，否则一定被$M!$包含。<br>于是我们只要求出$N!$内与$M!$互质的数，然后减去1就是答案了。</p>
<p>由于$M!$是$N!$的约数，所以这里面一定有$\dfrac{N!}{M!}$个$M!$，对于每个$M!$，$\varphi(M!)$就是$M!$内与$M!$互质的数的个数，所以我们$N!$内与$M!$互质的数的个数为<br>$$<br>\varphi(M!)\dfrac{N!}{M!}<br>$$<br>预处理$\varphi(i!)$和阶乘即可$O(\log m)$回答每个询问。这题的模数是$10^8+7$，有点坑。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>预处理$O(10^7)$，回答$O(\log m)$。</p>
<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> fact[MAXV], phif[MAXV];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[MAXV / <span class="number">10</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> nop[MAXV];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fastExp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> p, <span class="keyword">int</span> mod)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (p) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>) t = (ll)t * a % mod;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        a = (ll)a * a % mod;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    fact[<span class="number">0</span>] = fact[<span class="number">1</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAXV - <span class="number">5</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        fact[i] = (ll)fact[i - <span class="number">1</span>] * i % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!nop[i]) primes[++tot] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * primes[j] &lt;= MAXV - <span class="number">5</span>; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            nop[i * primes[j]] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!(i % primes[j])) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    phif[<span class="number">1</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">1</span>; i &lt;= MAXV - <span class="number">5</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i == primes[j]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            phif[i] = (ll)phif[i - <span class="number">1</span>] * (i - <span class="number">1</span>) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            j++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            phif[i] = (ll)phif[i - <span class="number">1</span>] * i % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!(n + m)) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> mul = (ll)fact[n] * fastExp(fact[m], MOD - <span class="number">2</span>, MOD) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        mul = (mul + MOD) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> c = (ll)phif[m] * mul % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (c + MOD - <span class="number">1</span>) % MOD &lt;&lt; <span class="string">'\n'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
        <category>UVA</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>[CSP-S 2020 T3] 函数调用</title>
    <url>/2020/11/27/CSP-S-2020-T3/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你一个DAG的函数调用关系，以及每个函数的作用（只有加法，乘法以及调用其他函数），求顺序调用$Q$个函数以后数列变成什么样子。</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>正向计算每个元素被贡献了多少很困难，这时候要用到加法和乘法顺序执行的性质。<br>乘法和加法可能交替执行，所以如果先进行了加法，把某个元素增加了$x$，那么之后的每一个乘法都会使$x$在最终贡献中乘上所有乘法操作的积。假设在加法之后执行了$n$个乘法，每个乘法给所有元素乘上了$q_i$，那么加法操作最终的贡献为<br>$$<br>x\prod_{i=1}^{n} q_i<br>$$<br>利用这个性质，我们可以倒序维护一个当前的乘积，如果遇到加法就把这个乘积作为贡献次数放在加法上。但是问题来了，由于有第三类操作的存在，我们需要先求出每一个节点的后续节点总共执行了多少次乘法操作。同时为了计算每个加法的贡献次数，我们需要使用像线段树一样标记下传的方式获得正确的贡献次数。</p>
<p>假设我们调用了函数$f_i$，此时倒序的乘积为$x$，那么如果$f_i$是个加法函数，就应该多执行$x$次，如果$f_i$拥有子节点，那么那么就把$x$作为标记下传到子节点上。要注意的是，$f_i$的子节点有可能有带乘法的节点，需要把这些贡献也乘到$x$。</p>
<p>一开始没有想到这个性质，所以强行正向求只得了50分，不应该求每一个元素被加了多少，而是求每个加法操作被乘积操作增强了多少次。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>统计每个节点的乘积$O(n)$，拓扑排序和标记下传用了$O(m + \sum C_i)$，总体时间复杂度$O(n+m+q+\sum C_i)$.</p>
<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Info</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> mul;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; add;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Function</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> x, y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; calls;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> vis[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line">Function func[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> A[MAXN], tag[MAXN], mul[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> indeg[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMul</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (vis[id]) <span class="keyword">return</span> mul[id];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Function&amp; f = func[id];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    vis[id] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (f.type == <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> mul[id] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f.type == <span class="number">2</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> mul[id] = f.x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll m = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> a : f.calls) m = m * getMul(a) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> mul[id] = m;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        A[i] = read&lt;<span class="keyword">int</span>&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;func[i].type);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (func[i].type == <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;func[i].x, &amp;func[i].y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (func[i].type == <span class="number">2</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;func[i].x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> v = read&lt;<span class="keyword">int</span>&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                func[i].calls.push_back(v);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                indeg[v]++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">std</span>::reverse(func[i].calls.begin(), func[i].calls.end());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vals;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> c = read&lt;<span class="keyword">int</span>&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        vals.push_back(c);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::reverse(vals.begin(), vals.end());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> curmul = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : vals) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        tag[c] += curmul;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        tag[c] %= MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        curmul = (ll)curmul * getMul(c) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        A[i] = (ll)A[i] * curmul % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 拓扑排序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (func[i].type == <span class="number">3</span> &amp;&amp; !indeg[i]) Q.push(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> v = Q.front();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Q.pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> mul1 = tag[v];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : func[v].calls) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            tag[a] += (ll)mul1 % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            tag[a] %= MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            mul1 = (ll)mul1 * getMul(a) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!(--indeg[a])) Q.push(a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (func[v].type == <span class="number">3</span>) tag[v] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (func[i].type == <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            A[func[i].x] += (ll)func[i].y * tag[i] % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            A[func[i].x] %= MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>[NC 21340] 网格游戏</title>
    <url>/2020/08/08/NC21340/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>有一个游戏平板上面有$N\times M$个格子，一开始每个格子都是关闭的，每个格子里面都有一个标记。<br>已知每种标记恰好出现两次，也就是一共有$K=\dfrac{NM}{2}$种标记<br>规定一次移动为依次(one by one不是同时)打开一对格子查看里面的标记，如果标记不一样，格子会自动关闭，但是你过目不忘。如果标记是一样的，格子从此就一直保持打开状态，当所有格子都打开时游戏结束。<br>请算出游戏结束的最少期望步数。</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先肯定是要推期望式子，考虑一下每次操作都有哪些状态发生改变。如果这次操作成功得到两个相同颜色的格子，那么我们就可以少考虑一种颜色。如果失败了，我们能得到两种颜色的位置。</p>
<p>于是我们可以设 $f(i,j)$ 为：我们已经匹配了$i$种颜色，此时有$j$种未匹配的颜色我们知道它的位置的期望步数。</p>
<p>在状态 $(i, j)$ 下，我们有 $R=\dfrac{NM}{2} - 2i - j$ 个格子可以去选择，在最优方案下，我们不应该选任何已经知道颜色的格子，这样才能将信息最大化。那么加下来的状态会随着你选择的格子而改变：</p>
<ol>
<li>如果第一次选择的格子刚好和某个已知颜色相同，那么第二次就直接选那个已知颜色，此时操作数+1，我们的状态转移到 $(i + 1, j - 1)$。那么选到某个已知格子的概率就应该是 $p = \dfrac{j}{R}$。</li>
<li>如果和已知颜色不同，那么可能是选中两个不同的未知颜色格子，此时新增两个未知格子，于是状态变成 $(i, j + 2)$。选中不同格子的概率是 $p_0 = \dfrac{R-j}{R}$，第二次再选一个不同格子的概率是 $p_1=\dfrac{R-j-2}{R-1}$，总体概率为 $p_0p_1$。</li>
<li>如果选的是两个相同未知颜色的格子，那么多匹配了一种颜色，状态变成 $(i+1, j)$。概率 $p_1=\dfrac{1}{R-1}$。</li>
<li>如果选的第一个格子和已知不同，但是第二个和已知相同，此时我们失败一次，但是马上我们就可以把第二个颜色匹配上，需要花两次操作，状态变成 $(i+1,j)$，多一个已知元素和少一个抵消。概率 $p_1=\dfrac{j}{R-1}$。</li>
</ol>
<p>于是我们就可以利用这几种情况得到递推公式，最终结果即为 $f(K,0)$。但是如果这样推会有一个问题，对于一个状态，转移出去的情况概率是确定的，但是转移到它的状态却无法保证概率是确定的，因为这个概率完全由转移到它的状态决定，而且可能有多种方案转移到它，所以非常难以计算。</p>
<p>于是我们可以倒着推，我们知道一个起始状态 $(0, 0)$。于是我们可以从 $(K,0)$ 回推到 $(0,0)$，因为每个状态转移的方式是固定的，所以我们的公式看起来像是这样：<br>$$<br>f(x) = \sum_y (f(y) + v_y) * p_y<br>$$<br>其中 $y$ 就是上述的操作集合，$p_y$是这个操作发生的概率。再注意一下边界条件我们就可以完成dp了。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>状态是$O(K^2)$的，转移是$O(1)$级别，所以总体$O(K^2)$。</p>
<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    N = n * m;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    M = n * m / <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dp[M][<span class="number">0</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = M - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = M - i; j &gt;= <span class="number">0</span>; j--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 可选的数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> rest = N - i * <span class="number">2</span> - j;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (j &gt;= <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// 刚好和已知颜色相同，那么就直接选那个已知颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">double</span> p1 = j / (<span class="keyword">double</span>)rest;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                dp[i][j] += (dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>) * p1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 和已知颜色不同，要么增加两个新的已知颜色，要么直接消掉，要么多一步消掉</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">double</span> p2 = (rest - j) / (<span class="keyword">double</span>)rest;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 情况1：选择两个未知不同颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (rest - j - <span class="number">1</span> &gt;= <span class="number">3</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">double</span> p3 = (rest - j - <span class="number">2</span>) / (<span class="keyword">double</span>)(rest - <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                dp[i][j] += (dp[i][j + <span class="number">2</span>] + <span class="number">1</span>) * p2 * p3;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 情况2：选择两个未知相同颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (rest - j &gt;= <span class="number">2</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">double</span> p3 = <span class="number">1</span> / (<span class="keyword">double</span>)(rest - <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                dp[i][j] += (dp[i + <span class="number">1</span>][j] + <span class="number">1</span>) * p2 * p3;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; rest - <span class="number">1</span> &gt;= j) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// 情况3：第二步选到已知颜色，于是我们失败一次然后直接消掉</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">double</span> p3 = j / (<span class="keyword">double</span>)(rest - <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                dp[i][j] += (dp[i + <span class="number">1</span>][j] + <span class="number">2</span>) * p2 * p3;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.10lf\n"</span>, dp[<span class="number">0</span>][<span class="number">0</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>概率期望</tag>
      </tags>
  </entry>
  <entry>
    <title>[NC 21337] 牛牛的回文串</title>
    <url>/2020/07/31/NC21337/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你一个字符串$S(|S|\leq 50)$，以及$m$个操作，这些操作可以分为：</p>
<ol>
<li>在任意位置增加一个字符$x$</li>
<li>删除一个字符$x$</li>
<li>将字符$x$改变成字符$y$</li>
</ol>
<p>每个操作都有一个代价$c_i$，求最少需要多少代价把$S$变成回文串。</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>有增删改操作乍一看无从下手，但是如果我们仔细想想回文串的性质还是能发现一些规律的。</p>
<p>对于字符串$S$来说，如果$|S| \leq 1$，那么$S$是回文串。同时有$S’ = xSx$，也就是两边加上相同的字符，那么$S’$也是回文串。那么反过来，如果知道$S[1], S[n]$相同，我们就可以把$S[1, n]$是不是回文串这个问题分解为$S[2, n-1]$是否是回文串。</p>
<p>这就提醒我们，可以用区间dp去求解这个问题。设$dp[i][j]$为将字符串$S$的$[i, j]$区间内的字符通过增删改变成回文串所需的最小代价，然后我们就可以利用大区间以来小区间结果的方式递推。</p>
<p>但是有个问题，增删改如何表示成状态的转移呢？以字符串$S = \text{aabc}$为例。<br>如果我们想让$S$变成回文串，先要保证$S$的左右端点相同，那么可以有以下几种方法：</p>
<ol>
<li>左边删去$a$，此时问题变成$S’=\text{abc}$变成回文串的最小代价，加上删除一个$a$的代价，即$dp[i+1, j] + del(a)$。</li>
<li>右边增加一个$a$，此时字符串变成 $\textbf{a}\text{abc}\textbf{a}$ ，那么问题被分解成了$S’=\text{abc}$变成回文串的最小代价，加上增加一个$a$的代价。此时我们相当于消去了左边的$a$，即$dp[i+1, j] + add(a)$。</li>
<li>我们把左边换成右边的字符，或者右边字符换成左边，即 $\text{aab}\textbf{a}$ 或 $\textbf{c}\text{abc}$，由于两端相等消掉，所以转移到$dp[i+1, j-1]$。</li>
<li>两端都换成一个其他字符，然后一起消掉，所以转移到$dp[i+1, j-1]$。</li>
</ol>
<p>其中方法1，2可以看成对一个字符的操作，所以我们只需要选增删字符$x$的最小代价。</p>
<p>但是这题还没完，因为题目给出了$m$个操作，所以不一定所有字符都可以变换，而且还有连环改变这种操作。所以为了求出每次字符变成另一个字符的最小代价，我们需要使用floyd最短路算法。同时，方法1，2还可以分解为：</p>
<ol>
<li>先增加再改变，$\text{aabc}\textbf{b} \implies {\text{aabc}\textbf{a}}$。</li>
<li>先改变再删除，$\textbf{x}\text{abc} \implies \text{abc}$。</li>
<li>增加连环改变，$\text{aabc}\textbf{b} \implies \text{aabc}\textbf{x} \implies \textbf{x}\text{abc}\textbf{x}$。</li>
</ol>
<p>尤其是最后一种，看了样例4才想到，算是比较难想的一种情况。总之，我们要保证每次增删改操作的代价都是最小的，然后进行dp代价才会最小。</p>
<p>还有一个要注意的地方是因为第三个分解方式的原因，如果使用的INF太大，会导致溢出，所以这里我把$\text{0x3f}$换成了$\text{0x1f}$。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>预处理需要花费$O(26^3)$的时间，dp需要$O(26n^2)$的时间，所以总时间复杂度大概是$O(26n^2)$</p>
<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll G[MAXN][MAXN], c[MAXN], dp[MAXV][MAXV];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> text[MAXV], tmp[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line">ll add[MAXN], del[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">umin</span><span class="params">(ll&amp; x, ll v)</span> </span>&#123; x = min(x, v); &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Floyd最短路</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; k++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                G[i][j] = min(G[i][j], G[i][k] + G[k][j]);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 计算所有可能的分解方式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        c[i] = min(add[i], del[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (i != j) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// 分解1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                c[i] = min(c[i], add[j] + G[j][i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// 分解2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                c[i] = min(c[i], G[i][j] + del[j]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// 分解3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; k++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    c[i] = min(c[i], G[i][k] + add[j] + G[j][k]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, text + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    n = <span class="built_in">strlen</span>(text + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) text[i] -= <span class="string">'a'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(G, <span class="number">0x1f</span>, <span class="keyword">sizeof</span>(G));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(add, <span class="number">0x1f</span>, <span class="keyword">sizeof</span>(add));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(del, <span class="number">0x1f</span>, <span class="keyword">sizeof</span>(del));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x1f</span>, <span class="keyword">sizeof</span>(dp));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) G[i][i] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dp[i][i] = dp[i][i - <span class="number">1</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, tmp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">char</span> c1, c2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (tmp[<span class="number">0</span>] == <span class="string">'a'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">scanf</span>(<span class="string">" %c %d"</span>, &amp;c1, &amp;x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            add[c1 - <span class="string">'a'</span>] = x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmp[<span class="number">0</span>] == <span class="string">'e'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">scanf</span>(<span class="string">" %c %d"</span>, &amp;c1, &amp;x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            del[c1 - <span class="string">'a'</span>] = x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">scanf</span>(<span class="string">" %c %c %d"</span>, &amp;c1, &amp;c2, &amp;x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            G[c1 - <span class="string">'a'</span>][c2 - <span class="string">'a'</span>] = x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cal();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>; l &lt;= n; l++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - l + <span class="number">1</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> j = i + l - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (text[i] == text[j]) umin(dp[i][j], dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 方法1，2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            umin(dp[i][j], dp[i + <span class="number">1</span>][j] + c[text[i]]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            umin(dp[i][j], dp[i][j - <span class="number">1</span>] + c[text[j]]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 方法3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            umin(dp[i][j], dp[i + <span class="number">1</span>][j - <span class="number">1</span>] +</span></pre></td></tr><tr><td class="code"><pre><span class="line">                               min(G[text[i]][text[j]], G[text[j]][text[i]]));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 方法4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; <span class="number">26</span>; r++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                umin(dp[i][j],</span></pre></td></tr><tr><td class="code"><pre><span class="line">                     dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + G[text[i]][r] + G[text[j]][r]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (dp[<span class="number">1</span>][n] == dp[<span class="number">0</span>][<span class="number">1</span>]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[<span class="number">1</span>][n]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>[CF1139D] Steps to One</title>
    <url>/2020/07/26/CF1139D/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>一开始有一个空集合$S$，你每次可以往里放入一个从$1$到$m$的数，如果里面的数的$\gcd$为1则停下。求期望多少次后会停下。</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先我们知道期望公式为$\sum_{x} xp(x)$，但是很可惜，由于步数可以到无穷，所以貌似不太好从这里入手。<br>于是我们考虑使用期望递推式，令$f(i)$为当前集合内元素$gcd$为$i$，期望需要多少步后停下。很显然$f(1)=0$，那么对于$m=2, f(2)$来说，总共$m$种选择，要么下一步加入的这个数是个偶数，那么又回到$f(2)$，要么是个奇数我们直接跳到$f(1)$的结果，所以$f(2) = 1 + \frac{f(2)}{2} + \frac{f(1)}{2}$。也就是说，对于$f(i)$，有：<br>$$<br>f(i) = 1 + \sum_{j=1}^{m} \frac{f(\gcd(i, j))}{m}<br>$$<br>由于$\gcd(i, j)$有可能等于$i$，所以我们要进行一些消元操作，把这些数移到右边。这样的数总共有$\lfloor\frac{m}{i}\rfloor$个，所以可以改写为：<br>$$<br>f(i) = 1 + \sum_{j=1, \gcd(i, j) \neq i}^{m} \frac{f(\gcd(i, j))}{m} + \frac{\lfloor\frac{m}{i}\rfloor f(i)}{m}\\<br>\frac{m - \lfloor\frac{m}{i}\rfloor}{m}f(i) = 1 + \sum_{j=1, \gcd(i, j) \neq i}^{m} \frac{f(\gcd(i, j))}{m} \\<br>$$<br>于是得到最终式子<br>$$<br>\begin{equation}<br>f(i) = \frac{m + \sum_{j=1, \gcd(i, j) \neq i}^{m} f(\gcd(i, j))}{m - \lfloor\frac{m}{i}\rfloor}<br>\end{equation}<br>$$<br>那么最终的答案就可以写成$Ans = 1+\frac{\sum_i^{m} f(i)}{m}$<br>然而这个式子不化简递推至少需要$O(m^2\log{m})$的时间复杂度，所以考虑枚举$\gcd(i, j)$，这个值一定是$i$的约数。<br>$$<br>\sum_{j=1}^{m} f(\gcd(i, j)) = \sum_{d|i} f(d) \sum_{j=1}^{m} [\gcd(i, j) == d]<br>$$<br>然后便是$\gcd$莫比乌斯反演的标准套路了<br>$$<br>\begin{align}<br>S &amp;= \sum_{d|i} f(d) \sum_{j=1}^{\lfloor \frac{m}{d} \rfloor} \bigg[\gcd\bigg(\frac{i}{d}, j\bigg) == 1\bigg] \\<br>&amp;= \sum_{d|i} f(d) \sum_{j=1}^{\lfloor \frac{m}{d} \rfloor} \sum_{g|\gcd(i/d, j) } \mu(g) \\<br>&amp;= \sum_{d|i} f(d) \sum_{g|i/d} \mu(g) \lfloor\frac{m}{dg} \rfloor<br>\end{align}<br>$$<br>然后又是老套路令$T=gd$，并且我们直接枚举$T$，此时$g = \frac{T}{d}$<br>$$<br>\begin{equation}<br>S = \sum_{T|i} \lfloor\frac{m}{T} \rfloor \sum_{d|T} \mu\bigg(\frac{T}{d}\bigg) f(d)<br>\end{equation}<br>$$<br>然后我们刨去$f(d=i)$的部分，但是观察到当$f(d=i)$的时候对整个式子的贡献就是它自己，因为$\mu(1)$和前面那坨都是1，而我们在推式子 $(1)$ 的时候已经把$f(d=i)$的贡献丢掉了，所以此时我们用直接 $(5)$ 替换掉 $(1)$ 中求贡献的部分即可。<br>$$<br>\begin{equation}<br>f(i) = \frac{m + \sum_{T|i} \lfloor\frac{m}{T} \rfloor \sum_{d|T} \mu(\frac{T}{d}) f(d)}{m - \lfloor\frac{m}{i}\rfloor}<br>\end{equation}<br>$$<br>此时还有一个小问题，就是如何快速求$g(T) = \sum_{d|T} \mu(\frac{T}{d}) f(d)$，其实很简单，每次我们求出一个$f(i)$，我们可以用类似埃氏筛的方法枚举倍数，然后把$\mu(\frac{T}{i}) f(i)$加到对应的$g(T)$上即可。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>每个数的约数，以及$\mu(i)$可以用欧拉筛和埃氏筛在$O(m)$时间内求出。<br>对于每个$f(i)$，先求约数，然后与$g(T)$进行计算，这个时间复杂度会被均摊到$O(m\log{m})$。<br>接下里每个$f(i)$还会枚举倍数，这个复杂度可以用调和级数计算$\sum_i \lfloor\frac{m}{i}\rfloor \leq O(m\ln{m})$。<br>所以总体复杂度为$O(m\log{m})$</p>
<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!nop[i]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            primes[tot++] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            mu[i] = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot &amp;&amp; primes[j] * i &lt;= N; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            nop[i * primes[j]] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                mu[i * primes[j]] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            mu[i * primes[j]] = -mu[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 求每个数的约数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= N; j += i) d[j].push_back(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sieve(m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> invM = getInv(m, MOD);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> d : d[i]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            F[i] += (ll)(m / d) * G[d] % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            F[i] %= MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        F[i] = (F[i] + m) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        F[i] = (ll)F[i] * getInv((m - m / i), MOD) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 递推G(T)的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= m; j += i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            G[j] += mu[j / i] * F[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            G[j] %= MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sum = (sum + F[i]) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 把数值扳正</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (((ll)sum * invM + <span class="number">1</span>) % MOD + MOD) % MOD);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>概率</tag>
        <tag>动态规划</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>[CF442B] Andrey and Problem</title>
    <url>/2020/07/23/CF442B/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你一个长度为$n$的集合，集合中每个元素是$[0,1]$之间的概率，代表第$i$个元素有$p_i$的概率变成1。求如何选择这个集合的一个子集，使得最后只有一个数为$1$的概率最大，输出这个概率。</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先明确我们要求的其实是$P(X=1)$，也就是只有一个元素为1的概率，那么假设我们已经选择了集合$S$，那么<br>$$<br>P(S) = \sum_{i=1}^{|S|} p_i \prod_{j=1, i\neq j}^{|S|} (1 - p_j)<br>$$<br>那么假设我们现在要加入一个新元素$p_k$，那么概率会变成:<br>$$<br>\begin{align}<br>P(S’) &amp;= (1-p_k)\sum_{i=1}^{|S|} p_i \prod_{j=1, i\neq j}^{|S|} (1 - p_j) + p_k \prod_{j=1}^{|S|}(1-p_j) \\<br>P(S’) &amp;= (1 -p_k) P(S) + p_k\prod_{j=1}^{|S|}(1-p_j) \\<br>\Delta p&amp;= -p_k P(S)+ p_k\prod_{j=1}^{|S|}(1-p_j) \\<br>&amp;=p_k\bigg(-P(S)+\prod_{j=1}^{|S|}(1-p_j)\bigg)<br>\end{align}<br>$$<br>已知$p_k \in [0, 1]$，那么如果$\prod_{j=1}^{|S|}(1-p_j) &gt; P(S)$就会递增概率。而且递增量刚好是$p_k$倍这个差距。<br>我们知道$\prod_{j=1}^{|S|}(1-p_j)$和$P(S)$这两个函数的取值都在$[0, 1]$这个范围内，而$\prod_{j=1}^{|S|}(1-p_j)$必然随着选择元素增加而减少，而$P(S)$的值需要保持最优，也就是最大。由此可知，$f(S) = \prod_{j=1}^{|S|}(1-p_j) - P(S)$这个类似导数的东西一定会越来越小，那么我们一定要从$p_k$最大的元素开始取，这样才能保证取到最优解，否则收益一定没有最早取最大值要大，<br>但是这个结论我们需要一个比较严谨的证明，以后补上。。。<br>所以最终做法就是从最大值开始取元素，如果$P(S)$能继续增加就取它，否则就维持最大值。这个题数据范围$100$就是搞心态的。。。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>$O(n\log{n})$</p>
<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> A[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;A[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sort(A + <span class="number">1</span>, A + n + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> ans = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> invs = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">double</span> tmp = ans * (<span class="number">1</span> - A[i]) + A[i] * invs;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        invs *= (<span class="number">1</span> - A[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (tmp &lt; ans) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ans = max(ans, tmp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.9lf"</span>, ans);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>概率</tag>
        <tag>贪心</tag>
        <tag>结论</tag>
      </tags>
  </entry>
  <entry>
    <title>快速傅里叶变换（FFT）</title>
    <url>/2020/07/19/fft/</url>
    <content><![CDATA[<h1 id="多项式乘法、卷积"><a href="#多项式乘法、卷积" class="headerlink" title="多项式乘法、卷积"></a>多项式乘法、卷积</h1><p>假设我们有两个多项式$f, g$<br>$$<br>f(x) = \sum_{i=0}^n a_ix^i\\<br>g(x) = \sum_{i=0}^m b_ix^i\\<br>$$</p>
<a id="more"></a>
<p>两个多项式的最高次项分别为$n$和$m$，那么两个多项式的乘积有<br>$$<br>f(x)g(x) = \sum_{i=0}^{n+m} \sum_{j=0}^{i} a_{j}b_{i-j}x^i<br>$$<br>我们可以把这种$c_i = \sum_{j=0}^{i} a_{j}b_{i-j}$这种形式的运算叫做卷积运算。朴素算法去计算这个卷积每一个$c_i$需要计算$i$项，加上外层的$n+m+1$项总共需要$O(n^2)$级别的时间复杂度。<br>为了加速这一过程，我们可以利用多项式本身的一些性质，其中一个很重要的性质就是我们取不同的$n+1$个数，分别插入多项式求出$f(x)$，那么求出来这$n$个值一定能唯一的确定这个多项式$f(x)$。<br>为什么能这样呢？我们可以把一个$n$阶多项式看做含有$n+1$个未知数的方程组，系数是未知数，$x^i$是未知数的系数。我们可以写成矩阵形式<br>$$<br> \left[<br>  \begin{matrix}<br>   1 &amp; x_0 &amp; x_0^2 &amp; \cdots \\<br>   1 &amp; x_1 &amp; x_1^2 &amp; \cdots \\<br>   1 &amp; x_2 &amp; x_2^2 &amp; \cdots \\<br>   \vdots &amp; \vdots &amp; \vdots &amp; \ddots<br>  \end{matrix}<br>   \right]<br>   =<br>    \left[<br>  \begin{matrix}<br>    y_0 \\<br>    y_1 \\<br>    y_2 \\<br>   \vdots<br>  \end{matrix}<br>   \right]<br>$$<br>由于$x_i$各不相同所以矩阵总能化为阶梯形矩阵，所以一定有且仅有一个解。所以如果我们能求出$f(x),g(x)$的点值表示法，我们就能求出$f(x)g(x)$的点值了，只要将他们点值分别相乘，只需要$O(n)$时间。</p>
<p>可惜的是，先不说解方程用的高斯消元需要$O(n^3)$的时间，连求出所有$y_i$的时间都已经有$O(n^2)$了。</p>
<h1 id="复平面与单位根"><a href="#复平面与单位根" class="headerlink" title="复平面与单位根"></a>复平面与单位根</h1><p>由于直接求$y_i$没有什么搞笑方法，我们就得利用多项式的其他性质了，比如所有项都带个次方$x^i$，那么如果我们能选取一些特殊的点值，使得我们能够利用这些次方项，是不是能加速求解的速度呢？</p>
<p>答案是，是的。只不过我们去的这些数不一定是实数，而是虚数。准确的说，是$n$次单位复根。$n$次单位复根其实就是方程$x^n=1$的所有根，它一定会有$n$个根，分别为：$\omega_{n}^{0}, \omega_{n}^{1}, \cdots, \omega_{n}^{n-1}$。复数域上的运算有一个性质，两个复数相乘等于它们的模长相乘，同时辐角相加的结果。我们知道$n$次单位根的模长都为1，所以不需要管大小，像$\omega_n^k$其实就是$\omega_n^1$转了$k$次的位置，也就是从x轴正半轴转了$\frac{n}{k}$个圆的位置。</p>
<p>那么这个复数在复平面上就代表了一个唯一的点，所以我们可以用二维平面的公式求出这个点的位置<br>$$<br>\omega_n^k = \bigg(\cos(\frac{2\pi}{k}), \sin(\frac{2\pi}{k})\bigg)<br>$$<br>。所以其实$n$次单位根是个啥？就是把半径为1的圆分成$n$份，圆上$n$个点的位置，第$k$个点就是从x轴正半轴数第几个位置，也就是$\omega_{n}^k$。</p>
<p>而我们的傅里叶变换，其实就是求出多项式$f(x)$（此时最高次项为n-1）<br>在$f(\omega_n^0), f(\omega_n^1), \cdots, f(\omega_n^{n-1})$这$n$个位置的值。</p>
<p>乍一看好像也不好求，但是我们之前说了，复数乘法其实就是绕着圆心转，次方就是转几次，那么这个多项式有很多个$x^i$，那么是不是提示了我们，其实有很多地方我们会转到相同的值上呢？比如说$(\omega_n^1)^2 =\omega_n^2$。</p>
<p>在此之前，我们先提出几个复数运算的引理，这些都很容易证明是正确的：<br>$$<br>\begin{align}<br>(\omega_n^k)^i &amp;= \omega_n^{ki} \\<br>\omega_n^{an+k} &amp;= \omega_n^{k} \\<br>\omega_{2n}^{2k} &amp;= \omega_{n}^k \\<br>\omega_n^{k + \frac{n}{2}} &amp;= -\omega_{n}^k<br>\end{align}<br>$$<br>最后一个引理的意思是，你在圆上转了半圈，那么得到的位置一定和原来的位置是相反的。有了这几个引理我们才能确定快速傅里叶变换这个算法是正确的。</p>
<h1 id="快速傅里叶变换"><a href="#快速傅里叶变换" class="headerlink" title="快速傅里叶变换"></a>快速傅里叶变换</h1><p>接下来我们正式开始讲解快速傅里叶变换FFT的实现方法。首先，对于一个$n$次多项式，我们一定可以分开奇偶项来分解成这个样子<br>$$<br>f(x) = \sum_{i=0}^n a_ix^i = \sum_{i=0}^{\frac{n}{2}} a_{2i}x^{2i} + \sum_{i=0}^{\frac{n}{2}} a_{2i+1}x^{2i+1}<br>$$<br>然后我们把$2i+1$也变成$2i$，此时有<br>$$<br>\begin{align}<br>f(x) &amp;= \bigg(\sum_{i=0}^{\frac{n}{2}} a_{2i}x^{2i}\bigg) + x\times \bigg(\sum_{i=0}^{\frac{n}{2}} a_{2i+1}x^{2i}\bigg) \\<br>A(x^2) &amp;=  \sum_{i=0}^{\frac{n}{2}} a_{2i}(x^2)^i\\<br>B(x^2) &amp;=  \sum_{i=0}^{\frac{n}{2}} a_{2i+1}(x^2)^i\\<br>f(x) &amp;= A(x^2) + xB(x^2) \\<br>\end{align}<br>$$<br>于是我们就把对于一个$n$阶多项式的变换转化成了对于两个$n/2$阶多项式的变换。<br>$$<br>f(\omega_n^k) = G(\omega_n^{2k}) + \omega_n^k H(\omega_n^{2k})<br>= G(\omega_{n/2}^{k}) + \omega_n^k H(\omega_{n/2}^{k})<br>$$<br>那么这样做的好处在哪呢？<br>此时$f(\omega_n^{k+n/2})$的值也可以立即得出<br>$$<br>f(\omega_n^{k+n/2}) = G(\omega_n^{2k+n}) + \omega_n^{k+n/2} H(\omega_n^{2k+n})<br>= G(\omega_{n/2}^{k}) - \omega_n^k H(\omega_{n/2}^{k})<br>$$<br>于是乎，如果我们只需要求出了前一半的$G(\omega_{n/2}^k),H(\omega_{n/2}^k)$，就可以在知道前一半的$f(\omega_{n}^{k})$同时立即填充后一半的$f(\omega_{n}^{k+n/2})$，在最上一层则可以填充所有的$f(x)$。<br>此时递归的方程可以写成<br>$$<br>T(n) = 2T(\frac{n}{2}) + n/2<br>$$<br>通过主定理展开得到$T(n) = O(n\log{n})$。<br>于是我们就可以写出以下递归代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> x, y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Complex() = <span class="keyword">default</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Complex(<span class="keyword">double</span> x, <span class="keyword">double</span> y) : x(x), y(y) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex&amp; c) <span class="keyword">const</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> Complex(x + c.x, y + c.y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex&amp; c) <span class="keyword">const</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> Complex(x - c.x, y - c.y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Complex <span class="keyword">operator</span>*(<span class="keyword">const</span> Complex&amp; c) <span class="keyword">const</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> Complex(x * c.x - y * c.y, x * c.y + y * c.x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(Complex* arr, <span class="keyword">int</span> len, <span class="keyword">bool</span> forward)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Complex* even = (Complex*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Complex) * len / <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Complex* odd = (Complex*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Complex) * len / <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">2</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        even[i / <span class="number">2</span>] = arr[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        odd[i / <span class="number">2</span>] = arr[i + <span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    fft(even, len / <span class="number">2</span>, forward);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    fft(odd, len / <span class="number">2</span>, forward);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">Complex <span class="title">wn</span><span class="params">(<span class="built_in">cos</span>(<span class="number">2</span> * PI / len), <span class="built_in">sin</span>(<span class="number">2</span> * PI / len))</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Complex t = w * odd[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        arr[i] = even[i] + t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        arr[i + len / <span class="number">2</span>] = even[i] - t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        w = w * wn;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">free</span>(odd);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">free</span>(even);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>值得注意的是，由于每次都是递归处理两个大小为$\frac{n}{2}$的多项式，所以整个多项式的大小必须是二的次方$2^k$，如果不够可以考虑补0到二的次方。</p>
<h1 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h1><p>递归算法的复杂度已经达到了复杂度下限，但是我们可以让它的运行速度更快一点。这便是Cooley-Tukey的快速傅里叶变换算法。<br>优化的方法其实很简单，因为递归算法的瓶颈在于递归的额外开销，所以我们如果能把它转化为递推合并，就能加快速度。<br>因为每次递归我们都是把原多项式系数奇偶分类，所以递归到最后会形成一个原多项式系数的排列。通过观察规律，我们发现这个排列有这样一个性质：假设系数下标为$x$（从零开始），那么它在奇偶分类递归后会处于第$y$位，这个$y$等于$x$在原多项式大小$2^k$的$k$位二进制下反转的值。举个例子：假设原多项式是$2^4=16$个系数，那么对于第$2 = (0010)_2$个系数，变换之后的位置会是第$(0100)_2=4$位。而且这个规律在合并的时候是保持不变的，如此，我们就可以完全舍弃递归算法，在进行fft之前先对系数做一个重新排序。<br>反转二进制位我们可以用递推法实现，原理就是利用$x$右移一位的值。假设有$f((0010)_2)=(0100)_2$，那么$f((0100)_2)$就可以利用$f((0010)_2)$的值右移一位然后在倒着加上自己的最右一位的值得到。边界条件$f(0)=0$。<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; R); i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">           rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (R - <span class="number">1</span>));</span></pre></td></tr></table></figure>
<p>接下来就是利用这个排序后的系数进行变换了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transform</span><span class="params">(Complex* data, <span class="keyword">int</span> sign)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span> &lt;&lt; R;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 重新排序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i &lt; rev[i]) swap(data[i], data[rev[i]]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 枚举一半的长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; len; k &lt;&lt;= <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 步长</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> step = k &lt;&lt; <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function">Complex <span class="title">unit</span><span class="params">(<span class="built_in">cos</span>(PI / k), sign * <span class="built_in">sin</span>(PI / k))</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += step) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="function">Complex <span class="title">rt</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Complex t1 = data[i + j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                data[i + j] = t1 + rt * data[i + j + k];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                data[i + j + k] = t1 - rt * data[i + j + k];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                rt = rt * unit;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h1 id="傅里叶逆变换"><a href="#傅里叶逆变换" class="headerlink" title="傅里叶逆变换"></a>傅里叶逆变换</h1><p>现在我们得到了多项式$f(x)$在$x = \omega_{n}^{k}$处的点值了，那么如何快速的从这个点值得到多项式的系数呢？先考虑列出的线性方程组$Ax=b$：<br>$$<br> \left[<br>  \begin{matrix}<br>   1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1\\<br>   1 &amp; \omega_{n}^{1} &amp; \omega_{n}^{2} &amp; \cdots &amp; \omega_{n}^{(n-1)}\\<br>   1 &amp; \omega_{n}^{2} &amp; \omega_{n}^{4} &amp; \cdots &amp; \omega_{n}^{2(n-1)}\\<br>   \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\<br>   1 &amp; \omega_{n}^{(n-1)} &amp; \omega_{n}^{2(n-1)} &amp; \cdots &amp;\omega_{n}^{(n-1)^2}<br>  \end{matrix}<br>   \right]<br>   \left[<br>    \begin{matrix}<br>    a_0\\<br>    a_1\\<br>    a_2\\<br>    \vdots\\<br>    a_{n-1}<br>    \end{matrix}<br>   \right]<br>   =<br>    \left[<br>  \begin{matrix}<br>    y_0 \\<br>    y_1 \\<br>    y_2 \\<br>   \vdots \\<br>   y_{n-1} \\<br>  \end{matrix}<br>   \right]<br>$$<br>则$x =A^{-1}b$，所以只要求出大矩阵的逆与原点值向量相乘就是系数。<br>我们先来观察一下一个大小为8的矩阵：<br>$$<br> \left[<br>    \begin{matrix}<br>        1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1\\<br>        1 &amp; \omega_{n}^{1} &amp; \omega_{n}^{2} &amp; \omega_{n}^{3} &amp; \omega_{n}^{4} &amp; \omega_{n}^{5} &amp; \omega_{n}^{6} &amp; \omega_{n}^{7}\\<br>        1 &amp; \omega_{n}^{2} &amp; \omega_{n}^{4} &amp; \omega_{n}^{6} &amp; 1 &amp; \omega_{n}^{2} &amp; \omega_{n}^{4} &amp; \omega_{n}^{6}\\<br>        1 &amp; \omega_{n}^{3} &amp; \omega_{n}^{6} &amp; \omega_{n}^{1} &amp; \omega_{n}^{4} &amp; \omega_{n}^{7} &amp; \omega_{n}^{2} &amp; \omega_{n}^{5}\\<br>        1 &amp; \omega_{n}^{4} &amp; 1 &amp; \omega_{n}^{4} &amp; 1 &amp; \omega_{n}^{4} &amp; 1 &amp; \omega_{n}^{4}\\<br>        1 &amp; \omega_{n}^{5} &amp; \omega_{n}^{2} &amp; \omega_{n}^{7} &amp; \omega_{n}^{4} &amp; \omega_{n}^{1} &amp; \omega_{n}^{6} &amp; \omega_{n}^{3}\\<br>        1 &amp; \omega_{n}^{6} &amp; \omega_{n}^{4} &amp; \omega_{n}^{2} &amp; 1 &amp; \omega_{n}^{6} &amp; \omega_{n}^{4} &amp; \omega_{n}^{2}\\<br>        1 &amp; \omega_{n}^{7} &amp; \omega_{n}^{6} &amp; \omega_{n}^{5} &amp; \omega_{n}^{4} &amp; \omega_{n}^{3} &amp; \omega_{n}^{2} &amp; \omega_{n}^{1}\\<br>    \end{matrix}<br>\right]<br>$$<br>而这个大矩阵求逆以后的操作为多项式$B(x)$<br>$$<br>B(x) = \frac{1}{n} \sum_{i=0}^{n-1} y_i x^i<br>$$<br>的点值，只不过这次点值插入的是$-\omega_{n}^{k}$，其实就是相当于在复平面反着转回去的结果除以n。反着转和正着转区别不大，只是方向相反，所以我们仍然可以套用FFT的过程，只不过把单位根的转向变成负的即可。之前代码里面的<code>sign</code>参数其实就是为了逆变换的，如果<code>sign</code>为1就是正向变换，反之就是逆向变换。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>算法</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>快速傅里叶变换</tag>
      </tags>
  </entry>
  <entry>
    <title>[CF1286A] Garland</title>
    <url>/2020/02/26/CF1286A/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>有一个由$1-n(n\leq 100)$构成的数列，其中部分被删除（删除的元素由$0$代替），请用被删除的元素补全这个数列，使这个数列中相邻元素奇偶性不同的对数最少。</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这种又像贪心又像dp的题当然是要使用随机化算法了（其实是dp太难想了）。</p>
<p>首先先明确这道题要求的是什么，其实是这个式子：</p>
<p>$<br>f(a)=\sum\limits_{i=2}^{n} parity(a_{i-1}) \oplus parity(a_i)<br>$</p>
<p>由于缺失的数字要么是奇数，要么是偶数，所以问题转化为如何将这些奇数和偶数填进数组使得相邻两数之间的奇偶性不同的对数最少。</p>
<p>由于没有什么明显的性质，dp式子也不好推，看一下数据范围$n\leq100$，那么我们显然可以用爬山/模拟退火等随机化算法搞一搞。</p>
<p>我们先从估价函数开始分析，对于这道题估价函数只需要$O(n)$的复杂度，完全可以接受。</p>
<p>接下来我们考虑枚举后继状态的转移，运用爬山的思想，我们只需要选择后继状态里面$f(a’)$比当前状态小且最小的那个$a’$就行了。如果发现没有任何后继状态比这个状态更好我们就可以退出爬山了。具体的枚举方式可以是交换两个奇偶性不同的填充数字，形成一个新的排列。</p>
<p>我第一次尝试的就是<strong>随机化爬山</strong>算法。一般来说，使用随机爬山算法足以应付大部分随机化题目，但是发现爬山在本题有一个致命的缺陷。设状态$x$为当前最优状态，当$f(a’)=f(x)$的时候爬山算法是不会转移到$a’$的。但是这题的函数是可以长这个样子的</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/317wgxgo.png" alt=""></p>
<p>于是随机爬山算法的很多起始点都会被这块平原阻挡，无法到达全局最优解。此时我们就需要对$f(a’)=f(x)$状态的转移进行优化，引入模拟退火的温度概念。每次遇到与当前最优解相同的状态都用一个概率$e^{-\frac{1}{T}}$去接受它，接受的概率会随着文读的下降而下降，而与模拟退火不同的是我们不接受任何不优的$a’$。因为这题的特殊性质，$f(a’)&lt;f(x)$基本上是不会产生更优解，反而会浪费计算资源的。</p>
<p>加入了这个优化以后就能以相当高的几率得到最优解，同时我并没有对运行时间进行什么优化，这个算法实际上还可以更快。具体实现可以参考我的代码：</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>$O(n^2 \times 玄学)$</p>
<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">mt19937 <span class="title">mt</span><span class="params">(<span class="number">15784371</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[MAXN], b[MAXN], p[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> bin[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 估价函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eval</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) a[b[i]] = p[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) cnt += (a[i - <span class="number">1</span>] &amp; <span class="number">1</span>) ^ (a[i] &amp; <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hill_climbing</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">bool</span> swp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans = eval();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> T = <span class="number">100</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">do</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        swp = <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; m; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (p[i] == p[j]) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                swap(p[i], p[j]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> e = eval();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (e &lt; ans) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="comment">// 遇到更优解一定转移</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    swp = <span class="literal">true</span>, ans = e;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e == ans) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="comment">// 如果解状态并不优，则机率接受它</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">double</span> p = <span class="built_in">exp</span>(<span class="number">-1</span> / T);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (mt.max() * p &gt; mt()) swp = <span class="literal">true</span>, ans = e;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="comment">// 否则回退状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    swap(p[i], p[j]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        T *= <span class="number">0.85</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cnt++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 结合了爬山算法和模拟退火，要么局部最优解跳出，要么温度过低跳出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">while</span> (swp &amp;&amp; T &gt; <span class="number">1e-6</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> sz)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> j = mt() % (i + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        swap(a[i], a[j]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans = INF2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">20</span>; t++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        shuffle(p, m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ans = min(ans, hill_climbing());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// b数组代表第i个空是a数组的第几个元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!a[i]) b[m++] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        bin[a[i]] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> odd = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!bin[i])</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (i &amp; <span class="number">1</span>) odd++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// p数组代表第i个空是奇数还是偶数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; odd; i++) p[i] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = odd + <span class="number">1</span>; i &lt; m; i++) p[i] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, search());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>随机化</tag>
      </tags>
  </entry>
  <entry>
    <title>[UVA1614] Hell on the Markets</title>
    <url>/2020/02/26/UVA1614/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你一个长度为$n(n\leq 10^5)$的序列$A$, 满足$1 \leq A_i \leq i$。求确定每个数的正负号，使得总和为$0$。</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>如果不考虑那个诡异的条件，显然我们只需要求出序列$A$的子集和是否可以等于总和的一半即可。但是子集和问题(Subset Sum)是一个著名的NPC问题，显然无法在满足时间限制的条件下得到解。</p>
<p>于是我们必须考虑如何使用$1 \leq A_i \leq i$这个条件。我一开始的猜想就是如果序列总和$S_n$是偶数，那么在这个限制条件下一定存在一个子集$a$使得$Sum(a) = S / 2$。但是我无法证明它，也没法找到一个合适的贪心方法找出这个子集。</p>
<p>看了别人的题解才发现这个结论需要变得更强一点：对于前缀和$S_i$，以及$1$到$S_i$的每个整数$x$，一定能从前$i$个元素中找出一个子集使得子集的和等于$x$。证明可以使用归纳法：</p>
<p>$\textbf{Base Case: }$ 当$i = 1$的时候，我们有$a_1 = 1$，那么我们可以用$a_1$，凑出$S_1$。</p>
<p>$\textbf{Inductive Hypothesis: }$ 假设对于整数$k$，我们有对于所有$1$到$S_k$的整数，都存在一个由前$k$个数组成的集合，使得集合的和为这个整数。</p>
<p>那么对于整数$k+1$，新加入的这个$a_{k+1}$有$1 \leq a_{k+1} \leq k + 1$。此时$S_{k+1} = S_k + a_{k + 1}$。对于所有$x \leq S_k$，我们都可以用前$k$个元素组成。那么我们只需要考虑对于所有$S_k + 1 \leq x \leq S_k + k + 1$我们如何去组合就行了。假设我们有$a_{k+1} = y$，$S_{k + 1} = S_k + y$，那么$S_k + j (j \in [1, y])$可以由组成$S_k + j - y$的集合中，添加一个$a_{k+1}$组成。由于$y\geq j$，所以所有的$S_k + j - y$集合都可以由前$k$个元素组成，新加的元素只需要贡献$y$。因此我们有对于所有$1$到$S_{k+1}$的整数，都存在一个由前$k+1$个数组成的集合，使得集合的和为这个整数。</p>
<p>于是此结论得证，我们一定可以凑出来$S_n/2$。但是怎样去凑呢？还是要利用这个结论。假设我们想用前$k$个元素凑出$x$，则一定有$x&lt;=S_k$，那么如果$0 \leq x-a_k \leq S_{k-1}$，则前$k-1$个元素一定能凑出$x-a_k$。由于$x\leq S_k$，所以一定满足$x-a_k \leq S_{k-1}$。如果出现$x-a_k$为负数的情况，那么一定有$x \leq S_{k-1}$，否则根据前缀和，无法出现负数。由于$x \leq S_k$一直保持，所以一定有$x\leq S_1=1$，所以$x$最后一定为$0$。</p>
<p>至此，我们得出了一个凑出子集和等于$S_n/2$的方法，从后往前选取$a_i$，如果$a_i$的选取会超出$S_n/2$，那么就不选，由于上面的证明，最后一定选取的元素和一定为$S_n/2$。至此，这道题终于被解决了，有两个结论和两个不显然的证明，实在是难想啊。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>$O(n)$</p>
<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line">ll pref[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pref[i] = pref[i - <span class="number">1</span>] + arr[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (pref[n] &amp; <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll st = pref[n] / <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (st - arr[i] &gt;= <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            st -= arr[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            arr[i] *= <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i != <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, arr[i] &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        solve();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
        <category>UVA</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>结论</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>[SDOI2012]任务安排</title>
    <url>/2020/02/10/SDOI2012Mission/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>有$n (n\leq 3\times10^5)$个任务需要被完成，你可以把这些任务全部分成任意多组，每组内的任务必须连续。同组任务会在同一时刻完成，所花时间为$\sum_{i=l}^{r}t_i$，同时每组任务开始有一个预热时间$s$。任务$i$完成的费用为完成时间乘以$c_i$，求如何分组能让费用最小。</p>
<a id="more"></a>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>既然要把所有任务都分组，那么我们只需要知道每个任务属于哪一个组所需费用最小即可。对于任务$i$，我们想要知道从之前哪个任务分过来费用最小。于是考虑动态规划，设$f(i)$为从$1~i$分组完成，所需的最少费用，答案则是$f(n)$。但是有个启动时间$s$不好处理，怎么办呢。利用费用提前思想，每次启动机器的时间一定会给后面的任务贡献费用，那么转移方程为：<br>$$<br>f(i) = \min_{j&lt;i}\{f(j) + (F_i - F_j) * T_i + s * (F_n - F_j) \}<br>$$<br>式子中$F_i$表示费用的前缀和，$T_i$表示时间的前缀和。</p>
<p>显然暴力寻找是$O(n^2)$，但是可以用斜率优化DP的套路去降时间复杂度。考虑到费用$F_i$是单调不减的，那么显然$j$越小需要的费用越大，这就让我们想到决策可能是随着$i$增大而单调不减的，打表也证实了这一点。由于决策单调性的存在，我们的目标可以转变成计算出什么时候需要更新决策。</p>
<p>于是考虑此时我们在$i$，决策$j$能替换掉原有决策$k$，根据单调性此时一定有$j&gt;k$，且<br>$$<br>f(j) + (F_i - F_j) * T_i + s * (F_n - F_j) \leq f(k) + (F_i - F_k) * T_i + s * (F_n - F_k)<br>$$<br>即<br>$$<br>f(j) + F_iT_i - F_jT_i + sF_n - sF_j \leq f(k) + F_iT_i - F_kT_i + sF_n - sF_k<br>$$<br>消掉不变的项<br>$$<br>f(j) - F_jT_i - sF_j \leq f(k) - F_kT_i - sF_k<br>$$<br>移项，尽量让带$T_i$的在左边，$j, k$在右边<br>$$<br>T_i(F_k - F_j) \leq f(k)- f(j) - sF_k + sF_j<br>$$<br>这里要格外小心，由于$j&gt;k$，一定有$F_j&gt;F_k$，即$F_k - F_j \leq 0$。此时等于$0$的情况必须特判，而小于$0$的情况需要让不等式变号！最终结果：<br>$$<br>T_i \geq \frac{f(k)- f(j) - sF_k + sF_j}{F_k - F_j}<br>$$<br>由此我们可以得出结论，令$slope(k, j) = \frac{f(k)- f(j) - sF_k + sF_j}{F_k - F_j}$。当$slope(k, j) \leq T_i$时，有$j$优于$k$（因为$j&gt;k$所以$j$会比较靠后，是更优解），此时这个$slope(k, j)$可以看成是点$k$到点$j$的斜率。</p>
<p>我们进一步分析这个斜率，假设当前$j$打败了$k$，新来了一个$i &gt; j$，如果有$slope(j, i) \leq slope(k,j)$那么此时$j$也不占优势了。因为无论后面的$T_{i+1}$值是多少，$slope(j, i)$都会比$slope(k,j)$更容易小于$T_{i+1}$，而此时$i$又比$j$打，那么$j$就再也打不过$i$了。此时清除$j$这个废物，不然整个序列就不符合后面的具有比前面更优的潜力这个性质了（即决策单调）。</p>
<p>整理一下得到的两个性质<br>$$<br>\begin{cases}<br>    slope(k, j) &amp;\leq T_i  &amp;\text{此时j替换k}\\<br>    slope(k, j) &amp;\geq slope(j, i)  &amp;\text{此时j比不过i}<br>\end{cases}<br>$$<br>根据这两个性质我们就可以写出一个单调队列，里面存储的就是位置$i$，最优决策则可以通过这两个性质取得。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 性质1，QQ是单调队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (l &lt; r &amp;&amp; slope(QQ[l], QQ[l + <span class="number">1</span>]) &lt;= T[i]) ++l;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> opt = QQ[l];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dp[i] = dp[opt] + ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 性质2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (l &lt; r &amp;&amp; slope(QQ[r - <span class="number">1</span>], QQ[r]) &gt;= slope(QQ[r], i)) --r;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    QQ[++r] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>但是仔细看这题的数据范围，$|t_i|\leq2^8$，啥意思，就是$t_i$可能是负数，也就是$T_i$并非单调增。我们的代码这一行<code>while (l &lt; r &amp;&amp; slope(QQ[l], QQ[l + 1]) &lt;= T[i]) ++l;</code>就是基于$T_i$是单调增的情况，我们去除之前一定不会比现在更优的点。但是如果$T_i$并非单调增，被去掉点有可能在此时是最优解，于是我们只能删掉这一行。</p>
<p>那么问题来了，我们怎么知道哪个点是最优解呢？首先，我们利用性质1和2维护了一个斜率单调下降的序列，那么对于一个$T_i$，只要知道满足$slope(j, j+1) \leq T_i$且最大的$j+1$，就是最优解。于是我们可以使用二分。二分找指定条件的方法我在之前的博客中介绍过，这里就不多讲了。</p>
<p>最后一个极其重要的点就是由于这题的毒瘤性质$c_i$可以是$0$，也就是$F_j-F_k$可能是$0$，这会严重影响决策正确性。因为$slope(k, j)$此时有可能是正无穷也有可能是负无穷（因为分子不一定是正的），它们显然会干扰性质1和2。此时我们就要想，当$c_k$为$0$的时候我们是包括它还是不包括它更好呢？显然是要包括啊，免费的你还不要！也就是说，当$j&gt;k$的时候，我们不要去替换成$j$，而是能留多久留多久，如果要替换那就直接越过$j$，此时$j$毫无卵用。于是我们最好就把$slope(j,k)$设为正无穷大，使得它无论怎样都不会成为最优解，这样就不会有错了。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(n\log{n})$</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// j &gt; k</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> j)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (F[k] == F[j]) <span class="keyword">return</span> <span class="number">1.0</span> / <span class="number">0.0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> (dp[k] - dp[j] + s * (<span class="keyword">double</span>)(F[j] - F[k])) / (<span class="keyword">double</span>)(F[k] - F[j]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bSearch</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, ll v)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> QQ[l];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans = r;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (slope(QQ[mid + <span class="number">1</span>], QQ[mid]) &gt;= v)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ans = mid, r = mid - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            l = mid + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> QQ[ans];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    n = read&lt;ll&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    s = read&lt;ll&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll t = read&lt;ll&gt;(), c = read&lt;ll&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        T[i] = T[i - <span class="number">1</span>] + t, F[i] = F[i - <span class="number">1</span>] + c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> opt = bSearch(l, r, T[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dp[i] = dp[opt] + (F[i] - F[opt]) * T[i] + s * (F[n] - F[opt]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; slope(QQ[r - <span class="number">1</span>], QQ[r]) &gt;= slope(QQ[r], i)) --r;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        QQ[++r] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, dp[n]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>斜率DP</tag>
      </tags>
  </entry>
  <entry>
    <title>数论筛法</title>
    <url>/2020/01/20/eulersieve/</url>
    <content><![CDATA[<h1 id="欧拉筛-线性筛"><a href="#欧拉筛-线性筛" class="headerlink" title="欧拉筛/线性筛"></a>欧拉筛/线性筛</h1><p>之前的素数判定中，我们曾使用埃拉托斯特尼筛法(Sieve of Eratosthenes)，进行素数的筛选。但是这个算法的时间复杂度是$O(n\log{\log{n}})$的，因为每个数都被它筛了它的素因子个数那么多次。</p>
<a id="more"></a>

<h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>欧拉筛法（Euler’s sieve）就是减少这种重复的一种筛法，埃筛的方法是筛去素数的倍数，而欧拉筛的核心思想是筛去最小素因子为它的数。这样一对比下来，因为每个数只有一个最小素因子，所以时间复杂度显然是$O(n)$。</p>
<p>然而，欧拉筛法的实现是有一点技巧的，我当初尝试理解的时候还是费了一番功夫。假设我们有一个数$x$，有唯一质因数分解：$\prod_{k} p_k^{\alpha_k} \ (p_{k-1} &lt; p_k)$。此时欧拉筛会筛除一个$p_i*x$，$p_i \leq p_1$，$p_1$就是最小素因子，也就是说筛去的这个数的最小素因子会小于等于$x$的最小素因子，且是$x$的倍数。现在我们就要对于所有的$x$都筛掉这些倍数。</p>
<p>那么为什么每个数只会被筛一次呢？根据唯一分解定理，任何一个数的质因数排序后的序列一定是唯一的，那么假设$a\neq b$，并且他们删掉最小素因子后的数相同，那么它们的最小素因子一定不同。那么他们会被那个除掉最小素因子的数筛掉，然后就不会再被触及。</p>
<p>现在又有一个问题，怎么保证$x\in[2,p-1]$的合数全部被筛掉，没有遗漏呢？还是那个思路，因为小于$p$的数的最小素因子一定小于$p$，所以它一定会被小于$x/最小素因子$的数筛掉，这就保证了正确性。</p>
<p>实现的时候，我们筛到一个素数就要把它放到一个数组里面，此时素数的大小顺序非常重要，因为我们对于$x$需要查找所有小于等于$p_1$的素数，同时在等于$p_1$的时候停止查找。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> nop[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[MAXN / ln(MAXN)];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!nop[i]) primes[tot++] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot &amp;&amp; i * primes[j] &lt;= n; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            nop[i * primes[j]] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// i 整除 p_j 代表此时p_j已经是i的最小素因子</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!(i % primes[j])) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="扩展应用"><a href="#扩展应用" class="headerlink" title="扩展应用"></a>扩展应用</h2><p>欧拉筛在数论筛法里面用途非常广泛，尤其是对于积性函数，以欧拉函数筛为例，我们令$\varphi(x)=n\prod_k(\frac{p_k-1}{p_k})$，如果$x$是质数，那么$\varphi(x)=x-1$。同时$\varphi(pq) = \varphi(p) * \varphi(q) \ (p \perp q)$，也就是积性函数性质。</p>
<p>于是我们可以在筛到质数的时候把它的$\varphi(x)$设为$x-1$，否则，我们就需要去计算筛到合数的时候$\varphi(x)$值的变化。因为每次我们只加入一个质因数$p$，如果这个质因数不在原数的质因数分解中，那么显然答案要乘以$\varphi(p)$，否则就乘以$p$本身。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> nop[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[MAXN / ln(MAXN)], phi[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!nop[i]) primes[tot++] = i, phi[i] = i - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot &amp;&amp; i * primes[j] &lt;= n; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            nop[i * primes[j]] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!(i % primes[j])) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                phi[i * primes[j]] = primes[j] * phi[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                phi[i * primes[j]] = phi[primes[j]] * phi[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>素数判定</title>
    <url>/2019/12/31/prime-test/</url>
    <content><![CDATA[<blockquote>
<p>定义：对于一个大于$1$的正整数$p$，如果$p$是质数/素数，那么对于所有$a|p$，$a$要么是$1$，要么是$p$。</p>
</blockquote>
<p>那么对于一个数$x$，我们如何让计算机去判定它是不是质数/素数呢？</p>
<a id="more"></a>
<h1 id="素数判定"><a href="#素数判定" class="headerlink" title="素数判定"></a>素数判定</h1><h2 id="朴素方法"><a href="#朴素方法" class="headerlink" title="朴素方法"></a>朴素方法</h2><p>根据定义，我们只需要判断这个数$x$，除了$1$和$x$以外还有没有其他约数就好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(ll x)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt; x; i++) </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>这个算法的时间复杂度是$O(n)$，在极端情况下，$x$是质数的时候就需要扫遍$2~x$之间的所有值。但是实际上，我们并不需要扫到$x$，为什么呢？</p>
<p>考虑当$x$有一个约数$a$，$a|x$，那么一定有$\frac{x}{a}|x$。也就是说，每个约数都是对称的，对称中心就是$\sqrt{x}$。当$a\leq \sqrt{x}$存在一个对于$x$的约数的时候，$a &gt; \sqrt{x}$一定也存在一个$\frac{x}{a}$，反之则不存在。所以我们只需要扫到$\sqrt{x}$就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(ll x)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i * i &lt;= x; i++) </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>这个算法的时间复杂度是$O(\sqrt{n})$，还不错。</p>
<h2 id="筛法"><a href="#筛法" class="headerlink" title="筛法"></a>筛法</h2><p>但是在算法竞赛里面，经常有一类问题需要你对给出的$Q$个查询进行回答。此时如果查询范围很大，而次数又很多的话，上面的方法就会超时。</p>
<p>这时候就引出我们的埃氏筛/线性筛法。我们不从$x$出发去判断$x$是不是质数，而是从比较小的数开始，依次划掉这个数的倍数。因为质数的倍数一定不是质数（都有倍数了还怎么是质数），那么没有划掉的就是质数，直接$O(1)$判定即可。实现也非常简单</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> notprime[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> maxn)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxn; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (notprime[i]) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">2</span>; j &lt;= maxn; j += i) notprime[j] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>我之所以把数组定义成<code>notprime</code>是因为这样就不用把数组都初始化为$1$了。<br>这个算法的时间复杂度是多少呢？我们可以这样考虑，只有质数会进入第二个循环，而它会划掉所有它的倍数。那么也就是说，每个数最多会被划掉质因数个数那么多次。我们把一个数的质因数分解表示为$\prod_{k} p_k^{\alpha_k}$，则极端情况下，假设有$k$个不同质因数，则$n$的范围会是$2\times 3\times \dots \times p_k \geq k!$。而$k!$根据斯特林公式有<br>$$<br>n! \approx \sqrt{2\pi n}\bigg(\frac{n}{e}\bigg)^n \leq n^n<br>$$<br>那么$k$相对于$n$就是$O(\log{\log{n}})$级别的了，所以总复杂度是$O(n\log{\log{n}})$。这个复杂度与线性几乎没有差别了，虽然还有更高级的$O(n)$线性筛，但是这不是重点。</p>
<h2 id="Miller–Rabin-素性测试"><a href="#Miller–Rabin-素性测试" class="headerlink" title="Miller–Rabin 素性测试"></a>Miller–Rabin 素性测试</h2><p>Miller-Rabin 素性测试是一个更高级的素数判定算法，为什么叫素性测试呢？因为这个算法也很难保证一定能测出这个数是不是质数，只能说它很像质数，有多像呢？非常非常像。</p>
<p>但是对于算法竞赛的数据范围来说，这个算法是可以<strong>准确</strong>判定出这个数是不是质数的。</p>
<h3 id="Fermat小定理"><a href="#Fermat小定理" class="headerlink" title="Fermat小定理"></a>Fermat小定理</h3><blockquote>
<p>如果$p$是质数，对于一个数$a \in [1, p-1]$，有<br>$$<br>a^{p-1} \equiv 1\pmod{p}<br>$$</p>
</blockquote>
<p>如果我们想知道$n$是否是素数，我们在中间选取$a$，看看上面等式是否成立。如果$a^{n-1} \not\equiv 1\pmod{n}$，那么$n$一定不是质数。但是注意，这个定理的逆命题不一定成立，也就是说，$a^{n-1} \equiv 1\pmod{n}$不一定表示$n$是质数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fermat</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> n == <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= TEST_TIME; ++i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> a = rand() % (n - <span class="number">2</span>) + <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 快速幂求得a^&#123;n-1&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (fastExp(a, n - <span class="number">1</span>, n) != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>事实上，有一类数满足</p>
<blockquote>
<p>$n$是合数，对于与$n$互质的数$b$，$b^{n-1}\equiv 1\pmod{n}$</p>
</blockquote>
<p>这样的数被称为Carmichael数，是费马测试的大敌，但是由于Carmichael比质数少得多，所以仍然有方法去应对它。它的一个等价定义：</p>
<blockquote>
<p>一个正合成数$n$是卡迈克尔数，当且仅当$n$无平方数约数且对于所有$n$的素因数$p$，$p-1|n-1$。</p>
</blockquote>
<h3 id="二次探测定理"><a href="#二次探测定理" class="headerlink" title="二次探测定理"></a>二次探测定理</h3><p>假设我们有$x^2 \equiv 1\pmod{p}$，$p$为素数，那么该式子可以化为<br>$$<br>(x - 1)(x + 1) \equiv 0\pmod{p}<br>$$<br>那么$p$能整除$(x - 1)(x + 1)$，此时$(x-1)$或者$(x+1)$能被质数$p$整除，有$x \equiv 1\pmod{p}$或者$x\equiv-1\pmod{p}$。</p>
<p>那么我们假设$n&gt;2$是个质数，那么它一定是个奇数，且$n-1$一定可以被写成$d2^s$的形式，其中$s$是正整数，$d$是奇数。根据费马小定理，那么就有$a^{d2^s} \equiv1\pmod{n}$，同时，根据以上性质，对于$i \in [1, s-1]$，有<br>$$<br>    a^{d2^i} \equiv-1\pmod{n}\\<br>    a^d \equiv 1\pmod{n}<br>$$<br>所以我们可以不断对$a^{n-1}$取平方根后，判断是否出现不符合以上性质的根就知道它是否像质数了。同样，这个引理的逆命题也存在反例，但是由于Carmichael数的性质，它通不过平方探测，所以与费马小定理结合起来效果很不错。</p>
<p>但是即使这样，我们也只能说像是质数，事实上Miller–Rabin有$4^{-k}$的错误率，$k$是选取的基数$a$的数量。好消息是，在算法竞赛范围内$n\leq2^{64}$，选取$8$个素数作为基数就可以准确判定了。</p>
<p>时间复杂度：算法竞赛内用<code>__int128_t</code>可以达到$O(k\log{n})$，但是对于大整数一般是$O(k\log^3{n})$，可以用$FFT$优化到$O(k\log^2{n}\log{\log{n}}\log{\log{\log{n}}})$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">modmul</span><span class="params">(ll a, ll b, ll p)</span> </span>&#123; <span class="keyword">return</span> (<span class="keyword">__int128_t</span>)a * (<span class="keyword">__int128_t</span>)b % p; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">fastExp</span><span class="params">(ll x, ll p, ll mod)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    x %= mod;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll ans = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (p) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>) ans = modmul(ans, x, mod);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        x = modmul(x, x, mod);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">miller_rabin</span><span class="params">(ll x)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (x == <span class="number">2</span> || x == <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span> || !(x &amp; <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll <span class="built_in">pow</span> = <span class="number">0</span>, u = x - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (!(u &amp; <span class="number">1</span>)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">pow</span>++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> p = primes[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (p &gt;= x) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll v = fastExp(p, u, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (v == <span class="number">1</span> || v == x - <span class="number">1</span>) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (; j &lt; <span class="built_in">pow</span>; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            v = modmul(v, v, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (v == x - <span class="number">1</span>) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (j == <span class="built_in">pow</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>例题：<a href="https://loj.ac/problem/143" target="_blank" rel="noopener">质数判定</a></p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>质因数分解</title>
    <url>/2019/12/31/prime-factor/</url>
    <content><![CDATA[<h1 id="质因数分解"><a href="#质因数分解" class="headerlink" title="质因数分解"></a>质因数分解</h1><p>接着上一章的素数判定，这一章我们要讨论质因数分解的算法。</p>
<blockquote>
<p>算数基本定理，又称唯一分解定理：每个大于$1$的自然数，都可以写成质数次方的积，且这些质数从小到大排列后，仅存在这一种分解方式。</p>
</blockquote>
<p>换句话说，每个$n&gt;1$，都有唯一一种分解方式$\prod_{k} p_k^{\alpha_k} = n$。</p>
<a id="more"></a>
<h2 id="朴素方法"><a href="#朴素方法" class="headerlink" title="朴素方法"></a>朴素方法</h2><p>对于所有$p|n$，我们不断试除就可以了，与质数判定同理，我们不需要试超过$\sqrt{n}$的质数，因为这样的质数一定就是$n$本身，于是有代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;ll, ll&gt; factorize(ll x) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">map</span>&lt;ll, ll&gt; pcnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i * i &lt;= x; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) cnt++, x /= i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            pcnt[i] = cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 注意要把最后一个质数包括进去</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) pcnt[x] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> pcnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>注意我们可以直接在$n$上面做除法，而不用真的遍历到$\sqrt{n}$，因为发现一个质因数就可以把数据规模缩小，可以用哈希表把$log$消掉。这样，在最坏情况下这个算法时间复杂度是$O(\sqrt{n})$。当然，如果先把所有质数预处理出来，可以达到$O(\sqrt{\frac{n}{\log{n}}})$。</p>
<h2 id="Pollard’s-rho-算法"><a href="#Pollard’s-rho-算法" class="headerlink" title="Pollard’s rho 算法"></a>Pollard’s rho 算法</h2><h3 id="生日悖论-Birthday-Paradox"><a href="#生日悖论-Birthday-Paradox" class="headerlink" title="生日悖论 (Birthday Paradox)"></a>生日悖论 (Birthday Paradox)</h3><p>在介绍Pollard’s rho算法之前，我想先介绍一个概率学中的小问题：一个房间中要有多少人，出现两个人生日相同的概率大于等于$50\%$？</p>
<p>如果你是第一次看到这个问题，那么答案可能会让你惊讶：只需要$23$个人。这不是玄学，而是通过严谨的数学推理得出的，实验也证明了这一点。那么这个结果是如何得到的呢？</p>
<p>假设一年有$365$天，且每个人的生日是独立且均匀分布的，那么第一个人在第$x$天生日的概率是$\frac{1}{365}$，我们记为$Pr\{b_1=x\}$。那么现在来了第二个人，它的生日在第$x$天的概率$Pr\{b_2=x\}$也是$\frac{1}{365}$，此时两个人都在第$x$天的概率是<br>$$<br>Pr\{b_1=x \textbf{ and } b_2=x\} = \frac{1}{365^2}<br>$$<br>但是这个$x$我们可以取$365$个，于是两个人生日都在同一天的概率就是<br>$$<br>Pr\{b_1=b_2\} = 365\times \frac{1}{365^2} = \frac{1}{365}<br>$$<br>知道了任意两人生日相同的概率，就可以扩展到$k$个人中的两人生日相同的期望值，由于$k$个人中选$2$个，所以有:<br>$$<br>E = {k\choose2} \frac{1}{365} = \frac{k(k-1)}{730}<br>$$<br>所以期望存在至少一对生日相同的两人只需要$k=28$，$50\%$概率的计算由于比较复杂就不放上来了，但是可以推测，这个值一定会比$28$少。</p>
<p>于是我们可以知道，生日碰撞的概率是$O(\sqrt{n})$级别的，而不是我们下意识的$O(n)$。</p>
<h3 id="随机化算法"><a href="#随机化算法" class="headerlink" title="随机化算法"></a>随机化算法</h3><p>Pollard’s rho 算法的基本原理就是从待分解数$x$中任意找出两个数$a, b$，计算$gcd(|a - b|, x)$，当他们的$gcd$不是$1$的时候，我们就找到了$x$的一个因数。为什么是取两个呢？这就要利用我们上面说到的生日悖论了，因为只取一个$a$，此时$a|x$的几率很小，但是如果我们取两个数做差，出现$|a-b|$与$x$有公约数的几率就大很多了。事实上Pollard’s rho算法输出$x$的一个约数$p$的期望运行时间是$O(\sqrt{p})$。</p>
<p>那么如何选取这两个数呢？我们可以随机选取，但是Pollard’s rho算法使用的是一种二次剩余系的伪随机数生成函数<br>$$<br>f(x) = x^2 + c \pmod{n}<br>$$<br>为什么用这个函数呢？我没有在算法导论上看到具体说明，但是这个函数应该是对于Pollard’s rho算法的时间效率最优的函数。由于这个函数最后一定会出现循环，长得像希腊字母$\rho$，因此得名。</p>
<p><img src="/uploads/rho_cycle.jpg" width="30%" height="30%"></img><br>正因为这个性质，在出现环的时候我们也需要及时的退出并且换下一个随机数。我们可以使用Floyd判圈算法来判断是否出现了环，大意就是两个指针一个走一步一个走两步，如果有环那么两个指针一定会碰上，于是我们就可以有代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">f</span><span class="params">(ll x, ll c, ll p)</span> </span>&#123; <span class="keyword">return</span> (modmul(x, x, p) + c) % p; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">pollard_rho</span><span class="params">(ll x)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll c = mt() % (x - <span class="number">1</span>) + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll l = f(mt() % x, c, x), r = f(l, c, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// l是慢的指针，r是快的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (l != r) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll g = __gcd(<span class="built_in">abs</span>(l - r), x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (g &gt; <span class="number">1</span>) <span class="keyword">return</span> g;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        l = f(l, c, x), r = f(f(r, c, x), c, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如果$x$是个质数，那么我们可以用上一章的Miller–Rabin算法提前判掉，这样整个算法的期望时间复杂度就是$O(n^{0.25}\log{n})$了。</p>
<h3 id="常数优化"><a href="#常数优化" class="headerlink" title="常数优化"></a>常数优化</h3><p>上面的写法虽然时间复杂度是正确的，但是对于这道题还是不够的：<br>例题：<a href="https://www.luogu.com.cn/problem/P4718" target="_blank" rel="noopener">【模板】Pollard-Rho算法</a></p>
<p>我们还需要一些常数优化，Pollard’s rho算法的瓶颈就在于需要多少次才能得到一个约数$p$，以及找不到约数的时候做$gcd$的时间。前者并不好优化（玄学），但是减少$gcd$的次数却是可以做到的。</p>
<p>一个普遍的做法就是利用倍增的思想，先走完$2^k$步以后把$|a-b|$乘积统一进行$gcd$，然后换一个起点继续增加步数。如果出现乘积为$0$就说明我们遇到环了，此时退出并寻找下一个随机数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">pollard_rho</span><span class="params">(ll x)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll c = (ll)mt() % (x - <span class="number">1</span>) + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll s = <span class="number">0</span>, t = (ll)mt() % (x), val = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// i是步长</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;; i &lt;&lt;= <span class="number">1</span>, s = t, val = <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">1</span>; z &lt;= i; z++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            t = f(t, c, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            val = modmul(val, <span class="built_in">abs</span>(t - s), x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 如果遇到环了</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!val) <span class="keyword">return</span> x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 为了避免步数过长导致出不来结果，所以手动设定每127步计算一次</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!(z % <span class="number">127</span>)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ll g = __gcd(val, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (g &gt; <span class="number">1</span>) <span class="keyword">return</span> g;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll g = __gcd(val, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (g &gt; <span class="number">1</span>) <span class="keyword">return</span> g;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>随机化</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>[CF1097D] Makoto and a Blackboard</title>
    <url>/2019/12/25/CF1097D/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>一开始有一个整数$n(n\leq 10^{15})$，你可以执行以下操作$k(k\leq 10^4)$次：把$n$替换成$n$的任意一个约数(包括$1$和$n$)，假设每个约数都有相同概率被选中。现在问你$k$次操作后剩下这个数的期望值是多少。</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>我们知道期望公式为$\sum{x*p(x)}$，在这道题中，由于$x$的范围是离散且确定的，我们只需要知道每个$x$出现的概率就行了。</p>
<p>我们可以画一张图来看看转移的过程，以$6$为例：<br><img src="/uploads/cf1097d1.png" width="30%" height="30%"></img><br>我们可以得出几个有用的信息：</p>
<ul>
<li>图中所有节点都为原数$n$的约数</li>
<li>每个节点只会转移到小于等于它的数</li>
<li>因为$k$有限，这个流程可以直接模拟</li>
</ul>
<p>于是我们就可以用动态规划，令$f(i, x)$为第$i$轮时，得到数字为$x$的概率，可得：<br>$$<br>    f(i + 1, y) = f(i + 1, y) + f(i, x) * \frac{1}{|d(x)|} (y \in d(x))<br>$$<br>于是这题就解决了……</p>
<p>但是等等，这个玩意复杂度是多少呢？我们花$O(\sqrt{n})$预处理出来约数，约数个数大约是$O(\log{n})$，都在时间范围内。状态数量是$O(k\log{n})$，转移是$O(\log{n})$，合在一起$O(k\log^2{n})$但是交上去会T掉，为什么呢？</p>
<p>因为因数个数虽然是$O(\log{n})$，但是常数巨大，一般来说一个数的质因数分解可以表示为$\prod_k{(p_k^{\alpha_k})}$那么它会有$\prod_k{(\alpha_k+1})$个因数。</p>
<p>那么假如我给出$n=2^{20}\times3^{20}$，足足会有$21\times21=441$个因数，那么$10^4\times441^2=1.6*10^9$这不T到天上去？<br>那么接下来就要引出我写这篇博客的意义了，首先把我们刚刚得到的递推式优化一下。<br>$$<br>    f(i+1, y) = \sum_{ky|n} \frac{f(i, ky)}{|d(ky)|}<br>$$<br>而形如$g(n) = \sum_{d|n} f(d)$这类函数给我们的提示就是它很有可能是积性的，由于地方太小就不写证明了。当$f(i, x)$是积性函数的时候，$f(i,x)=\prod_{k} f(i, p_k^{\alpha_k})$。于是我们可以分别计算对于$n$的每个质因数的$f(i, p^{\alpha_k})$，然后把他们乘起来。此时时间复杂度为$O(k\sum{\alpha_i^2})$，此前为$O(k\prod{(\alpha_i+1)})$，对于$2^{20}\times3^{20}$来说，只需要$10^4\times800=8\times10^6$，是一个巨大的提升。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>$O(k\sum{\alpha_i^2})$</p>
<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll x = n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 获取质因数以及其指数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i &gt; x) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (x % i == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            x /= i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cnt++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (cnt) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            divs.push_back(&#123;i, cnt&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) divs.push_back(&#123;x, <span class="number">1</span>&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll ans = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 最外层是每个质因数p^i形式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> pair : divs) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> cnt = pair.second;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 滚动数组优化空间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">memset</span>(dp[<span class="number">0</span>], <span class="number">0</span>, <span class="keyword">sizeof</span>(dp[<span class="number">0</span>]));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dp[<span class="number">0</span>][cnt] = <span class="number">1L</span>L;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 从这里开始是每个状态的转移</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">memset</span>(dp[(i &amp; <span class="number">1</span>) ^ <span class="number">1</span>], <span class="number">0</span>, <span class="keyword">sizeof</span>(dp[<span class="number">0</span>]));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= cnt; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= j; s++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    dp[(i &amp; <span class="number">1</span>) ^ <span class="number">1</span>][s] +=</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        getInv(j + <span class="number">1</span>, MOD) * dp[i &amp; <span class="number">1</span>][j] % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (dp[(i &amp; <span class="number">1</span>) ^ <span class="number">1</span>][s] &gt; MOD) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        dp[(i &amp; <span class="number">1</span>) ^ <span class="number">1</span>][s] -= MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll tmp = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll pw = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cnt; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            tmp += (pw * dp[k &amp; <span class="number">1</span>][i] % MOD);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (tmp &gt; MOD) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                tmp -= MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            pw = pw * pair.first % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ans = (ans * tmp) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>数论</tag>
        <tag>概率期望</tag>
      </tags>
  </entry>
  <entry>
    <title>[SDOI2009] 虔诚的墓主人</title>
    <url>/2019/12/10/SDOI09Grave/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>一个$N \times M (N, M \leq 10^9)$的地图上有$W (W \leq 10^5)$棵树。对于图上没有树的点，如果在这个点上下左右都至少有$k (1 \leq k \leq 10)$个点，那么它会贡献${L\choose{k}} *  {R\choose{k}} * {U\choose{k}}* {D\choose{k}}$点虔诚度，问这个地图上所有虔诚度之和模$2147483648$（有毒）的值。</p>
<a id="more"></a>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题意很清晰，但是$N,M$的规模过于庞大，普通的模拟肯定不行了。但是我们注意到$W$的值并没有很大，所以实际上能贡献虔诚度的点只有$O(W^2)$个。但是这么多点一个个统计仍然太多了，所以很自然的我们想到了用扫描线法。</p>
<p>扫描线的统计仍然不是很直观，所以我们需要画一个图，假设我们现在的地图是这样的：<br><img src="/uploads/sdoi09grave1.png" alt="初始地图"><br>那么显然中间那个点是一个可以统计的点，如果我们记某个点$p$上方的树的数量为$U(p)$，下方为$D(p)$，左右分别为$L(p), R(p)$。那么这个点的虔诚度为${L(p)\choose{k}} *  {R(p)\choose{k}} * {U(p)\choose{k}}* {D(p)\choose{k}} = 1$。如果我们再加两个点，然后把目光集中在那根竖线上：<br><img src="/uploads/sdoi09grave3.png" alt="初始地图"><br>我们可以发现可以贡献虔诚度的点会在竖线的线段与其左右两边的横线的交点上。除此之外，我们知道在这条竖线（不包括两端）上的点$U(p)$和$D(p)$的值是完全相等的。如果我们回到那个公式，统计所有点的贡献：<br>$$<br>\begin{align}<br>S &amp; = \sum_{p} {L(p)\choose{k}} *  {R(p)\choose{k}} * {U(p)\choose{k}}* {D(p)\choose{k}}\\<br>&amp; = {U(p)\choose{k}} * {D(p)\choose{k}} * \bigg(\sum_{p} {L(p)\choose{k}} *  {R(p)\choose{k}}\bigg)<br>\end{align}<br>$$<br>根据求和公式的分配率可以推出来。这个公式意味着我们可以先得出一段竖线的${U(p)\choose{k}} * {D(p)\choose{k}}$值，然后乘以这个竖线区域所包含的所有横线的${L(p)\choose{k}} *  {R(p)\choose{k}}$就是这个区域所有的虔诚度贡献。竖线上的$U(p)$和$D(p)$可以通过从上到下以及预处理的方式求出来，现在问题在于怎么求出竖线上的横线贡献的$L(p), R(p)$：<br>$$<br>\sum_{i = l}^{r} {L(p[i])\choose{k}} *  {R(p[i])\choose{k}}<br>$$<br>可以看出这其实是一个区间查询问题，对于横线来说$L(p), R(p)$也可以通过从左到右的方式算出来，但是问题是每个横线区域与竖线的位置是密切相关的，随着向右边移动而变化：<br><img src="/uploads/sdoi09grave4.png" alt="扫描线"><br>这个时候扫描线的优势就出来了，我们可以把所有树的位置按照$x$坐标排序，如果$x$坐标相同则按照$y$坐标排序。然后我们从左到右，从上到下扫描，先统计个数，再更新横线的$L(p), R(p)$，最后把${L(p[i])\choose{k}} *  {R(p[i])\choose{k}}$放进区间查询的数据结构里面。因为这个虔诚度是可以加起来的所以区间查询用树状数组就足够了。<br><img src="/uploads/sdoi09grave5.gif" alt="动态演示"></p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(W\log{W})$，分别在排序和树状数组查询上。</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cntX[MAXN * <span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cntY[MAXN * <span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> curY[MAXN * <span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">FenwickTree tree;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> tot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tot);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 组合数打表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= min(i, <span class="number">10</span>); j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            C[i][j] = (C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> x, y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        points[i].x = x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        points[i].y = y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        discrete.add(x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        discrete.add(y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    discrete.discretize();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sort(points, points + tot);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cnt++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i == tot || points[i].x != points[i + <span class="number">1</span>].x) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> xx = discrete.get(points[i].x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 横坐标为xx的点共有多少个</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            cntX[xx] = cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cnt = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        points[i].x = discrete.get(points[i].x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        points[i].y = discrete.get(points[i].y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 纵坐标为y的点共有多少个</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        cntY[points[i].y]++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll ans = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> curX = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 当前y坐标左边有多少个点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        curX++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i &amp;&amp; points[i].x != points[i - <span class="number">1</span>].x) curX = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i != tot &amp;&amp; points[i].x == points[i + <span class="number">1</span>].x) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> l = points[i].y, r = points[i + <span class="number">1</span>].y - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (l &lt; r) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ll U = choose(curX, k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ll D = choose(cntX[points[i].x] - curX, k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ll sum = ((tree.getSum(r) - tree.getSum(l)) % MOD + MOD) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ans = (ans + (sum * U % MOD) * D % MOD) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        curY[points[i].y]++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll now = choose(curY[points[i].y], k) *</span></pre></td></tr><tr><td class="code"><pre><span class="line">                 choose(cntY[points[i].y] - curY[points[i].y], k) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll pre =</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ((tree.getSum(points[i].y) - tree.getSum(points[i].y - <span class="number">1</span>)) % MOD +</span></pre></td></tr><tr><td class="code"><pre><span class="line">             MOD) %</span></pre></td></tr><tr><td class="code"><pre><span class="line">            MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 注意只计算当前的总和，而不是之前的所有和</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        tree.increase(points[i].y, (now - pre + MOD) % MOD);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>扫描线</tag>
        <tag>组合数学</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>二分法杂谈</title>
    <url>/2019/12/09/binary-search/</url>
    <content><![CDATA[<p>学算法一年了，做了很多题，但是对于二分法这块一直不是很明白。 有时候遇到二分答案的问题经常要调好长时间才能写对，有些时候就是看别人二分是怎么写的就照抄，但是并不清楚为什么这么写是对的。今天总结了一下二分法的几种情况以及它们的思路。</p>
<a id="more"></a>

<h2 id="二分的写法"><a href="#二分的写法" class="headerlink" title="二分的写法"></a>二分的写法</h2><p>网上的二分法普遍有两种写法，一种是左闭右开<code>[l, r)</code>的写法，一种是左闭右闭<code>[l, r]</code>的写法。左闭右开写法的优点是上下界比较宽松，不会出现死循环，而且最终答案$l,r$都可以用。但是缺点就是对于将要介绍的四种情况，转移时的$\pm 1$的位置变换很令人头疼。所以这里我将要使用的是后一种方式，但是左闭右闭一定要注意转移的写法<code>l = mid + 1</code>和<code>r = mid - 1</code>，此时$\pm 1$都是固定的，但是最优解可能不在区间内，所以需要一个外层变量<code>ans</code>来确保得到的是最优解。这种写法的优点是非常好想。</p>
<h2 id="二分法四种情况"><a href="#二分法四种情况" class="headerlink" title="二分法四种情况"></a>二分法四种情况</h2><p>需要二分答案的时候，要先确保数据具有单调性。也就是说给定一个集合$S$，里面有一个需要寻找的答案，那么有：如果$S_i$满足条件，那么所有$S_j(j\geq i)$（或者$j\leq i$），都满足条件，并且如果$S_i$不满足条件，则所有$S_j(j&lt;i)$（或者$j&gt;i$）都不满足条件，那么这个数据就具有单调性。</p>
<p>在单调的数据下，我们需要找一个满足条件的答案就可以用二分法。我们都学过二分搜索查找一个数，但是有时候我们不是查找一个数，而是找一个满足条件的最小/最大值呢？如果满足条件值并不存在呢？我们把所有情况分成四种以便区分。假设数据是一个非降序列，那么他们分别是：不小于条件最小位置，严格大于等于条件最小位置，不大于条件的最大位置，严格小于条件的最大位置。</p>
<h3 id="不小于条件最小位置"><a href="#不小于条件最小位置" class="headerlink" title="不小于条件最小位置"></a>不小于条件最小位置</h3><p>假如给定一个非降序列：$S={1,1,4,4,5,6,7,8}$，假如我们想知道$S_i \geq 3$的最小位置，在此处显然是位置$3$，而不是位置$4$。在这种情况下，我们二分法找到$S_i$满足$S_i \geq 3$以后仍然要往更小的范围去寻找，这样才能保证是最小位置，那么在二分写法里面，就是将$r$的值缩小，那么最后一个满足条件的$mid$就是答案。由此可得一个写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans = n + <span class="number">1</span>; <span class="comment">// 如果目标不存在就返回一个不存在的位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= k) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        	ans = min(ans, mid);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            r = mid - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            l = mid + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="严格大于条件最小位置"><a href="#严格大于条件最小位置" class="headerlink" title="严格大于条件最小位置"></a>严格大于条件最小位置</h3><p>我们换一个非降序列：$S={1,1,3,4,5,6,7,8}$，假如我们想知道$S_i &gt; 3$的最小位置，那么我们可以看出应该是位置$4$，那么我们只需要把<code>if (arr[mid] &gt;= k)</code>改成<code>if (arr[mid] &gt; k)</code>就行了。</p>
<h3 id="不大于条件的最大位置"><a href="#不大于条件的最大位置" class="headerlink" title="不大于条件的最大位置"></a>不大于条件的最大位置</h3><p>假设这个序列是$S={1,1,3,3,3,6,7,8}$，然后我们要找一个$S_i \leq 3$的最大位置，那么我们可以看出应该是位置$5$。在此条件下，如果我们找到一个$S_i \leq 3$我们仍然需要往后找以确保能找到最大位置。那么在二分写法里面就是将$l$增大，那么我们只需要在此时找到最大的那个$mid$就是答案，写法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="comment">// 如果目标不存在就返回一个不存在的位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (arr[mid] &lt;= k) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        	ans = max(ans, mid);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            l = mid + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            r = mid - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="严格小于条件最大位置"><a href="#严格小于条件最大位置" class="headerlink" title="严格小于条件最大位置"></a>严格小于条件最大位置</h3><p>我们只需要把<code>if (arr[mid] &lt; k)</code>改成<code>if (arr[mid] &lt;= k)</code>就行了。</p>
<h3 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h3><p>对于序列并非升序的情况，我们可以将它转化为升序思考。绝大部分二分的题都可以归结为这四种情况，像最大的最小值就是满足条件的最大位置，最小的最大值就是满足条件的最小位置。只要想清楚自己想要二分出来的答案是什么样的就可以轻松A掉题了。</p>
<p>$$<br>\begin{align}<br>F(n) &amp;= \frac{\sum_{i=0}^{n-1} D_i{n\choose i} (n-i)}{n!} \\<br>F(n) &amp;= \dfrac{\sum_{i=0}^{n-1} i!\sum_{j=0}^{i}\frac{(-1)^j}{j!} {n\choose i}(n-i) }{n!} \\<br>F(n) &amp;= \dfrac{\sum_{i=0}^{n-1} \sum_{j=0}^{i}\frac{(-1)^j}{j!} \dfrac{n!}{(n-i-1)!} }{n!} \\<br>F(n) &amp;= \sum_{i=0}^{n-1} \dfrac{1}{(n-i-1)!}\sum_{j=0}^{i}\dfrac{(-1)^j}{j!} \\<br>F(n) &amp;= \sum_{i=0}^{n-1} (\dfrac{1}{i!}\sum_{j=0}^{n-i-1}\dfrac{(-1)^j}{j!})<br>\end{align}<br>$$<br>$$<br>\begin{align}<br>g(i) = \sum_{j=0}^{i} \frac{(-1)^j}{j!}\\<br>f(i) = \dfrac{1}{i!}\\<br>T(n) = \sum_{i=0}^{n} (f(i) g(n-i))\\<br>F(n) = T(n-1)<br>\end{align}<br>$$</p>
<p>假设$n$是个偶数<br>$$<br> E(i) = \frac{1}{i}(E(i-1)+1) + \frac{i-2}{i}E(i-2)<br>$$</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>算法</category>
        <category>二分法</category>
      </categories>
      <tags>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>[ICPC NAQ2018] Problem L: Longest Life</title>
    <url>/2019/12/04/NAQ18L/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>正常情况下每分钟你的生命就会流失一分钟（废话），但是现在科技这么发达你有（$N \leq 10^5$）次改变生命流失速度的机会，这些机会会出现在$N$个不同的时间点上。但是如果你改变了生命流失速率，那么你就会瞬间流失 $C$ 分钟的生命。如果你能够自由选择是否接受这些机会，问你最晚的死亡时间是什么时候。</p>
<a id="more"></a>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>如果用动态规划的方式去求解，那么可以很容易得到一个DP方程，如果我们设 $f(i) =$ 以第$i$个药片作为最后使用的药片的最晚死亡时间。那么转移方程就应该是：<br>$$f(i) = \max \{g(i, k)\} \ (0 \leq k &lt; i)$$</p>
<p>$g(i, k)$就表示之前使用了第$k$个药片，换成第$i$个药片以后所能存活的最长时间。如果我们把整个过程看做一个线性函数斜率不断改变的过程，那么$y$坐标就是不做改变应该存活的时间，而$x$轴就代表实际存活的时间。于是有图</p>
<p><img src="/uploads/naq18L1.png" alt="药剂效果"></p>
<p>我们要求的就是两个直线触及天花板的那个点的横坐标。</p>
<p>假设一开始死亡时间为$T$，药片出现时间为$t[i]$，改变的斜率为$k[i]$，那么有</p>
<p>$$g(i, k) = t[i] +  \frac{T-\text{使用i时的高度}}{k[i]}$$</p>
<p>合并到DP方程展开后就是：<br>$$<br>f(i)= \max \bigg( t[i]+\frac{T-(k[j]t[j]+T-k[j]f(j)+k[j](t[i]-t[j]) + C)}{k[i]} \bigg)<br>$$<br>化简一下<br>$$<br>f(i)= \max \bigg( t[i]-\frac{C+k[j](t[i]-f(j))}{k[i]} \bigg)<br>$$<br>其中$1 \leq k&lt;i$，如果看不懂的话手动推一下就好了。</p>
<p>但是观察一下数据范围，$10^5$ 显然对于这个$O(N^2)$ 的DP来说太大了，但是我们观察到$t[i]$是单调上升的，而且对于进来的不同$k[i]$，有一部分斜率比之前最小值要大的显然不能构成最优解，也就是说，这里面$j$的选择是可以优化的。那么如果想让程序不超时，我们需要一个$O(1)$的最优解选择方法，那么就要想到斜率DP。</p>
<p>我们继续优化这个式子，假设现在有两个药片$s, j$且$s &lt; j &lt; i$。那么假设$j$是比$s$更优的选择，那么一定满足：<br>$$t[i]&gt; \frac{k[s]f(s)-k[j]f(j)}{k[s]-k[j]}$$<br>当这个条件满足的时候，我们知道选择第$j$个药片比第$s$个药片要优。<br>如果我们定义$slope(s, j) = $上面这个式子，也就是相当于点$s$到点$j$的斜率，那我们需要判断满足这个条件的点具有的特征。假设对于三个点$s &lt; j &lt; i$并且$slope(s, j) &gt; slope(j, i)$，那么我们可以判断点$j$一定不会形成最优解。<br>剩下的就是用单调队列维护下凸包的操作了，但是要注意不要把$k[i]$不单调的点也算进去，具体见代码。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(N)$，因为每个元素只会进队列一次，出列一次。</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里我用了long double来防止精度不够</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> LD;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pill</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LD ks;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Pill() &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Pill(ll t, ll x, ll y) : t(t), ks(y / (LD)x) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Pill&amp; b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> t &lt; b.t; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Pill&gt; pills;</span></pre></td></tr><tr><td class="code"><pre><span class="line">LD dp[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟了一个队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> QQ[MAXN * <span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 斜率计算</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">LD <span class="title">slope</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> j)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> (pills[j].ks * dp[j] - pills[s].ks * dp[s]) /</span></pre></td></tr><tr><td class="code"><pre><span class="line">           (pills[j].ks - pills[s].ks);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;n, &amp;m, &amp;k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll t, x, y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;t, &amp;x, &amp;y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pills.emplace_back(t, x, y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pills.emplace_back(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sort(pills.begin(), pills.end());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dp[<span class="number">0</span>] = n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    QQ[<span class="number">1</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LD minn = <span class="number">1e30</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (pills[i].ks &gt;= minn) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; slope(QQ[l], QQ[l + <span class="number">1</span>]) &lt;= pills[i].t) ++l;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> opt = QQ[l];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        LD ki = pills[i].ks;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        LD kj = pills[opt].ks;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 根据公式从dp[j]计算dp[i]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        LD newx = (LD)pills[i].t - (k + kj * (pills[i].t - dp[opt])) / ki;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dp[i] = max(dp[i], newx);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; slope(QQ[r - <span class="number">1</span>], QQ[r]) &gt;= slope(QQ[r], i)) r--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        QQ[++r] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        minn = min(minn, pills[i].ks);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LD ans = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ans = max(ans, dp[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.7Lf"</span>, ans);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>斜率DP</tag>
      </tags>
  </entry>
  <entry>
    <title>[洛谷P3067] 平衡的奶牛群</title>
    <url>/2019/12/04/LuoguP3067/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你$n(n\leq20)$个数，从中任意选出一些数，记为集合$S$，使得存在一种$s \in S$满足$sum(s) == sum(\bar{s})$。求这样的选数方案有多少种。</p>
<a id="more"></a>

<p>介绍一种解这道题的新思路：利用$bitset$。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>先从暴力算法开始，我们只需要枚举所有集合以及他们的子集，如果发现子集以及其补集的和相等，那么这个集合就是一种方案。</p>
<p>更具体的说，假设$P$是原集合，$S$是$P$的所有子集。如果对于所有$s \in S$ 的子集有 $sum(s) == sum(\bar{s})$，那么$S$就贡献一个答案。</p>
<p>于是我们可以写出如下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s1 = i; s1; s1 = (s1 - <span class="number">1</span>) &amp; i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (sum[s1] == sum[i ^ s1]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ans++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>子集求和是$O(n2^n)$但是枚举子集的子集是$O(3^n)$的，显然会TLE的死死的。</p>
<p>于是我们会想到折半枚举，假设我们能枚举前一半和后一半的所有子集，那么应该怎么确定哪些子集是符合条件的呢？</p>
<p>假设对于一个集合$S_1$我们有一个子集$s_1$和补集$\bar{s_1}$，同时我们有另一个集合$S_2$和子集$s_2$和$\bar{s_2}$，如果这个集合能合并，那么我们需要有</p>
<ul>
<li>$S_1 \cap S_2 = \emptyset$</li>
<li>$sum(s_1) + sum(s_2) == sum(\bar{s_1}) + sum(\bar{s_2})$</li>
</ul>
<p>第一个条件用折半枚举可以保证。对于第二个来说，假设我们有$sum(s_1)-sum(\bar{s_1})=d$，那么如果$sum(\bar{s_2})-sum(s_2)=d$，那么就满足了第二个条件。</p>
<p>于是我们可以枚举左边的所有可能，然后记录有多少个集合具有差值$d$。然后在枚举右边的时候，对于每个右边子集，找到它的子集总共能匹配多少个左边子集。为了表述清晰，设$S_l$为左边集合的子集，$S_r$为右边集合的子集。对于每个右边集合的子集$s_r \subset S_r$，以及它的子集$ss_r \subset s_r$，我们要求：<br>$$<br>    \sum_{s_r}|\bigcap_{ss_r\in s_r}{s_l\text{使得}ss_r\text{可以与左边合并}}|<br>$$</p>
<p>所以我们要求差值为$d$集合的并集，但是集合个数有$2^{\frac{n}{2}}$个，无法用状态压缩($int$和long long)表示。于是我们就想到了使用$bitset$，$2^{\frac{n}{2}}$在这道题中仅有$1024$，$bitset$实现中每个集合所占空间仅有$\frac{1024}{8} = 128$字节。</p>
<p>我们再来计算一下总共可能会有多少种差值，不好计算但是可以估算出是小于$3^{10}=6\times10^4$的，也就是最坏也只是$sum$数组的内存级别。</p>
<p>于是我们只要维护一个<code>map&lt;int,bitset&lt;1024&gt;&gt;</code>就可以了。</p>
<p>以下是这种解法对应的代码：</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>折半枚举的复杂度是$3^{n/2}$，另一半查询的复杂度是因为有map所以是$\log$级别。<br>加上预处理以后的时间复杂度<br>$$<br>O(n2^n+3^{\frac{n}{2}}\log{3^{\frac{n}{2}}})<br>$$</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">25</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, k;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum[(<span class="number">1</span> &lt;&lt; <span class="number">20</span>) + <span class="number">5</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">bitset</span>&lt;1024&gt;&gt; mpp;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 求出所有子集的和</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> ((i &gt;&gt; j) &amp; <span class="number">1</span>) sum[i] += arr[j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 枚举左边</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> mid = n / <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; mid); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s1 = i;; s1 = (s1 - <span class="number">1</span>) &amp; i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            mpp[sum[s1 ^ i] - sum[s1]].<span class="built_in">set</span>(i, <span class="literal">true</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!s1) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 枚举右边</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; (n - mid)); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">bitset</span>&lt;1024&gt; sss(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 这里我刻意保留了子集为空的情况</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s1 = i;; s1 = (s1 - <span class="number">1</span>) &amp; i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> diff = sum[s1 &lt;&lt; mid] - sum[(s1 ^ i) &lt;&lt; mid];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            sss |= mpp[diff];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!s1) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 对答案的贡献就是这个集合的大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        ans += sss.count();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 要减去左边右边都是空集的情况</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans - <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>中途相遇/折半枚举</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>[CF1238E] Keyboard Purchase</title>
    <url>/2019/12/04/CF1238E/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你一个文本串$S(len(S) \leq 10^5)$，由前$m(m\leq20)$个小写字母组成。要你求一种键盘的排列，使得打出这个文本串的消耗最小。这个消耗$cost$的计算方式为相邻字符的键盘距离之和，也就是$\sum_{i=2}^{n} |pos_{s_i-1}-pos_{s_i}|$。只需要输出这个最小消耗就行。</p>
<a id="more"></a>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>打比赛时候以为是一道贪心题，结果怎么做都不对，后来看到$(m\leq20)$就在想状压DP，但是完全不会做这种对于排列的DP。因为无法确定这个字符应该插入到什么位置，也就没法计算$cost$。<br>赛后看题解才知道原来DP还可以有预先计算$cost$这种操作，那么公式也就很好想了。<br>我们先预处理文本串$S$中相邻字符对出现的次数。设$f(S)$为当前使用了集合为$S$的字符进行排列，所能产生的最小$cost$。当我们加入一个新字符的时候，我们除了计算当前最小值，还要把还没有使用过的字符与使用过的字符所产生的$cost$也加进去，由此可得：<br>$$<br>\begin{aligned}<br>f(S) &amp;=\min\{f(S-\{j\})\} &amp; [j\in S]\\<br>f(S) &amp;= f(S) + cost(i, j) &amp; [i \in S,j\in \overline{S}]\\<br>\end{aligned}<br>$$<br>那么整体最小值就是$f(S的全集)$了。<br>顺便吐槽一下状压$O(m^22^m)$都$4\times10^8$了，结果$CF$神机居然$0.5$秒就跑出来了也是可以，我还以为会超时。。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(m^22^m+S)$</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录点对的数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt[<span class="number">25</span>][<span class="number">25</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">ll dp[(<span class="number">1</span> &lt;&lt; <span class="number">20</span>) + <span class="number">5</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, text);</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">char</span> a = text[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">char</span> b = text[i + <span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (a == b) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cnt[a - <span class="string">'a'</span>][b - <span class="string">'a'</span>]++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cnt[b - <span class="string">'a'</span>][a - <span class="string">'a'</span>]++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dp));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; (<span class="number">1</span> &lt;&lt; k); s++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> ((s &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                dp[s] = min(dp[s], dp[s ^ (<span class="number">1</span> &lt;&lt; i)]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!((s &gt;&gt; i) &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// 未访问的点的贡献</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> ((~s &gt;&gt; j) &amp; <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    dp[s] += cnt[i][j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[(<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩DP</tag>
      </tags>
  </entry>
  <entry>
    <title>你好，世界</title>
    <url>/2019/12/04/hello-world/</url>
    <content><![CDATA[<p>欢迎，这里是DXTsT，又名小裙子。<br>这个博客里包含：算法、图形学、数学等方面的研究以及知识总结。<br>欢迎对其中内容进行评论，或者加我讨论。</p>
<h3 id="注意，本博客的所有题解代码都不保证能够直接提交AC，只是截取了部分核心代码，能不能AC还是要靠自己！"><a href="#注意，本博客的所有题解代码都不保证能够直接提交AC，只是截取了部分核心代码，能不能AC还是要靠自己！" class="headerlink" title="注意，本博客的所有题解代码都不保证能够直接提交AC，只是截取了部分核心代码，能不能AC还是要靠自己！"></a>注意，本博客的所有题解代码都不保证能够直接提交AC，只是截取了部分核心代码，能不能AC还是要靠自己！</h3><p>开幕雷击，吓到了吗？</p>
<a id="more"></a><link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
  </entry>
  <entry>
    <title>[ICPC NAQ2019] Problem L: Traveling Merchant</title>
    <url>/2019/12/03/NAQ19L/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>一条线上有$N(N\leq10^5)$个城市，标号从$1$到$N$。每个城市物价根据星期的不同而有所不同，具体来说，每个城市有原价$v_i$，变动$d_i$，周一到周日的变化量为$\{+0, +v_i, +2v_i, +3v_i, +2v_i, +v_i, +0\}$。现在有$Q(\leq 10^5)$个询问，每个询问商人会从$l$号城市往$r$号城市旅行，$l$有可能大于$r$，此时要逆行。求次旅行最大的差价$(price_j-price_i)$其中$(j &gt; i)$是多少。</p>
<a id="more"></a>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>$10^5$数据量+$10^5$查询，那么很明显直接模拟是不行的，但是这题题意看起来用线段树也不太好维护（有可能是我太菜了不会）。于是有没有又好维护跑的又快的数据结构呢？于是祭出分块大法。</p>
<p>我们可以把所有城市按照标号分成$\sqrt{N}$块，每一块内存储3个信息:<br>$$\{整块内最大价格，整块内最小价格，整块内最大差价\}$$<br>这样查询的时候可以两端直接模拟，中间根据这三个信息更新最大差价，每次查询复杂度不会超过$O(\sqrt{N})$。</p>
<p>由于有星期这个设定，所以我们要维护$7$重块，每个块信息代表当从第$k$天开始从左到右（反向旅行同理）旅行的信息。这个问题便迎刃而解了，看官方题解好像是用的线段树，但是感觉应该很难写，我用分块一发就过了，线段树不知道要调多久。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(N+Q\sqrt{N})$</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100005</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, k;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Info</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> v, d, b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 块信息，最大值，最小值，最大差值，左右延伸范围</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> maxx;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> minn;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> maxprofit;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> lft;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> rgt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> raise[<span class="number">7</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> CASE;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 正向旅行块</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Block blocks[<span class="number">7</span>][<span class="number">505</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 反向旅行块</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Block blocks2[<span class="number">7</span>][<span class="number">505</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> B;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Info cities[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 正向计算</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> d, <span class="keyword">int</span>&amp; maxx, <span class="keyword">int</span>&amp; minn, <span class="keyword">int</span>&amp; maxprofit)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt;= r; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> day = (j - l + d) % <span class="number">7</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> price = cities[j].v + raise[day] * cities[j].d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        minn = min(minn, price);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        maxprofit = max(maxprofit, price - minn);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        maxx = max(maxx, price);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 反向计算</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal2</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> l, <span class="keyword">int</span> d, <span class="keyword">int</span>&amp; maxx, <span class="keyword">int</span>&amp; minn, <span class="keyword">int</span>&amp; maxprofit)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = r; j &gt;= l; j--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> day = (r - j + d) % <span class="number">7</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> price = cities[j].v + raise[day] * cities[j].d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        minn = min(minn, price);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        maxprofit = max(maxprofit, price - minn);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        maxx = max(maxx, price);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 同样也是一正一反</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query2</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> l)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> d = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> maxx = <span class="number">0</span>, minn = <span class="number">1e9</span>, prof = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> rs = max(l, blocks2[<span class="number">0</span>][cities[r].b].lft);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cal2(r, rs, d, maxx, minn, prof);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    d = (d + r - rs + <span class="number">1</span>) % <span class="number">7</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cities[r].b - <span class="number">1</span>; i &gt;= cities[l].b + <span class="number">1</span>; i--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        prof = max(prof, blocks2[d][i].maxx - minn);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        minn = min(minn, blocks2[d][i].minn);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        prof = max(prof, blocks2[d][i].maxprofit);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        maxx = max(maxx, blocks2[d][i].maxx);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        d = (d + blocks2[d][i].rgt - blocks2[d][i].lft + <span class="number">1</span>) % <span class="number">7</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (cities[l].b != cities[r].b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> ls = min(r, blocks2[<span class="number">0</span>][cities[l].b].rgt);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cal2(ls, l, d, maxx, minn, prof);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> prof;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> d = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ls = min(r, blocks[<span class="number">0</span>][cities[l].b].rgt);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> maxx = <span class="number">0</span>, minn = <span class="number">1e9</span>, prof = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cal(l, ls, d, maxx, minn, prof);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    d = (d + ls - l + <span class="number">1</span>) % <span class="number">7</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cities[l].b + <span class="number">1</span>; i &lt;= cities[r].b - <span class="number">1</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        prof = max(prof, blocks[d][i].maxx - minn);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        minn = min(minn, blocks[d][i].minn);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        prof = max(prof, blocks[d][i].maxprofit);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        maxx = max(maxx, blocks[d][i].maxx);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        d = (d + blocks[d][i].rgt - blocks[d][i].lft + <span class="number">1</span>) % <span class="number">7</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (cities[l].b != cities[r].b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> rs = max(l, blocks[<span class="number">0</span>][cities[r].b].lft);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cal(rs, r, d, maxx, minn, prof);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> prof;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    B = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n) + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> cnt = (n + B - <span class="number">1</span>) / B;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;cities[i].v, &amp;cities[i].d);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cities[i].b = (i - <span class="number">1</span>) / B + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">7</span>; d++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 确定块的左右边界</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            blocks[d][i].lft = B * (i - <span class="number">1</span>) + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            blocks[d][i].rgt = B * i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            blocks2[d][i].lft = B * (i - <span class="number">1</span>) + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            blocks2[d][i].rgt = B * i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> l = blocks[d][i].lft, r = blocks[d][i].rgt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Block&amp; cur = blocks[d][i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cur.maxx = <span class="number">0</span>, cur.minn = <span class="number">1e9</span>, cur.maxprofit = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Block&amp; cur2 = blocks2[d][i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cur2.maxx = <span class="number">0</span>, cur2.minn = <span class="number">1e9</span>, cur2.maxprofit = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cal(l, r, d, cur.maxx, cur.minn, cur.maxprofit);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cal2(r, l, d, cur2.maxx, cur2.minn, cur2.maxprofit);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (m--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> l, r;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (l &lt;= r) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(l, r));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query2(l, r));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>[ICPC NAQ2019] Problem E: NVMLS</title>
    <url>/2019/12/03/NVMLS/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你$N$个大写字母组成的单词和一串大写非元音字母所组成的字符串（$L\leq 3\times 10^5$）。已知字符串$L$是由给出单词的非元音字母组成的，求将这个字符串还原回正常单词以后，元音字母数量最多的一个原串。数据保证$\sum_{i=0}^{n} len(s_i) \leq 10^5$。</p>
<a id="more"></a>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于模式串$L$和匹配串的数据很大，所以普通匹配肯定是不行的。可以考虑$AC$自动机或者Hash，但是我$AC$自动机写挂了所以改用$Hash$了。同时匹配结束以后我们还需要用$DP$来获取元音字母最多的还原串。<br>假设我们已经获取每个位置上的匹配串，假设位置$i$的所有匹配串为$m_i$，每个匹配串的元音字母数量为$v[j]$，匹配长度为$l[j]$。那么可得$DP$公式：<br>$$<br>f(i)=\max_{j \in m_i}\{f(i-l[j]+v[j])+v[j]\}<br>$$<br>那么$f(L)$就是最多的元音数量。因为题目要输出这个还原串，所以我们在$DP$的时候还要记录每一个状态是由哪一个匹配串转移而来的，这样就可以从后往前构造原串。</p>
<p>如果我们考虑这个$DP$的时间复杂度，会发现它很有可能是$O(NL)$的，显然会超时。但是仔细一想我们会发现，对于每一个位置，长度为$x$的匹配串有且仅能有一个，那么我们其实只需要枚举长度就好了。对于一个总长度不超过$N$的单词集合，长度的种类最多只有$O(\sqrt{N})$种。因为$\sum_{i=1}^k{i}=N$可得$\frac{k(k+1)}{2}=N$，解得$k=\sqrt{2N+0.25}-0.5$。<br>如果每个位置只有最多$O(\sqrt{N})$个匹配串，那么总复杂度$O(L\sqrt{N})$就可以接受了。<br>对于维护$\sqrt{N}$个长度的$Hash$我们也可以动态的$O(L)$时间来实现，只要在超出长度的时候$hash - pow[len]$就可以了。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(L\sqrt{N})$</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">300005</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, k;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> CASE;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 单词字符串信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node2</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span> str;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ull hash1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll hash2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 长度离散化结构</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Discretization</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; xp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator xend;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> xend - xp.begin(); &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; xp.push_back(val); &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">discretize</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sort(xp.begin(), xp.end());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        xend = unique(xp.begin(), xp.end());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> lower_bound(xp.begin(), xend, val) - xp.begin() + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get2</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123; <span class="keyword">return</span> xp[num - <span class="number">1</span>]; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Discretization dis;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> text[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串hash匹配表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hashList[MAXN * <span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 原单词信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Node2 strList[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 每个位置匹配的串</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; matches[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> opt[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">removeVowel</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">int</span>&amp; cnt)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cnt = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : str) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (c == <span class="string">'A'</span> || c == <span class="string">'E'</span> || c == <span class="string">'I'</span> || c == <span class="string">'O'</span> || c == <span class="string">'U'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cnt++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            res.push_back(c);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 我用了双hash，一个自然溢出一个模数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ull powh[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line">ll powh2[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hasher</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ull hashB1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll hashB2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> cnt1;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        powh[<span class="number">0</span>] = powh2[<span class="number">0</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAXN; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            powh[i] = powh[i - <span class="number">1</span>] * <span class="number">277L</span>L;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            powh2[i] = powh2[i - <span class="number">1</span>] * <span class="number">1999L</span>L % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Hasher() &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB1 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB2 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removel</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> len)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB1 -= powh[len] * (ull)c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB2 -= (powh2[len] * c) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB2 %= MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (hashB2 &lt; <span class="number">0</span>) hashB2 += MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertr</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB1 *= powh[<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB1 += c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB2 = (hashB2 * powh2[<span class="number">1</span>]) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB2 += c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB2 %= MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Hasher hasher;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Hasher dynHash[<span class="number">505</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; sss;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    hasher.init();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> tot = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, text);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(text)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">string</span> rem = removeVowel(s, cnt);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!sss.count(rem) || cnt &gt; sss[rem]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            sss[rem] = cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            hasher.clear();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> a : rem) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                hasher.insertr(a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            strList[tot] = &#123;s, hasher.hashB1, hasher.hashB2, cnt&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            hashList[hasher.hashB1 % (MAXN * <span class="number">2</span>)].push_back(tot);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            tot++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            dis.add(rem.size());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dis.discretize();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, text + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    n = <span class="built_in">strlen</span>(text + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dp[i] = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> sz = dis.size();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = sz; j &gt;= <span class="number">1</span>; j--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 动态维护每个长度的hash</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            dynHash[j].insertr(text[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> len = dis.get2(j);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (i &gt; len) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                dynHash[j].removel(text[i - len], len);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (i &gt;= len) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> loc = dynHash[j].hashB1 % (MAXN * <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// hash匹配</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> v : hashList[loc]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    Node2&amp; nd = strList[v];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (nd.hash2 == dynHash[j].hashB2) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        matches[i].push_back(v);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : matches[i]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Node2&amp; nd = strList[a];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> p = i - nd.str.size() + nd.cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (dp[p] &gt;= <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> nx = dp[p] + nd.cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (dp[i] &lt; nx) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    dp[i] = nx;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    opt[i] = a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> k = n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 构造原串</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        res.push_back(opt[k]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> d = strList[opt[k]].str.size() - strList[opt[k]].cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        k -= d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = res.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, strList[res[i]].str.c_str());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>题解</category>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>字符串哈希</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
</search>
