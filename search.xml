<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[CF1097D] Makoto and a Blackboard</title>
    <url>/2019/12/25/CF1097D/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>一开始有一个整数$n(n\leq 10^{15})$，你可以执行以下操作$k(k\leq 10^4)$次：把$n$替换成$n$的任意一个约数(包括$1$和$n$)，假设每个约数都有相同概率被选中。现在问你$k$次操作后剩下这个数的期望值是多少。</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>我们知道期望公式为$\sum{x*p(x)}$，在这道题中，由于$x$的范围是离散且确定的，我们只需要知道每个$x$出现的概率就行了。</p>
<p>我们可以画一张图来看看转移的过程，以$6$为例：<br><img src="/uploads/cf1097d1.png" width="30%" height="30%"></img><br>我们可以得出几个有用的信息：</p>
<ul>
<li>图中所有节点都为原数$n$的约数</li>
<li>每个节点只会转移到小于等于它的数</li>
<li>因为$k$有限，这个流程可以直接模拟</li>
</ul>
<p>于是我们就可以用动态规划，令$f(i, x)$为第$i$轮时，得到数字为$x$的概率，可得：<br>$$<br>    f(i + 1, y) = f(i + 1, y) + f(i, x) * \frac{1}{|d(x)|} (y \in d(x))<br>$$<br>于是这题就解决了……</p>
<p>但是等等，这个玩意复杂度是多少呢？我们花$O(\sqrt{n})$预处理出来约数，约数个数大约是$O(\log{n})$，都在时间范围内。状态数量是$O(k\log{n})$，转移是$O(\log{n})$，合在一起$O(k\log^2{n})$但是交上去会T掉，为什么呢？</p>
<p>因为因数个数虽然是$O(\log{n})$，但是常数巨大，一般来说一个数的质因数分解可以表示为$\prod_k{(p_k^{\alpha_k})}$那么它会有$\prod_k{(\alpha_k+1})$个因数。</p>
<p>那么假如我给出$n=2^{20}\times3^{20}$，足足会有$21\times21=441$个因数，那么$10^4\times441^2=1.6*10^9$这不T到天上去？<br>那么接下来就要引出我写这篇博客的意义了，首先把我们刚刚得到的递推式优化一下。<br>$$<br>    f(i+1, y) = \sum_{ky|n} \frac{f(i, ky)}{|d(ky)|}<br>$$<br>而形如$g(n) = \sum_{d|n} f(d)$这类函数给我们的提示就是它很有可能是积性的，由于地方太小就不写证明了。当$f(i, x)$是积性函数的时候，$f(i,x)=\prod_{k} f(i, p_k^{\alpha_k})$。于是我们可以分别计算对于$n$的每个质因数的$f(i, p^{\alpha_k})$，然后把他们乘起来。此时时间复杂度为$O(k\sum{\alpha_i^2})$，此前为$O(k\prod{(\alpha_i+1)})$，对于$2^{20}\times3^{20}$来说，只需要$10^4\times800=8\times10^6$，是一个巨大的提升。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><pre><code class="cpp"></code></pre>
]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>概率期望</tag>
        <tag>动态规划</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>[SDOI2009] 虔诚的墓主人</title>
    <url>/2019/12/10/SDOI09Grave/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>一个$N \times M (N, M \leq 10^9)$的地图上有$W (W \leq 10^5)$棵树。对于图上没有树的点，如果在这个点上下左右都至少有$k (1 \leq k \leq 10)$个点，那么它会贡献${L\choose{k}} *  {R\choose{k}} * {U\choose{k}}* {D\choose{k}}$点虔诚度，问这个地图上所有虔诚度之和模$2147483648$（有毒）的值。</p>
<a id="more"></a>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题意很清晰，但是$N,M$的规模过于庞大，普通的模拟肯定不行了。但是我们注意到$W$的值并没有很大，所以实际上能贡献虔诚度的点只有$O(W^2)$个。但是这么多点一个个统计仍然太多了，所以很自然的我们想到了用扫描线法。</p>
<p>扫描线的统计仍然不是很直观，所以我们需要画一个图，假设我们现在的地图是这样的：<br><img src="/uploads/sdoi09grave1.png" alt="初始地图"><br>那么显然中间那个点是一个可以统计的点，如果我们记某个点$p$上方的树的数量为$U(p)$，下方为$D(p)$，左右分别为$L(p), R(p)$。那么这个点的虔诚度为${L(p)\choose{k}} *  {R(p)\choose{k}} * {U(p)\choose{k}}* {D(p)\choose{k}} = 1$。如果我们再加两个点，然后把目光集中在那根竖线上：<br><img src="/uploads/sdoi09grave3.png" alt="初始地图"><br>我们可以发现可以贡献虔诚度的点会在竖线的线段与其左右两边的横线的交点上。除此之外，我们知道在这条竖线（不包括两端）上的点$U(p)$和$D(p)$的值是完全相等的。如果我们回到那个公式，统计所有点的贡献：<br>$$<br>\begin{align}<br>S &amp; = \sum_{p} {L(p)\choose{k}} *  {R(p)\choose{k}} * {U(p)\choose{k}}* {D(p)\choose{k}}\\<br>&amp; = {U(p)\choose{k}} * {D(p)\choose{k}} * \bigg(\sum_{p} {L(p)\choose{k}} *  {R(p)\choose{k}}\bigg)<br>\end{align}<br>$$<br>根据求和公式的分配率可以推出来。这个公式意味着我们可以先得出一段竖线的${U(p)\choose{k}} * {D(p)\choose{k}}$值，然后乘以这个竖线区域所包含的所有横线的${L(p)\choose{k}} *  {R(p)\choose{k}}$就是这个区域所有的虔诚度贡献。竖线上的$U(p)$和$D(p)$可以通过从上到下以及预处理的方式求出来，现在问题在于怎么求出竖线上的横线贡献的$L(p), R(p)$：<br>$$<br>\sum_{i = l}^{r} {L(p[i])\choose{k}} *  {R(p[i])\choose{k}}<br>$$<br>可以看出这其实是一个区间查询问题，对于横线来说$L(p), R(p)$也可以通过从左到右的方式算出来，但是问题是每个横线区域与竖线的位置是密切相关的，随着向右边移动而变化：<br><img src="/uploads/sdoi09grave4.png" alt="扫描线"><br>这个时候扫描线的优势就出来了，我们可以把所有树的位置按照$x$坐标排序，如果$x$坐标相同则按照$y$坐标排序。然后我们从左到右，从上到下扫描，先统计个数，再更新横线的$L(p), R(p)$，最后把${L(p[i])\choose{k}} *  {R(p[i])\choose{k}}$放进区间查询的数据结构里面。因为这个虔诚度是可以加起来的所以区间查询用树状数组就足够了。<br><img src="/uploads/sdoi09grave5.gif" alt="动态演示"></p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(W\log{W})$，分别在排序和树状数组查询上。</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cntX[MAXN * <span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cntY[MAXN * <span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> curY[MAXN * <span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">FenwickTree tree;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> tot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tot);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 组合数打表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= min(i, <span class="number">10</span>); j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            C[i][j] = (C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> x, y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        points[i].x = x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        points[i].y = y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        discrete.add(x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        discrete.add(y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    discrete.discretize();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sort(points, points + tot);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cnt++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i == tot || points[i].x != points[i + <span class="number">1</span>].x) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> xx = discrete.get(points[i].x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 横坐标为xx的点共有多少个</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            cntX[xx] = cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cnt = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        points[i].x = discrete.get(points[i].x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        points[i].y = discrete.get(points[i].y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 纵坐标为y的点共有多少个</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        cntY[points[i].y]++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll ans = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> curX = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 当前y坐标左边有多少个点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        curX++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i &amp;&amp; points[i].x != points[i - <span class="number">1</span>].x) curX = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i != tot &amp;&amp; points[i].x == points[i + <span class="number">1</span>].x) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> l = points[i].y, r = points[i + <span class="number">1</span>].y - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (l &lt; r) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ll U = choose(curX, k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ll D = choose(cntX[points[i].x] - curX, k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ll sum = ((tree.getSum(r) - tree.getSum(l)) % MOD + MOD) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ans = (ans + (sum * U % MOD) * D % MOD) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        curY[points[i].y]++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll now = choose(curY[points[i].y], k) *</span></pre></td></tr><tr><td class="code"><pre><span class="line">                 choose(cntY[points[i].y] - curY[points[i].y], k) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll pre =</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ((tree.getSum(points[i].y) - tree.getSum(points[i].y - <span class="number">1</span>)) % MOD +</span></pre></td></tr><tr><td class="code"><pre><span class="line">             MOD) %</span></pre></td></tr><tr><td class="code"><pre><span class="line">            MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 注意只计算当前的总和，而不是之前的所有和</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        tree.increase(points[i].y, (now - pre + MOD) % MOD);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>扫描线</tag>
        <tag>组合数学</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>二分法杂谈</title>
    <url>/2019/12/09/binary-search/</url>
    <content><![CDATA[<p>学算法一年了，做了很多题，但是对于二分法这块一直不是很明白。 有时候遇到二分答案的问题经常要调好长时间才能写对，有些时候就是看别人二分是怎么写的就照抄，但是并不清楚为什么这么写是对的。今天总结了一下二分法的几种情况以及它们的思路。</p>
<a id="more"></a>

<h2 id="二分的写法"><a href="#二分的写法" class="headerlink" title="二分的写法"></a>二分的写法</h2><p>网上的二分法普遍有两种写法，一种是左闭右开<code>[l, r)</code>的写法，一种是左闭右闭<code>[l, r]</code>的写法。左闭右开写法的优点是上下界比较宽松，不会出现死循环，而且最终答案$l,r$都可以用。但是缺点就是对于将要介绍的四种情况，转移时的$\pm 1$的位置变换很令人头疼。所以这里我将要使用的是后一种方式，但是左闭右闭一定要注意转移的写法<code>l = mid + 1</code>和<code>r = mid - 1</code>，此时$\pm 1$都是固定的，但是最优解可能不在区间内，所以需要一个外层变量<code>ans</code>来确保得到的是最优解。这种写法的优点是非常好想。</p>
<h2 id="二分法四种情况"><a href="#二分法四种情况" class="headerlink" title="二分法四种情况"></a>二分法四种情况</h2><p>需要二分答案的时候，要先确保数据具有单调性。也就是说给定一个集合$S$，里面有一个需要寻找的答案，那么有：如果$S_i$满足条件，那么所有$S_j(j\geq i)$（或者$j\leq i$），都满足条件，并且如果$S_i$不满足条件，则所有$S_j(j&lt;i)$（或者$j&gt;i$）都不满足条件，那么这个数据就具有单调性。</p>
<p>在单调的数据下，我们需要找一个满足条件的答案就可以用二分法。我们都学过二分搜索查找一个数，但是有时候我们不是查找一个数，而是找一个满足条件的最小/最大值呢？如果满足条件值并不存在呢？我们把所有情况分成四种以便区分。假设数据是一个非降序列，那么他们分别是：不小于条件最小位置，严格大于等于条件最小位置，不大于条件的最大位置，严格小于条件的最大位置。</p>
<h3 id="不小于条件最小位置"><a href="#不小于条件最小位置" class="headerlink" title="不小于条件最小位置"></a>不小于条件最小位置</h3><p>假如给定一个非降序列：$S={1,1,4,4,5,6,7,8}$，假如我们想知道$S_i \geq 3$的最小位置，在此处显然是位置$3$，而不是位置$4$。在这种情况下，我们二分法找到$S_i$满足$S_i \geq 3$以后仍然要往更小的范围去寻找，这样才能保证是最小位置，那么在二分写法里面，就是将$r$的值缩小，那么最后一个满足条件的$mid$就是答案。由此可得一个写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans = n + <span class="number">1</span>; <span class="comment">// 如果目标不存在就返回一个不存在的位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= k) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        	ans = min(ans, mid);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            r = mid - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            l = mid + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="严格大于条件最小位置"><a href="#严格大于条件最小位置" class="headerlink" title="严格大于条件最小位置"></a>严格大于条件最小位置</h3><p>我们换一个非降序列：$S={1,1,3,4,5,6,7,8}$，假如我们想知道$S_i &gt; 3$的最小位置，那么我们可以看出应该是位置$4$，那么我们只需要把<code>if (arr[mid] &gt;= k)</code>改成<code>if (arr[mid] &gt; k)</code>就行了。</p>
<h3 id="不大于条件的最大位置"><a href="#不大于条件的最大位置" class="headerlink" title="不大于条件的最大位置"></a>不大于条件的最大位置</h3><p>假设这个序列是$S={1,1,3,3,3,6,7,8}$，然后我们要找一个$S_i \leq 3$的最大位置，那么我们可以看出应该是位置$5$。在此条件下，如果我们找到一个$S_i \leq 3$我们仍然需要往后找以确保能找到最大位置。那么在二分写法里面就是将$l$增大，那么我们只需要在此时找到最大的那个$mid$就是答案，写法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="comment">// 如果目标不存在就返回一个不存在的位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (arr[mid] &lt;= k) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        	ans = max(ans, mid);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            l = mid + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            r = mid - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="严格小于条件最大位置"><a href="#严格小于条件最大位置" class="headerlink" title="严格小于条件最大位置"></a>严格小于条件最大位置</h3><p>我们只需要把<code>if (arr[mid] &lt; k)</code>改成<code>if (arr[mid] &lt;= k)</code>就行了。</p>
<h3 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h3><p>对于序列并非升序的情况，我们可以将它转化为升序思考。绝大部分二分的题都可以归结为这四种情况，像最大的最小值就是满足条件的最大位置，最小的最大值就是满足条件的最小位置。只要想清楚自己想要二分出来的答案是什么样的就可以轻松A掉题了。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>二分法</category>
      </categories>
      <tags>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>[ICPC NAQ2018] Problem L: Longest Life</title>
    <url>/2019/12/04/NAQ18L/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>正常情况下每分钟你的生命就会流失一分钟（废话），但是现在科技这么发达你有（$N \leq 10^5$）次改变生命流失速度的机会，这些机会会出现在$N$个不同的时间点上。但是如果你改变了生命流失速率，那么你就会瞬间流失 $C$ 分钟的生命。如果你能够自由选择是否接受这些机会，问你最晚的死亡时间是什么时候。</p>
<a id="more"></a>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>如果用动态规划的方式去求解，那么可以很容易得到一个DP方程，如果我们设 $f(i) =$ 以第$i$个药片作为最后使用的药片的最晚死亡时间。那么转移方程就应该是：<br>$$f(i) = \max \{g(i, k)\} \ (0 \leq k &lt; i)$$</p>
<p>$g(i, k)$就表示之前使用了第$k$个药片，换成第$i$个药片以后所能存活的最长时间。如果我们把整个过程看做一个线性函数斜率不断改变的过程，那么$y$坐标就是不做改变应该存活的时间，而$x$轴就代表实际存活的时间。于是有图</p>
<p><img src="/uploads/naq18L1.png" alt="药剂效果"></p>
<p>我们要求的就是两个直线触及天花板的那个点的横坐标。</p>
<p>假设一开始死亡时间为$T$，药片出现时间为$t[i]$，改变的斜率为$k[i]$，那么有</p>
<p>$$g(i, k) = t[i] +  \frac{T-\text{使用i时的高度}}{k[i]}$$</p>
<p>合并到DP方程展开后就是：<br>$$<br>f(i)= \max \bigg( t[i]+\frac{T-(k[j]t[j]+T-k[j]f(j)+k[j](t[i]-t[j]) + C)}{k[i]} \bigg)<br>$$<br>化简一下<br>$$<br>f(i)= \max \bigg( t[i]-\frac{C+k[j](t[i]-f(j))}{k[i]} \bigg)<br>$$<br>其中$1 \leq k&lt;i$，如果看不懂的话手动推一下就好了。</p>
<p>但是观察一下数据范围，$10^5$ 显然对于这个$O(N^2)$ 的DP来说太大了，但是我们观察到$t[i]$是单调上升的，而且对于进来的不同$k[i]$，有一部分斜率比之前最小值要大的显然不能构成最优解，也就是说，这里面$j$的选择是可以优化的。那么如果想让程序不超时，我们需要一个$O(1)$的最优解选择方法，那么就要想到斜率DP。</p>
<p>我们继续优化这个式子，假设现在有两个药片$s, j$且$s &lt; j &lt; i$。那么假设$j$是比$s$更优的选择，那么一定满足：<br>$$t[i]&gt; \frac{k[s]f(s)-k[j]f(j)}{k[s]-k[j]}$$<br>当这个条件满足的时候，我们知道选择第$j$个药片比第$s$个药片要优。<br>如果我们定义$slope(s, j) = $上面这个式子，也就是相当于点$s$到点$j$的斜率，那我们需要判断满足这个条件的点具有的特征。假设对于三个点$s &lt; j &lt; i$并且$slope(s, j) &gt; slope(j, i)$，那么我们可以判断点$j$一定不会形成最优解。<br>剩下的就是用单调队列维护下凸包的操作了，但是要注意不要把$k[i]$不单调的点也算进去，具体见代码。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(N)$，因为每个元素只会进队列一次，出列一次。</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里我用了long double来防止精度不够</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> LD;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pill</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LD ks;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Pill() &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Pill(ll t, ll x, ll y) : t(t), ks(y / (LD)x) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Pill&amp; b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> t &lt; b.t; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Pill&gt; pills;</span></pre></td></tr><tr><td class="code"><pre><span class="line">LD dp[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟了一个队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> QQ[MAXN * <span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 斜率计算</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">LD <span class="title">slope</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> j)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> (pills[j].ks * dp[j] - pills[s].ks * dp[s]) /</span></pre></td></tr><tr><td class="code"><pre><span class="line">           (pills[j].ks - pills[s].ks);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;n, &amp;m, &amp;k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll t, x, y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;t, &amp;x, &amp;y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pills.emplace_back(t, x, y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pills.emplace_back(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sort(pills.begin(), pills.end());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dp[<span class="number">0</span>] = n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    QQ[<span class="number">1</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LD minn = <span class="number">1e30</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (pills[i].ks &gt;= minn) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; slope(QQ[l], QQ[l + <span class="number">1</span>]) &lt;= pills[i].t) ++l;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> opt = QQ[l];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        LD ki = pills[i].ks;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        LD kj = pills[opt].ks;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 根据公式从dp[j]计算dp[i]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        LD newx = (LD)pills[i].t - (k + kj * (pills[i].t - dp[opt])) / ki;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dp[i] = max(dp[i], newx);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; slope(QQ[r - <span class="number">1</span>], QQ[r]) &gt;= slope(QQ[r], i)) r--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        QQ[++r] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        minn = min(minn, pills[i].ks);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LD ans = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ans = max(ans, dp[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.7Lf"</span>, ans);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>斜率DP</tag>
      </tags>
  </entry>
  <entry>
    <title>[洛谷P3067] 平衡的奶牛群</title>
    <url>/2019/12/04/LuoguP3067/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你$n(n\leq20)$个数，从中任意选出一些数，记为集合$S$，使得存在一种$s \in S$满足$sum(s) == sum(\bar{s})$。求这样的选数方案有多少种。</p>
<a id="more"></a>

<p>介绍一种解这道题的新思路：利用$bitset$。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>先从暴力算法开始，我们只需要枚举所有集合以及他们的子集，如果发现子集以及其补集的和相等，那么这个集合就是一种方案。</p>
<p>更具体的说，假设$P$是原集合，$S$是$P$的所有子集。如果对于所有$s \in S$ 的子集有 $sum(s) == sum(\bar{s})$，那么$S$就贡献一个答案。</p>
<p>于是我们可以写出如下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s1 = i; s1; s1 = (s1 - <span class="number">1</span>) &amp; i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (sum[s1] == sum[i ^ s1]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ans++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>子集求和是$O(n2^n)$但是枚举子集的子集是$O(3^n)$的，显然会TLE的死死的。</p>
<p>于是我们会想到折半枚举，假设我们能枚举前一半和后一半的所有子集，那么应该怎么确定哪些子集是符合条件的呢？</p>
<p>假设对于一个集合$S_1$我们有一个子集$s_1$和补集$\bar{s_1}$，同时我们有另一个集合$S_2$和子集$s_2$和$\bar{s_2}$，如果这个集合能合并，那么我们需要有</p>
<ul>
<li>$S_1 \cap S_2 = \emptyset$</li>
<li>$sum(s_1) + sum(s_2) == sum(\bar{s_1}) + sum(\bar{s_2})$</li>
</ul>
<p>第一个条件用折半枚举可以保证。对于第二个来说，假设我们有$sum(s_1)-sum(\bar{s_1})=d$，那么如果$sum(\bar{s_2})-sum(s_2)=d$，那么就满足了第二个条件。</p>
<p>于是我们可以枚举左边的所有可能，然后记录有多少个集合具有差值$d$。然后在枚举右边的时候，对于每个右边子集，找到它的子集总共能匹配多少个左边子集。为了表述清晰，设$S_l$为左边集合的子集，$S_r$为右边集合的子集。对于每个右边集合的子集$s_r \subset S_r$，以及它的子集$ss_r \subset s_r$，我们要求：<br>$$<br>    \sum_{s_r}|\bigcap_{ss_r\in s_r}{s_l\text{使得}ss_r\text{可以与左边合并}}|<br>$$</p>
<p>所以我们要求差值为$d$集合的并集，但是集合个数有$2^{\frac{n}{2}}$个，无法用状态压缩($int$和long long)表示。于是我们就想到了使用$bitset$，$2^{\frac{n}{2}}$在这道题中仅有$1024$，$bitset$实现中每个集合所占空间仅有$\frac{1024}{8} = 128$字节。</p>
<p>我们再来计算一下总共可能会有多少种差值，不好计算但是可以估算出是小于$3^{10}=6\times10^4$的，也就是最坏也只是$sum$数组的内存级别。</p>
<p>于是我们只要维护一个<code>map&lt;int,bitset&lt;1024&gt;&gt;</code>就可以了。</p>
<p>以下是这种解法对应的代码：</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>折半枚举的复杂度是$3^{n/2}$，另一半查询的复杂度是因为有map所以是$\log$级别。<br>加上预处理以后的时间复杂度<br>$$<br>O(n2^n+3^{\frac{n}{2}}\log{3^{\frac{n}{2}}})<br>$$</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">25</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, k;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum[(<span class="number">1</span> &lt;&lt; <span class="number">20</span>) + <span class="number">5</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">bitset</span>&lt;1024&gt;&gt; mpp;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 求出所有子集的和</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> ((i &gt;&gt; j) &amp; <span class="number">1</span>) sum[i] += arr[j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 枚举左边</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> mid = n / <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; mid); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s1 = i;; s1 = (s1 - <span class="number">1</span>) &amp; i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            mpp[sum[s1 ^ i] - sum[s1]].<span class="built_in">set</span>(i, <span class="literal">true</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!s1) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 枚举右边</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; (n - mid)); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">bitset</span>&lt;1024&gt; sss(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 这里我刻意保留了子集为空的情况</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s1 = i;; s1 = (s1 - <span class="number">1</span>) &amp; i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> diff = sum[s1 &lt;&lt; mid] - sum[(s1 ^ i) &lt;&lt; mid];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            sss |= mpp[diff];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!s1) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 对答案的贡献就是这个集合的大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        ans += sss.count();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 要减去左边右边都是空集的情况</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans - <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>中途相遇/折半枚举</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>[CF1238E] Keyboard Purchase</title>
    <url>/2019/12/04/CF1238E/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你一个文本串$S(len(S) \leq 10^5)$，由前$m(m\leq20)$个小写字母组成。要你求一种键盘的排列，使得打出这个文本串的消耗最小。这个消耗$cost$的计算方式为相邻字符的键盘距离之和，也就是$\sum_{i=2}^{n} |pos_{s_i-1}-pos_{s_i}|$。只需要输出这个最小消耗就行。</p>
<a id="more"></a>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>打比赛时候以为是一道贪心题，结果怎么做都不对，后来看到$(m\leq20)$就在想状压DP，但是完全不会做这种对于排列的DP。因为无法确定这个字符应该插入到什么位置，也就没法计算$cost$。<br>赛后看题解才知道原来DP还可以有预先计算$cost$这种操作，那么公式也就很好想了。<br>我们先预处理文本串$S$中相邻字符对出现的次数。设$f(S)$为当前使用了集合为$S$的字符进行排列，所能产生的最小$cost$。当我们加入一个新字符的时候，我们除了计算当前最小值，还要把还没有使用过的字符与使用过的字符所产生的$cost$也加进去，由此可得：<br>$$<br>\begin{aligned}<br>f(S) &amp;=\min\{f(S-\{j\})\} &amp; [j\in S]\\<br>f(S) &amp;= f(S) + cost(i, j) &amp; [i \in S,j\in \overline{S}]\\<br>\end{aligned}<br>$$<br>那么整体最小值就是$f(S的全集)$了。<br>顺便吐槽一下状压$O(m^22^m)$都$4\times10^8$了，结果$CF$神机居然$0.5$秒就跑出来了也是可以，我还以为会超时。。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(m^22^m+S)$</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录点对的数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt[<span class="number">25</span>][<span class="number">25</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">ll dp[(<span class="number">1</span> &lt;&lt; <span class="number">20</span>) + <span class="number">5</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, text);</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">char</span> a = text[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">char</span> b = text[i + <span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (a == b) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cnt[a - <span class="string">'a'</span>][b - <span class="string">'a'</span>]++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cnt[b - <span class="string">'a'</span>][a - <span class="string">'a'</span>]++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dp));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; (<span class="number">1</span> &lt;&lt; k); s++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> ((s &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                dp[s] = min(dp[s], dp[s ^ (<span class="number">1</span> &lt;&lt; i)]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!((s &gt;&gt; i) &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// 未访问的点的贡献</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> ((~s &gt;&gt; j) &amp; <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    dp[s] += cnt[i][j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[(<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩DP</tag>
      </tags>
  </entry>
  <entry>
    <title>[ICPC NAQ2019] Problem L: Traveling Merchant</title>
    <url>/2019/12/03/NAQ19L/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>一条线上有$N(N\leq10^5)$个城市，标号从$1$到$N$。每个城市物价根据星期的不同而有所不同，具体来说，每个城市有原价$v_i$，变动$d_i$，周一到周日的变化量为$\{+0, +v_i, +2v_i, +3v_i, +2v_i, +v_i, +0\}$。现在有$Q(\leq 10^5)$个询问，每个询问商人会从$l$号城市往$r$号城市旅行，$l$有可能大于$r$，此时要逆行。求次旅行最大的差价$(price_j-price_i)$其中$(j &gt; i)$是多少。</p>
<a id="more"></a>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>$10^5$数据量+$10^5$查询，那么很明显直接模拟是不行的，但是这题题意看起来用线段树也不太好维护（有可能是我太菜了不会）。于是有没有又好维护跑的又快的数据结构呢？于是祭出分块大法。</p>
<p>我们可以把所有城市按照标号分成$\sqrt{N}$块，每一块内存储3个信息:<br>$$\{整块内最大价格，整块内最小价格，整块内最大差价\}$$<br>这样查询的时候可以两端直接模拟，中间根据这三个信息更新最大差价，每次查询复杂度不会超过$O(\sqrt{N})$。</p>
<p>由于有星期这个设定，所以我们要维护$7$重块，每个块信息代表当从第$k$天开始从左到右（反向旅行同理）旅行的信息。这个问题便迎刃而解了，看官方题解好像是用的线段树，但是感觉应该很难写，我用分块一发就过了，线段树不知道要调多久。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(N+Q\sqrt{N})$</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100005</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, k;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Info</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> v, d, b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 块信息，最大值，最小值，最大差值，左右延伸范围</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> maxx;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> minn;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> maxprofit;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> lft;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> rgt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> raise[<span class="number">7</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> CASE;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 正向旅行块</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Block blocks[<span class="number">7</span>][<span class="number">505</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 反向旅行块</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Block blocks2[<span class="number">7</span>][<span class="number">505</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> B;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Info cities[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 正向计算</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> d, <span class="keyword">int</span>&amp; maxx, <span class="keyword">int</span>&amp; minn, <span class="keyword">int</span>&amp; maxprofit)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt;= r; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> day = (j - l + d) % <span class="number">7</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> price = cities[j].v + raise[day] * cities[j].d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        minn = min(minn, price);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        maxprofit = max(maxprofit, price - minn);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        maxx = max(maxx, price);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 反向计算</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal2</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> l, <span class="keyword">int</span> d, <span class="keyword">int</span>&amp; maxx, <span class="keyword">int</span>&amp; minn, <span class="keyword">int</span>&amp; maxprofit)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = r; j &gt;= l; j--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> day = (r - j + d) % <span class="number">7</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> price = cities[j].v + raise[day] * cities[j].d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        minn = min(minn, price);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        maxprofit = max(maxprofit, price - minn);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        maxx = max(maxx, price);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 同样也是一正一反</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query2</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> l)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> d = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> maxx = <span class="number">0</span>, minn = <span class="number">1e9</span>, prof = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> rs = max(l, blocks2[<span class="number">0</span>][cities[r].b].lft);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cal2(r, rs, d, maxx, minn, prof);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    d = (d + r - rs + <span class="number">1</span>) % <span class="number">7</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cities[r].b - <span class="number">1</span>; i &gt;= cities[l].b + <span class="number">1</span>; i--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        prof = max(prof, blocks2[d][i].maxx - minn);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        minn = min(minn, blocks2[d][i].minn);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        prof = max(prof, blocks2[d][i].maxprofit);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        maxx = max(maxx, blocks2[d][i].maxx);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        d = (d + blocks2[d][i].rgt - blocks2[d][i].lft + <span class="number">1</span>) % <span class="number">7</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (cities[l].b != cities[r].b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> ls = min(r, blocks2[<span class="number">0</span>][cities[l].b].rgt);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cal2(ls, l, d, maxx, minn, prof);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> prof;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> d = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ls = min(r, blocks[<span class="number">0</span>][cities[l].b].rgt);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> maxx = <span class="number">0</span>, minn = <span class="number">1e9</span>, prof = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cal(l, ls, d, maxx, minn, prof);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    d = (d + ls - l + <span class="number">1</span>) % <span class="number">7</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cities[l].b + <span class="number">1</span>; i &lt;= cities[r].b - <span class="number">1</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        prof = max(prof, blocks[d][i].maxx - minn);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        minn = min(minn, blocks[d][i].minn);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        prof = max(prof, blocks[d][i].maxprofit);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        maxx = max(maxx, blocks[d][i].maxx);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        d = (d + blocks[d][i].rgt - blocks[d][i].lft + <span class="number">1</span>) % <span class="number">7</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (cities[l].b != cities[r].b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> rs = max(l, blocks[<span class="number">0</span>][cities[r].b].lft);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cal(rs, r, d, maxx, minn, prof);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> prof;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    B = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n) + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> cnt = (n + B - <span class="number">1</span>) / B;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;cities[i].v, &amp;cities[i].d);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cities[i].b = (i - <span class="number">1</span>) / B + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">7</span>; d++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 确定块的左右边界</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            blocks[d][i].lft = B * (i - <span class="number">1</span>) + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            blocks[d][i].rgt = B * i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            blocks2[d][i].lft = B * (i - <span class="number">1</span>) + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            blocks2[d][i].rgt = B * i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> l = blocks[d][i].lft, r = blocks[d][i].rgt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Block&amp; cur = blocks[d][i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cur.maxx = <span class="number">0</span>, cur.minn = <span class="number">1e9</span>, cur.maxprofit = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Block&amp; cur2 = blocks2[d][i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cur2.maxx = <span class="number">0</span>, cur2.minn = <span class="number">1e9</span>, cur2.maxprofit = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cal(l, r, d, cur.maxx, cur.minn, cur.maxprofit);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cal2(r, l, d, cur2.maxx, cur2.minn, cur2.maxprofit);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (m--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> l, r;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (l &lt;= r) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(l, r));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query2(l, r));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>[ICPC NAQ2019] Problem E: NVMLS</title>
    <url>/2019/12/03/NVMLS/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你$N$个大写字母组成的单词和一串大写非元音字母所组成的字符串（$L\leq 3\times 10^5$）。已知字符串$L$是由给出单词的非元音字母组成的，求将这个字符串还原回正常单词以后，元音字母数量最多的一个原串。数据保证$\sum_{i=0}^{n} len(s_i) \leq 10^5$。</p>
<a id="more"></a>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于模式串$L$和匹配串的数据很大，所以普通匹配肯定是不行的。可以考虑$AC$自动机或者Hash，但是我$AC$自动机写挂了所以改用$Hash$了。同时匹配结束以后我们还需要用$DP$来获取元音字母最多的还原串。<br>假设我们已经获取每个位置上的匹配串，假设位置$i$的所有匹配串为$m_i$，每个匹配串的元音字母数量为$v[j]$，匹配长度为$l[j]$。那么可得$DP$公式：<br>$$<br>f(i)=\max_{j \in m_i}\{f(i-l[j]+v[j])+v[j]\}<br>$$<br>那么$f(L)$就是最多的元音数量。因为题目要输出这个还原串，所以我们在$DP$的时候还要记录每一个状态是由哪一个匹配串转移而来的，这样就可以从后往前构造原串。</p>
<p>如果我们考虑这个$DP$的时间复杂度，会发现它很有可能是$O(NL)$的，显然会超时。但是仔细一想我们会发现，对于每一个位置，长度为$x$的匹配串有且仅能有一个，那么我们其实只需要枚举长度就好了。对于一个总长度不超过$N$的单词集合，长度的种类最多只有$O(\sqrt{N})$种。因为$\sum_{i=1}^k{i}=N$可得$\frac{k(k+1)}{2}=N$，解得$k=\sqrt{2N+0.25}-0.5$。<br>如果每个位置只有最多$O(\sqrt{N})$个匹配串，那么总复杂度$O(L\sqrt{N})$就可以接受了。<br>对于维护$\sqrt{N}$个长度的$Hash$我们也可以动态的$O(L)$时间来实现，只要在超出长度的时候$hash - pow[len]$就可以了。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(L\sqrt{N})$</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">300005</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, k;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> CASE;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 单词字符串信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node2</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span> str;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ull hash1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll hash2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 长度离散化结构</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Discretization</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; xp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator xend;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> xend - xp.begin(); &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; xp.push_back(val); &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">discretize</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sort(xp.begin(), xp.end());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        xend = unique(xp.begin(), xp.end());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> lower_bound(xp.begin(), xend, val) - xp.begin() + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get2</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123; <span class="keyword">return</span> xp[num - <span class="number">1</span>]; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Discretization dis;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> text[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串hash匹配表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hashList[MAXN * <span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 原单词信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Node2 strList[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 每个位置匹配的串</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; matches[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> opt[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">removeVowel</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">int</span>&amp; cnt)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cnt = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : str) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (c == <span class="string">'A'</span> || c == <span class="string">'E'</span> || c == <span class="string">'I'</span> || c == <span class="string">'O'</span> || c == <span class="string">'U'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cnt++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            res.push_back(c);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 我用了双hash，一个自然溢出一个模数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ull powh[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line">ll powh2[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hasher</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ull hashB1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll hashB2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> cnt1;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        powh[<span class="number">0</span>] = powh2[<span class="number">0</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAXN; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            powh[i] = powh[i - <span class="number">1</span>] * <span class="number">277L</span>L;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            powh2[i] = powh2[i - <span class="number">1</span>] * <span class="number">1999L</span>L % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Hasher() &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB1 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB2 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removel</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> len)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB1 -= powh[len] * (ull)c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB2 -= (powh2[len] * c) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB2 %= MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (hashB2 &lt; <span class="number">0</span>) hashB2 += MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertr</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB1 *= powh[<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB1 += c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB2 = (hashB2 * powh2[<span class="number">1</span>]) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB2 += c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB2 %= MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Hasher hasher;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Hasher dynHash[<span class="number">505</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; sss;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    hasher.init();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> tot = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, text);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(text)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">string</span> rem = removeVowel(s, cnt);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!sss.count(rem) || cnt &gt; sss[rem]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            sss[rem] = cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            hasher.clear();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> a : rem) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                hasher.insertr(a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            strList[tot] = &#123;s, hasher.hashB1, hasher.hashB2, cnt&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            hashList[hasher.hashB1 % (MAXN * <span class="number">2</span>)].push_back(tot);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            tot++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            dis.add(rem.size());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dis.discretize();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, text + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    n = <span class="built_in">strlen</span>(text + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dp[i] = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> sz = dis.size();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = sz; j &gt;= <span class="number">1</span>; j--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 动态维护每个长度的hash</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            dynHash[j].insertr(text[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> len = dis.get2(j);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (i &gt; len) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                dynHash[j].removel(text[i - len], len);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (i &gt;= len) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> loc = dynHash[j].hashB1 % (MAXN * <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// hash匹配</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> v : hashList[loc]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    Node2&amp; nd = strList[v];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (nd.hash2 == dynHash[j].hashB2) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        matches[i].push_back(v);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : matches[i]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Node2&amp; nd = strList[a];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> p = i - nd.str.size() + nd.cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (dp[p] &gt;= <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> nx = dp[p] + nd.cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (dp[i] &lt; nx) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    dp[i] = nx;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    opt[i] = a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> k = n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 构造原串</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        res.push_back(opt[k]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> d = strList[opt[k]].str.size() - strList[opt[k]].cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        k -= d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = res.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, strList[res[i]].str.c_str());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>字符串哈希</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>你好，世界</title>
    <url>/2019/12/03/hello-world/</url>
    <content><![CDATA[<p>欢迎，这里是DXTsT，又名小裙子。<br>这个博客用来记录一些算法，黑科技等等，反正就是杂七杂八的东西。<br>在别的地方写过的文章，都会陆续搬到这里来，包括fs49.org</p>
<h3 id="注意，本博客的所有题解代码都不保证能够直接提交AC，只是截取了部分核心代码，能不能AC还是要靠自己！"><a href="#注意，本博客的所有题解代码都不保证能够直接提交AC，只是截取了部分核心代码，能不能AC还是要靠自己！" class="headerlink" title="注意，本博客的所有题解代码都不保证能够直接提交AC，只是截取了部分核心代码，能不能AC还是要靠自己！"></a>注意，本博客的所有题解代码都不保证能够直接提交AC，只是截取了部分核心代码，能不能AC还是要靠自己！</h3><a id="more"></a>]]></content>
  </entry>
</search>
