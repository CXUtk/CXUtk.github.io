<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[UVA11982] Fantasy Cricket</title>
    <url>/2020/12/18/UVA11982/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你一张名次表，以及每个队伍的名次变化，求上一轮队伍名次有多少种可能性。</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这题想要想清楚细节并不容易，首先，如果当前排名$i$的队伍名次上涨，就意味着上一轮这个队伍的排名一定在$[i-1. n]$这个范围内，如果下降就是$[1, i - 1]$这个范围内。如果名次不变那么只有一种选择就是上一轮也排在第$i$名。</p>
<p>假设<strong>这一轮</strong>队伍的排名情况是数组$A$，<strong>上一轮</strong>队伍的排名情况是数组$B$，那么可以通过刚才推出的关系在$A,B$之间连边，具体来说假设$A_i$是上涨的，那么连接$A_i$和$B_j(j \in [i-1, n])$这几条边。最后这两个集合所组成的图一定构成一个二分图，则答案是二分图完美匹配的个数。</p>
<p>二分图完美匹配计数本身是个NP-hard问题，但是对于这道题来说，我们可以利用一些特殊性质来有效的求解。</p>
<p>我们不妨从第i名开始，分析$A,B$之间的匹配都有哪些可能。</p>
<p>如果$A_i$是上涨的，那么与$A_i$匹配的某个$B_j$一定是在$i$后面，而此时的$B_i$可以选择：</p>
<ol>
<li>匹配之前的某个$A_i$，并且这个$A_i$一定是上涨状态</li>
<li>或者不匹配任何一个之前的$A_i$，把自己留给后面的某个$A_j$去匹配</li>
</ol>
<p>如果$A_i$是下降的，那么$A_i$<strong>必须</strong>匹配某个在$i$之前的$B_j$，此时$B_i$的选择和上涨情况是一样的。<br>如果$A_i$不变，那么$A_i$只能匹配$B_i$，$B_i$也是一样。</p>
<p>我们可以发现，对于$A$集合中的元素，不考虑相等我们的决策只有：要么必须与之前某个$B_j$匹配，要么必须留到后面。<br>对于$B$中的元素，可以选择往前面某个上涨$A_i$匹配，或者留到后面。</p>
<p>我们不妨设状态为$f(i, j, k)$，代表考虑到两个集合的前$i$个元素的时候，$B$中在$i$以及$i$以前有$j$个未匹配的元素，且$A$中$i$以及$i$以前有$k$个未匹配的上涨元素。</p>
<p>那么我们分别让$A_i,B_i$做出决策：</p>
<ol>
<li>当$A_i$是上涨状态时，$A_i$留到后面匹配，因为$k$包含自己，所以不变，$B_i$在此时可以选择匹配之前某个$A_j$，这个时候$B_i$因为匹配了值，所以$j$减少1，$k$也减少1，$B_i$可以匹配之前的$k-1$个上涨元素（不包含$A_i$）中的任意一个，有$k-1$种情况。如果$B_i$也不匹配，那么$j,k$的值都不变，这种情况只有一种。</li>
<li>当$A_i$是下降状态时，$A_i$<strong>必须</strong>匹配之前的任意一个$B_j$，$B_j$被匹配了，所以$j$减少1，总共有$j-1$种可能性。而$B_i$情况和之前相同，如果选择匹配之前某个$A_j$，那么仍然有$k-1$种情况，匹配后$j,k$再减少1，而如果不匹配$j,k$不变，有一种情况。</li>
<li>当$A_i$不变时，$A_i$与$B_i$匹配，$j,k$都减少1，只有一种情况。</li>
</ol>
<p>但是这样考虑我们需要记录$i,j,k$三个状态，在题目数据范围下显然不可行，但是刚才的思考$i,j,k$都是已经算好的，如果我们考虑从之前的$i-1,j,k$中转移呢？假设这时候的$j, k$都是从$i-1$中得出的，那么在每种操作结束后的$j,k$状态会变化：</p>
<ol>
<li>当$A_i$是上涨状态时，因为多了个上涨的$A_i$，所以状态变成$i, j+1, k+1$，后续操作会生成$i, j, k$或者$i, j+1, k+1$。</li>
<li>当$A_i$是下降状态时，只多了个$B_i$，所以状态变成$i, j+1, k$，后续操作会生成$i, j, k$或者$i, j-1, k-1$。</li>
<li>当$A_i$不变时，$A_i$与$B_i$匹配，所以状态是$i, j, k$。</li>
</ol>
<p>我们可以发现$j,k$的值<strong>在任何时候都相等</strong>，于是我们可以把它合并，最终状态为$f(i, j)$代表考虑两个集合前$i$个元素的匹配，此时$i$和$i$之前的$A,B$有$j$个上涨的$A$和没匹配的$B$。</p>
<p>转移只要常数时间就可以做到，至此这题就算解决了。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>$O(n^2)$</p>
<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increase</span><span class="params">(<span class="keyword">int</span>&amp; d, <span class="keyword">int</span> v)</span> </span>&#123; d = (d + v) % MOD; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, S + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">n = <span class="built_in">strlen</span>(S + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dp[i][j] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (S[i] == <span class="string">'E'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            increase(dp[i][j], dp[i - <span class="number">1</span>][j]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (S[i] == <span class="string">'U'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            increase(dp[i][j], (ll)dp[i - <span class="number">1</span>][j] * j % MOD);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (j) increase(dp[i][j], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            increase(dp[i][j], (ll)dp[i - <span class="number">1</span>][j + <span class="number">1</span>] * (j - <span class="number">1</span>) * (j - <span class="number">1</span>) % MOD);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            increase(dp[i][j], (ll)dp[i - <span class="number">1</span>][j] * j % MOD);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>UVA</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>计数</tag>
        <tag>思维</tag>
      </tags>
  </entry>
  <entry>
    <title>软光栅化渲染器【1】</title>
    <url>/2020/12/10/Graphics/Rasterizer-1/</url>
    <content><![CDATA[<p>最近准备趁这个寒假写一个软件光栅化渲染器，重新学习图形学渲染知识的同时，也要练习自己的软件开发能力。<br>就用这个博客记录一下自己学习的过程和一些重要的知识点吧。</p>
<a id="more"></a>

<h1 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h1><h2 id="投影矩阵"><a href="#投影矩阵" class="headerlink" title="投影矩阵"></a>投影矩阵</h2><p>投影矩阵的作用就是把三维空间的物体投影到另一个三维空间中，如果物体能够被显示在屏幕内，那么投影以后的物体会在目标三维空间的一个单位立方体内。此文以OpenGL的投影方式为例，目标物体会被投影到一个由$(-1,-1,-1)$和$(1,1,1)$为顶点的正方形内。</p>
<h3 id="正交投影矩阵的推导"><a href="#正交投影矩阵的推导" class="headerlink" title="正交投影矩阵的推导"></a>正交投影矩阵的推导</h3><p>正交投影（Orthographic Projection）矩阵物体的z坐标并不会影响最终在屏幕上的成像，除非越过远近平面。整个过程其实就是将某个点$p$，如果$x$坐标在$[l, r]$内，$y$坐标在$[b, t]$内且$z$坐标在$[n, f]$范围内的点投影到$([-1, 1], [-1, 1], [-1, 1])$这个坐标。比如说某个点$x$坐标为$\frac{l+r}{2}$，那么会被映射到$0$这个值。</p>
<p>我们不妨从每个分量来考虑，假设我们考虑$x$分量，那么也就是存在一个变换$\textbf{T}_x: \mathbb{R} \to \mathbb{R}$，进行变换后$x$分量处于正确的投影位置。那么有<br>$$<br>\begin{cases}<br>\textbf{T}_x(l) = -1 \\<br>\textbf{T}_x(r) = 1<br>\end{cases}<br>$$</p>
<img src="/images/Ortho.png" class="" width="600" title="正交投影x分量示意图">
<p>显然（？）$\textbf{T}_x$是个线性变换，也就是说：<br>$$<br>\begin{cases}<br>\textbf{T}_x(l) = al + b = -1 \\<br>\textbf{T}_x(r) = ar + b = 1<br>\end{cases}<br>$$<br>解得<br>$$<br>\begin{cases}<br>a = \dfrac{2}{r - l} \\<br>b = -\dfrac{l + r}{r-l}<br>\end{cases}<br>$$<br>因为有$a, b$两个参数，所以我们不妨将原变换拓展一下，使得输入可以是一个4维向量，也就是我们的位置向量，则$\textbf{T}_x: \mathbb{R}^4 \to \mathbb{R}^4$，假设有一个向量$\vec{x} = (x\ y\ z\ 1)^{T}$，那么$\textbf{T}_x$可以表示为：<br>$$<br>\begin{align}<br>\textbf{T}_x(\vec{x}) &amp;= \begin{bmatrix}<br>\dfrac{2}{r-l}&amp;0&amp;0&amp;-\dfrac{l + r}{r-l}\\<br>0&amp;1&amp;0&amp;0\\<br>0&amp;0&amp;1&amp;0\\<br>0&amp;0&amp;0&amp;1\\<br>\end{bmatrix}\begin{bmatrix}<br>x\\<br>y\\<br>z\\<br>1<br>\end{bmatrix}\\<br>&amp;=\begin{bmatrix}<br>\dfrac{2}{r-l}x - \dfrac{l + r}{r-l}\\<br>y\\<br>z\\<br>1<br>\end{bmatrix}<br>\end{align}<br>$$<br>此时$\textbf{T}_x$的作用就是仅仅进行x分量的映射，同理可得$y,z$分量的映射矩阵：<br>$$<br>\begin{align}<br>\textbf{T}_y &amp;= \begin{bmatrix}<br>1&amp;0&amp;0&amp;0\\<br>0&amp;\dfrac{2}{t-b}&amp;0&amp;-\dfrac{t+b}{t-b}\\<br>0&amp;0&amp;1&amp;0\\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}\\<br>\textbf{T}_z &amp;= \begin{bmatrix}<br>1&amp;0&amp;0&amp;0\\<br>0&amp;1&amp;0&amp;0\\<br>0&amp;0&amp;\dfrac{2}{f-n}&amp;-\dfrac{f+n}{f-n}\\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>\end{align}<br>$$<br>正交投影矩阵其实就是对每个分量都进行这么一个线性变换，那么我们定义<br>$\textbf{T}_o$为以上三个变换的组合：<br>$$<br>\textbf{T}_o = \textbf{T}_x\textbf{T}_y\textbf{T}_z<br>$$<br>注意到这三个变换都是独立的，所以组合起来就是<br>$$<br>\begin{equation}<br>\textbf{T}_o = \begin{bmatrix}<br>\dfrac{2}{r-l}&amp;0&amp;0&amp;-\dfrac{l + r}{r-l}\\<br>0&amp;\dfrac{2}{t-b}&amp;0&amp;-\dfrac{t+b}{t-b}\\<br>0&amp;0&amp;\dfrac{2}{f-n}&amp;-\dfrac{f+n}{f-n}\\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>\end{equation}<br>$$<br>然后这就是完整的正交投影矩阵了。</p>
<h3 id="透视投影矩阵的推导"><a href="#透视投影矩阵的推导" class="headerlink" title="透视投影矩阵的推导"></a>透视投影矩阵的推导</h3><p>透视投影（Perspective Projection）矩阵和正交投影的区别在于此时物体的$z$坐标会影响其在投影空间下$x,y$坐标的值，就像人眼所看到的那样，如果离视点得近，那么物体会变大，而离得远会变小。</p>
<img src="/images/Persp.png" class="" title="100% 透视投影示意图">
<p>如图所示，这时候的映射就不像之前那么简单了，假设我们还是有一个$\vec{x}$，原先正交投影变换$\textbf{T}_o(x)$会映射$x$到一个值$\alpha$，但是在透视中，映射的值会跟$z$有关系，变成$\alpha f(z)$。</p>
<img src="/images/PerspLR.png" class="" title="100% 透视投影示意图">
<img src="/images/PerspSim.png" class="" title="100% 透视投影示意图">
<p>跟之前那幅图对比，此时不再是对$l,r$这个范围进行映射，而是对$l’, r’$进行映射。根据蓝绿两个相似三角形的原理，我们可以推出$x$和$x’$的关系：<br>$$<br>\frac{x}{x’} = \frac{z}{n} \implies x’ = n\frac{x}{z}<br>$$<br>也就是说，我们要使用这个关系还原出$x’$，再让它在$l,r$范围内进行之前的映射。但是这个关系并不是很线性，因为我们要除以$z$这样一个输入里面已经有的值。要把这个关系变成线性映射，我们可以在输入的时候就把所有坐标都除以$z$再乘以$n$，即<br>$$<br>\begin{bmatrix}<br>\frac{nx}{z}\\<br>\frac{ny}{z}\\<br>\frac{nz}{z}\\<br>1<br>\end{bmatrix}<br>$$<br>如果我们能这么做，那么接下来的变换就会变成这样（以$x$坐标为例）：<br>$$<br>\begin{align}<br>\textbf{T}_x(\vec{x}) &amp;= \begin{bmatrix}<br>\dfrac{2}{r-l}&amp;0&amp;0&amp;-\dfrac{l + r}{r-l}\\<br>0&amp;1&amp;0&amp;0\\<br>0&amp;0&amp;1&amp;0\\<br>0&amp;0&amp;0&amp;1\\<br>\end{bmatrix}\begin{bmatrix}<br>\frac{nx}{z}\\<br>\frac{ny}{z}\\<br>\frac{nz}{z}\\<br>1<br>\end{bmatrix}\\<br>&amp;=\begin{bmatrix}<br>\dfrac{2}{r-l}x’ - \dfrac{l+r}{r-l}\\<br>\frac{ny}{z}\\<br>\frac{nz}{z}\\<br>1<br>\end{bmatrix}<br>\end{align}<br>$$<br>我们可以利用$w$坐标做到这件事，因为向量最终结果要除以$w$，所以如果我们设$w$为$\dfrac{z}{n}$，就可以达到效果<br>$$<br>\begin{bmatrix}<br>x\\<br>y\\<br>z\\<br>\frac{z}{n}<br>\end{bmatrix} = \begin{bmatrix}<br>\frac{nx}{z}\\<br>\frac{ny}{z}\\<br>n\\<br>1<br>\end{bmatrix}<br>$$<br>把$w$变成$\dfrac{z}{n}$是一个线性变换，因为$n$是个常数，所以<br>$$<br>\begin{bmatrix}<br>1&amp;0&amp;0&amp;0\\<br>0&amp;1&amp;0&amp;0\\<br>0&amp;0&amp;1&amp;0\\<br>0&amp;0&amp;\frac{1}{n}&amp;0<br>\end{bmatrix}\begin{bmatrix}<br>x\\<br>y\\<br>z\\<br>1<br>\end{bmatrix}<br>=\begin{bmatrix}<br>x\\<br>y\\<br>z\\<br>\frac{z}{n}<br>\end{bmatrix}<br>$$<br>那么我们下一步就可以直接使用正交投影了，但是要注意此时变换后的向量原来的$z$已经不是$z$了，变成了$n$，所以我们无法推出此时矩阵第三行的变换内容，但是整个透视投影的过程可以被描述为：<br>$$<br>\textbf{P}_p(\vec{x}) =<br>\begin{bmatrix}<br>\dfrac{2}{r-l}&amp;0&amp;0&amp;-\dfrac{l + r}{r-l}\\<br>0&amp;\dfrac{2}{t-b}&amp;0&amp;-\dfrac{t+b}{t-b}\\<br>?&amp;?&amp;?&amp;?\\<br>0&amp;0&amp;0&amp;1<br>\end{bmatrix}<br>\begin{bmatrix}<br>1&amp;0&amp;0&amp;0\\<br>0&amp;1&amp;0&amp;0\\<br>0&amp;0&amp;1&amp;0\\<br>0&amp;0&amp;\frac{1}{n}&amp;0<br>\end{bmatrix}<br>\begin{bmatrix}<br>x\\<br>y\\<br>z\\<br>1<br>\end{bmatrix}<br>$$<br>左边两个矩阵乘起来就是：<br>$$<br>\begin{bmatrix}<br>\dfrac{2}{r-l}&amp;0&amp;-\dfrac{l + r}{n(r-l)}&amp;0\\<br>0&amp;\dfrac{2}{t-b}&amp;-\dfrac{t+b}{n(t-b)}&amp;0\\<br>?&amp;?&amp;?&amp;?\\<br>0&amp;0&amp;\dfrac{1}{n}&amp;0<br>\end{bmatrix}<br>$$<br>我们把问号设为未知数$A,B,C,D$，为了求出他们，我们可以列方程，四个未知数使用空间中任意4个已知点即可求出来。比如点$(l,b,n)$应该被映射为$(-1,-1,-1, 1)$, $(r,t,f)$应该被映射为$(1,1,1,1)$，诸如此类，具体解法这里不再叙述，最终解得：<br>$$<br>\textbf{T}_p = \begin{bmatrix}<br>\dfrac{2n}{r-l}&amp;0&amp;-\dfrac{l + r}{r-l}&amp;0\\<br>0&amp;\dfrac{2n}{t-b}&amp;-\dfrac{t+b}{t-b}&amp;0\\<br>0&amp;0&amp;\dfrac{f+n}{f-n}&amp;-\dfrac{2fn}{f-n}\\<br>0&amp;0&amp;1&amp;0<br>\end{bmatrix}<br>$$<br>注意，这个矩阵是除以$w$以后的。</p>
<h2 id="三角形光栅化"><a href="#三角形光栅化" class="headerlink" title="三角形光栅化"></a>三角形光栅化</h2><h3 id="重心坐标"><a href="#重心坐标" class="headerlink" title="重心坐标"></a>重心坐标</h3><p>重心坐标插值是光栅化中一个至关重要的概念，任何一个三角形内的像素点的可变参数都是由构成这个三角形的三个顶点数据的重心坐标插值得到的。具体来说，有一个点$\textbf{P}$，假设三角形三个顶点分别为$\textbf{A}, \textbf{B}, \textbf{C}$，那么我们可以得到<br>$$<br>\textbf{P} = \alpha\textbf{A} + \beta\textbf{B} + \gamma\textbf{C}<br>$$<br>其中$(\alpha, \beta, \gamma)$构成了点$\textbf{P}$对三角形$\textbf{ABC}$的重心坐标。如果点$\textbf{P}$在三角形内部，则$\alpha, \beta, \gamma$必须满足：</p>
<ul>
<li>$0 \leq \alpha, \beta, \gamma \leq 1$</li>
<li>$\alpha + \beta + \gamma = 1$</li>
</ul>
<p>那么给定一个$\textbf{P}$，如何求出重心坐标呢？我们可以看这幅图</p>
<img src="/images/barycentric.png" class="" width="400" title="中心坐标示意图">

<p>此时$\textbf{P}$可以视作为向量$\vec{AC}$和$\vec{AB}$的线性组合，即<br>$$<br>\begin{align}<br>\textbf{P} &amp;= \textbf{A} + u\vec{AB} + v\vec{AC}\\<br>\textbf{P} &amp;= \textbf{A} + u(\textbf{B}-\textbf{A}) + v(\textbf{C}-\textbf{A})\\<br>\textbf{P} &amp;= \textbf{A}(1 - u - v) + u\textbf{B} + v\textbf{C}<br>\end{align}<br>$$<br>于是我们可以令重心坐标$(\alpha, \beta, \gamma)$为$(1-u-v, u, v)$. 这样做可以保证$\alpha + \beta + \gamma = 1$，并且$u,v$定义完全符合$\beta, \gamma$. 那么现在问题在于如何求出$u,v$。我们可以把这个过程规约到求解线性方程组:<br>$$<br>    \begin{align}<br>    \textbf{P} &amp;= \textbf{A} + u(\textbf{B}-\textbf{A}) + v(\textbf{C}-\textbf{A}) \\<br>    \textbf{P} - \textbf{A} &amp;= u(\textbf{B}-\textbf{A}) + v(\textbf{C}-\textbf{A})<br>    \end{align}<br>$$<br>转换一下，令$\vec{E}$为原$\vec{AB}$向量，$\vec{F}$为$\vec{AC}$，那么有：<br>$$<br>    u\vec{E} + v\vec{F} = \textbf{P}-\textbf{A}<br>$$<br>转换为矩阵形式就是求解<br>$$<br>    \begin{bmatrix}<br>    \vec{E}  &amp; \vec{F} \<br>    \end{bmatrix}<br>    \vec{x} = \textbf{P}-\textbf{A}<br>$$<br>解法就很简单啦，只要求出左边这个矩阵的逆，然后乘以$\textbf{P}-\textbf{A}$，解出来$\vec{x}$，那么$\vec{x}$向量的每个分量就是$u,v$了。<br>接下来我们根据得到的$u,v$判断这个重心坐标是否合法即可，然后$(1-u-v, u, v)$就是我们想要的重心坐标。<br>这个方法适用于二维情形，尤其是光栅化阶段，只要预先求出左边$EF$矩阵的逆，然后对于每个进来的像素点乘以$\textbf{P}-\textbf{A}$就可以很轻松的计算重心坐标了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 三角形三个顶点储存在 v 数组里</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 直接得到EF矩阵的逆</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">glm::<span class="function">mat2 <span class="title">interpTransform</span><span class="params">(v[<span class="number">1</span>] - v[<span class="number">0</span>], v[<span class="number">2</span>] - v[<span class="number">0</span>])</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">interpTransform = glm::inverse(interpTransform);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// ......</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 对于每个像素点计算重心坐标</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">glm::vec2 x = interpTransform * (pos - v[<span class="number">0</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">glm::vec3 bary = glm::vec3(<span class="number">1</span> - x.x - x.y, x.x, x.y);</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>图形学</category>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>Codeforces Round #688 (Div. 2) 选解</title>
    <url>/2020/12/04/CF/CF688/</url>
    <content><![CDATA[<h1 id="Problem-D"><a href="#Problem-D" class="headerlink" title="Problem D"></a>Problem D</h1><h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p>有$n$个关卡，每个关卡到达的时候可以有一个存档点，每次通过关卡失败可以回到最近存档点。每个关卡有$\dfrac{1}{2}$几率通过，你要构造一个期望$k$步能到终点的关卡设计方式。</p>
<a id="more"></a>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这题本质上是一个马尔可夫链模型，可以画出一个马尔可夫链转移模型。假设终点是$n$，我们要求的是到达第$n+1$关的期望步数。设$E[i]$为到达$i$点的期望步数，则有<br>$$<br>\begin{equation}<br>\label{T1}<br>E[n + 1] = E[n+1|n] + E[n|n+1] + \dots + E[2|1]<br>\end{equation}<br>$$<br>假设所有点都有存档点，我们从$E[2|1]$开始计算，有<br>$$<br>E[2|1] = \frac{E[2|1]}{2} + 1<br>$$<br>因为我们先要花一步闯关，然后有一半的几率回到第一关开始重新过，解得<br>$$<br>E[2|1] = 2<br>$$<br>而<br>$$<br>E[3|2] = \frac{E[3|2]}{2} + 1<br>$$<br>同理可得<br>$$<br>E[n+1|n] = \frac{E[n+1|n]}{2} + 1<br>$$<br>所以如果都有存档点，那么每个相邻转移期望都是$2$，通过式子$\ref{T1}$所有的期望加起来就是$2n$。</p>
<p>那如果存档点不在上一关，而是在之前得某一关呢？此时需要回到存档点的关卡，令最近存档点为$\alpha$，我们有如下期望公式<br>$$<br>\begin{align}<br>E[i|i-1] &amp;= \frac{E[i|\alpha]}{2} + 1\\<br>&amp;=\frac{\sum_{j=\alpha+1}^{i} E[j|j-1]}{2} + 1<br>\end{align}<br>$$<br>把熟悉的身影从求和符号中提取出来<br>$$<br>\begin{align}<br>E[i|i-1]&amp;=\frac{E[i|i-1]}{2} + \frac{\sum_{j=\alpha+1}^{i-1} E[j|j-1]}{2} + 1\\<br>\frac{E[i|i-1]}{2} &amp;= \frac{\sum_{j=\alpha+1}^{i-1} E[j|j-1]}{2} + 1 \\<br>E[i|i-1]&amp;=\sum_{j=\alpha+1}^{i-1} E[j|j-1]+2<br>\end{align}<br>$$<br>类比成以下的递推公式<br>$$<br>T(i) = \sum_{j=1}^{i-1} T(j) + 2<br>$$<br>代换，令$S(i) = \sum_{j=1}^{i} T(j)$，则有<br>$$<br>\begin{align}<br>S(i) - S(i - 1) &amp;= S(i - 1) + 2 \\<br>S(i) &amp;= 2S(i - 1) + 2<br>\end{align}<br>$$<br>再次令$G(i) = \frac{S(i)}{2^i}$<br>$$<br>G(i) = G(i-1)+2^{-i+1}<br>$$<br>则有<br>$$<br>G(i) = \sum_{j=1}^{i} 2^{-j+1} = 2 - (\frac{1}{2})^{i-1}<br>$$<br>此时<br>$$<br>S(i) = 2^{i+1} - 2<br>$$<br>则<br>$$<br>T(i) = S(i - 1) + 2 = 2^{i}<br>$$<br>好，花了一大堆功夫推出了个$T(i) = 2^{i}$，那么这个$i$其实就是期望式中的$i-\alpha$。所以<br>$$<br>E[i|i-1]=2^{i-\alpha}<br>$$<br>所以整体来讲，每一段连续的0区间，假设长度为$k=i-\alpha$，则贡献是<br>$$<br>E[i|i-1] + \dots + E[\alpha + 1 | \alpha] = \sum_{i = 1}^{k} 2^k = 2^{k+1} - 2<br>$$<br>注意，这里的$i$是有存档点的。我们假设有序列$1000$，那么全部通过的期望步数就是$2^{4+1} - 2$。我们可以构造这样的$10\dots$序列，每构造一次$n$的值就会减少$2^{k+1} - 2$，观察到无论怎么取0和1，我们的期望步数都只会增加个偶数，所以奇数一定构造不出来，至于为什么一定能把一个偶数构造出$2^{k+1} - 2$的分解，emmm</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(\log^2{n})$</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">60</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll c = (<span class="number">1L</span>L &lt;&lt; (i + <span class="number">1</span>)) - <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (n &gt;= c) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            n -= c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            v.push_back(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++) v.push_back(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, v.size());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> a : v) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<hr>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>比赛选解</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 99 选解</title>
    <url>/2020/12/02/CF/CFEDU99/</url>
    <content><![CDATA[<h1 id="Problem-A"><a href="#Problem-A" class="headerlink" title="Problem A"></a>Problem A</h1><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>可以把$g(x)=\dfrac{x}{f(f(x))}$看成$x$除以去掉前后缀的0以后的数，由于$x$没有前导0，所以只会去掉后缀0。<br>考虑每个1到$n$的$x$，一般情况下$f(f(x))=x$，当$x$是$10^k$的倍数时，得到$f(f(x))=\dfrac{x}{10^k}$，所以$g(x)=10^k$。于是我们只需要知道1到$n$有多少个$10^k$，$k$互不相同，也就是$n$有多少位数。</p>
<a id="more"></a>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(1)$</p>
<hr>

<h1 id="Problem-B"><a href="#Problem-B" class="headerlink" title="Problem B"></a>Problem B</h1><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>假设我们一直使用操作1，会形成数列<br>$$1+2+3+\dots+x$$<br>如果此时我们进行操作2，有<br>$$1+2+3+\dots+x-1$$<br>然后下一步继续操作1，可以得到<br>$$1+2+3+\dots+x-1+(x+2) = 1+2+3+\dots+x+(x+1)$$<br>如果我们继续加到$n$，相比于一直用操作1，我们得到的是<br>$$1+2+3+\dots+x+(x+1)+(x+3)+\dots+n$$<br>我们会发现最终结果少了一个$x+2$。<br>由此得出结论，假设我们在第$x$次操作使用操作2，那么最终我们的结果会减少$x+1$。同时，假设我们一直使用操作1，最终结果超出$n$的时候，这个差值一定小于$n$，假设这个差值是$d$，那么我们可以在第$d-1$次操作使用操作2。有一个例外是如果刚好超出1，此时我们没有办法减少这个值，必须最后多使用一次操作2。</p>
<h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(n)$</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> x = read&lt;<span class="keyword">int</span>&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sum += i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cnt++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (sum &gt; x) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> d = sum - x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (d == <span class="number">1</span>) cnt++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>比赛选解</tag>
      </tags>
  </entry>
  <entry>
    <title>[UVA1642] 魔法GCD</title>
    <url>/2020/12/01/UVA1642/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你一个正整数数列，求<br>$$<br>\max_{1 \leq l\leq r \leq n} \left\{ \gcd(a_l,…,a_r) \times (r- l + 1) \right\}<br>$$</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>一开始想着枚举$gcd$然后计算左右边界，还猜了个错的结论，真正做法应该是枚举右边界，然后计算从右边界开始所有不同$gcd$值所在的左边界。</p>
<p>因为每个$gcd$的值我只关心最左边的那一个，所以我只需要知道有哪些不同的$gcd$即可，由于$gcd$必是右端点的一个约数，所以每次需要考察的左端点个数是在$\ln n$到$\sqrt{n}$这个级别的。</p>
<p>从左到右枚举右端点的时候，我们可以动态维护所有的$gcd$值，以及其最左端点。当加入一个新的右端点$x$时，所有之前的这些$gcd$值需要跟$x$取$gcd$，然后重新判断是否是最左的端点，假设有$k$个不同$gcd$值，那么这个操作可以$O(k\log n)$完成。也就是总体时间复杂度$O(n\log^2{n})$。但是实际情况远好于这个复杂度，为什么呢？假设$x=10$，且之前$gcd$为$1,2,5,10$。你会发现如果想要把他们都构造出来是做不到的，由于2和5的存在，10一定不会和他们同时出现，所以实际长度远小于约数个数。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>趋近于$O(n\log{n})$</p>
<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll A[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll gcd;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Node(ll g, <span class="keyword">int</span> i) : gcd(g), i(i) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> T = read&lt;<span class="keyword">int</span>&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (T--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) A[i] = read&lt;ll&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; G;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        G.push_back(&#123;A[<span class="number">1</span>], <span class="number">1</span>&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll ans = A[<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            G.push_back(&#123;A[i], i&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Node&gt; newG;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : G) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (A[i] % v.gcd) v.gcd = <span class="built_in">std</span>::__gcd(v.gcd, A[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (newG.empty() || newG.back().gcd &lt; v.gcd) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    newG.push_back(v);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    ans = <span class="built_in">std</span>::max(ans, v.gcd * (i - v.i + <span class="number">1</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            G = newG;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>UVA</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>[UVA1393] Highways</title>
    <url>/2020/11/29/UVA1393/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>求一张$n\times m (n,m\leq 300)$的网格完全图里面，有多少条不同的直线是能够穿过至少两个顶点的，并且这个直线不能是水平或者竖直的。</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>先说一个比较直观的解法，既然要求直线，那么我们可以从枚举斜率和偏移入手。首先我们可以枚举任意两点，如果他们能组成符合条件的直线，假设这两个点之间的向量为$(x,y)$，那么$x,y$必定互质。否则我们就会重复记录这条直线，同时$x,y$不能有0。</p>
<p>于是我们可以枚举所有符合条件的$(x,y)$向量，这和Trees in a Wood那道题要求的东西很像。对于所有这样的向量，我们算出它的起点可能在网格图中的哪些坐标上。首先加上向量以后不能出界，否则这样的点对不会在原图中存在，其次不能叠加，否则会重复记录。不能出界很好计算，假设这个向量是$(x,y)$，那么在$(n-x,m-y)$之内的点都不会出界。不能叠加稍微有点难度，通过画图可以看出，对于在$(n-x, m-y)$这个范围内的点，只有左下角的第一层是可以取的，之后的点一定会存在一个斜率和偏移都相同的直线，也就总共有$(n-x-x)\times (m-y-y)$个点是不能取的，把这些点减去即可。</p>
<p>还有一个关键点是对于每一个这样的直线，一定存在一个与其中心对称的直线也符合要求，所以我们可以只用考虑射向右上角的直线，然后乘以2就是最终答案。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>$O(nm\log{n})$那个log是来自判定互质。</p>
<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">300</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">300</span>; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (<span class="built_in">std</span>::__gcd(i, j) != <span class="number">1</span>) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            G[i][j] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a, b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!a) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (!G[i][j]) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                n = a - i, m = b - j;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> c = <span class="built_in">std</span>::max(<span class="number">0</span>, a - i * <span class="number">2</span>) * <span class="built_in">std</span>::max(<span class="number">0</span>, b - j * <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ans += n * m - c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ans * <span class="number">2</span> &lt;&lt; <span class="string">'\n'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>UVA</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>[UVA10214] Trees in a Wood</title>
    <url>/2020/11/29/UVA10214/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>求在一个$a\times b$的网格中，从原点看过去，能看到多少个没被遮挡的点。这题主要就是求这个数目*4+4的值除以总数。</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>画图可发现，如果某个点$(x,y)$从原点看过去会被遮挡，那么一定有一个点$(a,b)$存在某个正整数$k$使得$x=ka, y=kb$。也就是说，$(x,y)$是某个点放大后得到的，此时$\gcd(x,y)\neq 1$。所以问题转化为求<br>$$<br>\sum_{i=1}^{a}\sum_{j=1}^{b} [\gcd(i, j) = 1]<br>$$<br>通过数论函数定义把$[\gcd(i, j) = 1]$进行变换<br>$$<br>\begin{align}<br>&amp;\sum_{i=1}^{a}\sum_{j=1}^{b} \sum_{d|gcd(i,j)} \mu(d) \\<br>=&amp;\sum_{d=1}^{\min(a,b)} \mu(d) \sum_{i=1}^{\lfloor \frac{a}{d} \rfloor}\sum_{j=1}^{\lfloor \frac{b}{d}  \rfloor} \\<br>=&amp;\sum_{d=1}^{\min(a,b)} \mu(d) \lfloor \frac{a}{d} \rfloor \lfloor \frac{b}{d}  \rfloor<br>\end{align}<br>$$<br>我们可以预处理莫比乌斯$\mu$函数，此时求解每个询问只要计算从1到$\min(a,b)$以上公式的和即可，复杂度$O(\min(a,b))$。当然也可以优化到$O(\sqrt{\min(a,b)})$，使用整除分块即可。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>$O(\sqrt{\min(a,b)})$</p>
<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pref[<span class="number">1</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 预处理莫比乌斯函数以及其前缀和</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAXV - <span class="number">5</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!nop[i]) primes[++tot] = i, mu[i] = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * primes[j] &lt;= MAXV - <span class="number">5</span>; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            nop[i * primes[j]] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!(i % primes[j])) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                mu[i * primes[j]] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            mu[i * primes[j]] = -mu[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pref[i] = pref[i - <span class="number">1</span>] + mu[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> a, b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!a) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> top = <span class="built_in">std</span>::min(a, b);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll K = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 计算公式，这里我用了整除分块</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= top; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> up = <span class="built_in">std</span>::min(&#123;top, a / (a / i), b / (b / i)&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            K += (ll)(pref[up] - pref[i - <span class="number">1</span>]) * (a / i) * (b / i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            i = up;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        K = K * <span class="number">4</span> + <span class="number">4</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll tot = (ll)(a * <span class="number">2</span> + <span class="number">1</span>) * (b * <span class="number">2</span> + <span class="number">1</span>) - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.8f\n"</span>, K / (<span class="keyword">double</span>)(tot));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>UVA</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>[UVA11440] Help Tomisu</title>
    <url>/2020/11/28/UVA11440/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你两个数$N,M (\leq 10^7, N-M\leq 10^5)$，求从2到$N!$有多少个数所有素因子都大于$M$。</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先从所有素因子都大于$M$入手，一个显而易见的结论就是它一定由大于$M$的素数组成，也就是说每个素因子都与$M$以及小于$M$的数互质，那么也一定和$M!$互质。<br>那么有引理：一个非1的数与$M!$互质，当且仅当它的最小素因子大于$M$。<br>证明：反向显然，因为$M!$没有任何一个数能成为一个大于$M$的质数的约数。正向则说明这个数并不包含任何1到$M$的约数，那么这个数只能是一个质数，并且一定大于$M$，否则一定被$M!$包含。<br>于是我们只要求出$N!$内与$M!$互质的数，然后减去1就是答案了。</p>
<p>由于$M!$是$N!$的约数，所以这里面一定有$\dfrac{N!}{M!}$个$M!$，对于每个$M!$，$\varphi(M!)$就是$M!$内与$M!$互质的数的个数，所以我们$N!$内与$M!$互质的数的个数为<br>$$<br>\varphi(M!)\dfrac{N!}{M!}<br>$$<br>预处理$\varphi(i!)$和阶乘即可$O(\log m)$回答每个询问。这题的模数是$10^8+7$，有点坑。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>预处理$O(10^7)$，回答$O(\log m)$。</p>
<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> fact[MAXV], phif[MAXV];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[MAXV / <span class="number">10</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> nop[MAXV];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fastExp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> p, <span class="keyword">int</span> mod)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> t = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (p) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>) t = (ll)t * a % mod;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        a = (ll)a * a % mod;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    fact[<span class="number">0</span>] = fact[<span class="number">1</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= MAXV - <span class="number">5</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        fact[i] = (ll)fact[i - <span class="number">1</span>] * i % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!nop[i]) primes[++tot] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= tot &amp;&amp; i * primes[j] &lt;= MAXV - <span class="number">5</span>; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            nop[i * primes[j]] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!(i % primes[j])) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    phif[<span class="number">1</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">1</span>; i &lt;= MAXV - <span class="number">5</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i == primes[j]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            phif[i] = (ll)phif[i - <span class="number">1</span>] * (i - <span class="number">1</span>) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            j++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            phif[i] = (ll)phif[i - <span class="number">1</span>] * i % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!(n + m)) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> mul = (ll)fact[n] * fastExp(fact[m], MOD - <span class="number">2</span>, MOD) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        mul = (mul + MOD) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> c = (ll)phif[m] * mul % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; (c + MOD - <span class="number">1</span>) % MOD &lt;&lt; <span class="string">'\n'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>UVA</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>[CSP-S 2020 T3] 函数调用</title>
    <url>/2020/11/27/CSP-S-2020-T3/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你一个DAG的函数调用关系，以及每个函数的作用（只有加法，乘法以及调用其他函数），求顺序调用$Q$个函数以后数列变成什么样子。</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>正向计算每个元素被贡献了多少很困难，这时候要用到加法和乘法顺序执行的性质。<br>乘法和加法可能交替执行，所以如果先进行了加法，把某个元素增加了$x$，那么之后的每一个乘法都会使$x$在最终贡献中乘上所有乘法操作的积。假设在加法之后执行了$n$个乘法，每个乘法给所有元素乘上了$q_i$，那么加法操作最终的贡献为<br>$$<br>x\prod_{i=1}^{n} q_i<br>$$<br>利用这个性质，我们可以倒序维护一个当前的乘积，如果遇到加法就把这个乘积作为贡献次数放在加法上。但是问题来了，由于有第三类操作的存在，我们需要先求出每一个节点的后续节点总共执行了多少次乘法操作。同时为了计算每个加法的贡献次数，我们需要使用像线段树一样标记下传的方式获得正确的贡献次数。</p>
<p>假设我们调用了函数$f_i$，此时倒序的乘积为$x$，那么如果$f_i$是个加法函数，就应该多执行$x$次，如果$f_i$拥有子节点，那么那么就把$x$作为标记下传到子节点上。要注意的是，$f_i$的子节点有可能有带乘法的节点，需要把这些贡献也乘到$x$。</p>
<p>一开始没有想到这个性质，所以强行正向求只得了50分，不应该求每一个元素被加了多少，而是求每个加法操作被乘积操作增强了多少次。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>统计每个节点的乘积$O(n)$，拓扑排序和标记下传用了$O(m + \sum C_i)$，总体时间复杂度$O(n+m+q+\sum C_i)$.</p>
<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Info</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> mul;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; add;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Function</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> x, y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; calls;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> vis[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line">Function func[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> A[MAXN], tag[MAXN], mul[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> indeg[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMul</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (vis[id]) <span class="keyword">return</span> mul[id];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Function&amp; f = func[id];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    vis[id] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (f.type == <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> mul[id] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f.type == <span class="number">2</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> mul[id] = f.x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll m = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> a : f.calls) m = m * getMul(a) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> mul[id] = m;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        A[i] = read&lt;<span class="keyword">int</span>&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;func[i].type);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (func[i].type == <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;func[i].x, &amp;func[i].y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (func[i].type == <span class="number">2</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;func[i].x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;c);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; c; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> v = read&lt;<span class="keyword">int</span>&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                func[i].calls.push_back(v);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                indeg[v]++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">std</span>::reverse(func[i].calls.begin(), func[i].calls.end());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vals;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> c = read&lt;<span class="keyword">int</span>&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        vals.push_back(c);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::reverse(vals.begin(), vals.end());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> curmul = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : vals) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        tag[c] += curmul;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        tag[c] %= MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        curmul = (ll)curmul * getMul(c) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        A[i] = (ll)A[i] * curmul % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 拓扑排序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (func[i].type == <span class="number">3</span> &amp;&amp; !indeg[i]) Q.push(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (!Q.empty()) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> v = Q.front();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Q.pop();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> mul1 = tag[v];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : func[v].calls) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            tag[a] += (ll)mul1 % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            tag[a] %= MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            mul1 = (ll)mul1 * getMul(a) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!(--indeg[a])) Q.push(a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (func[v].type == <span class="number">3</span>) tag[v] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (func[i].type == <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            A[func[i].x] += (ll)func[i].y * tag[i] % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            A[func[i].x] %= MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, A[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>NOIP</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title>[NC 21340] 网格游戏</title>
    <url>/2020/08/08/NC21340/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>有一个游戏平板上面有$N\times M$个格子，一开始每个格子都是关闭的，每个格子里面都有一个标记。<br>已知每种标记恰好出现两次，也就是一共有$K=\dfrac{NM}{2}$种标记<br>规定一次移动为依次(one by one不是同时)打开一对格子查看里面的标记，如果标记不一样，格子会自动关闭，但是你过目不忘。如果标记是一样的，格子从此就一直保持打开状态，当所有格子都打开时游戏结束。<br>请算出游戏结束的最少期望步数。</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先肯定是要推期望式子，考虑一下每次操作都有哪些状态发生改变。如果这次操作成功得到两个相同颜色的格子，那么我们就可以少考虑一种颜色。如果失败了，我们能得到两种颜色的位置。</p>
<p>于是我们可以设 $f(i,j)$ 为：我们已经匹配了$i$种颜色，此时有$j$种未匹配的颜色我们知道它的位置的期望步数。</p>
<p>在状态 $(i, j)$ 下，我们有 $R=\dfrac{NM}{2} - 2i - j$ 个格子可以去选择，在最优方案下，我们不应该选任何已经知道颜色的格子，这样才能将信息最大化。那么加下来的状态会随着你选择的格子而改变：</p>
<ol>
<li>如果第一次选择的格子刚好和某个已知颜色相同，那么第二次就直接选那个已知颜色，此时操作数+1，我们的状态转移到 $(i + 1, j - 1)$。那么选到某个已知格子的概率就应该是 $p = \dfrac{j}{R}$。</li>
<li>如果和已知颜色不同，那么可能是选中两个不同的未知颜色格子，此时新增两个未知格子，于是状态变成 $(i, j + 2)$。选中不同格子的概率是 $p_0 = \dfrac{R-j}{R}$，第二次再选一个不同格子的概率是 $p_1=\dfrac{R-j-2}{R-1}$，总体概率为 $p_0p_1$。</li>
<li>如果选的是两个相同未知颜色的格子，那么多匹配了一种颜色，状态变成 $(i+1, j)$。概率 $p_1=\dfrac{1}{R-1}$。</li>
<li>如果选的第一个格子和已知不同，但是第二个和已知相同，此时我们失败一次，但是马上我们就可以把第二个颜色匹配上，需要花两次操作，状态变成 $(i+1,j)$，多一个已知元素和少一个抵消。概率 $p_1=\dfrac{j}{R-1}$。</li>
</ol>
<p>于是我们就可以利用这几种情况得到递推公式，最终结果即为 $f(K,0)$。但是如果这样推会有一个问题，对于一个状态，转移出去的情况概率是确定的，但是转移到它的状态却无法保证概率是确定的，因为这个概率完全由转移到它的状态决定，而且可能有多种方案转移到它，所以非常难以计算。</p>
<p>于是我们可以倒着推，我们知道一个起始状态 $(0, 0)$。于是我们可以从 $(K,0)$ 回推到 $(0,0)$，因为每个状态转移的方式是固定的，所以我们的公式看起来像是这样：<br>$$<br>f(x) = \sum_y (f(y) + v_y) * p_y<br>$$<br>其中 $y$ 就是上述的操作集合，$p_y$是这个操作发生的概率。再注意一下边界条件我们就可以完成dp了。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>状态是$O(K^2)$的，转移是$O(1)$级别，所以总体$O(K^2)$。</p>
<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    N = n * m;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    M = n * m / <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dp[M][<span class="number">0</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = M - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = M - i; j &gt;= <span class="number">0</span>; j--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 可选的数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> rest = N - i * <span class="number">2</span> - j;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (j &gt;= <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// 刚好和已知颜色相同，那么就直接选那个已知颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">double</span> p1 = j / (<span class="keyword">double</span>)rest;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                dp[i][j] += (dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>) * p1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 和已知颜色不同，要么增加两个新的已知颜色，要么直接消掉，要么多一步消掉</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">double</span> p2 = (rest - j) / (<span class="keyword">double</span>)rest;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 情况1：选择两个未知不同颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (rest - j - <span class="number">1</span> &gt;= <span class="number">3</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">double</span> p3 = (rest - j - <span class="number">2</span>) / (<span class="keyword">double</span>)(rest - <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                dp[i][j] += (dp[i][j + <span class="number">2</span>] + <span class="number">1</span>) * p2 * p3;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 情况2：选择两个未知相同颜色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (rest - j &gt;= <span class="number">2</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">double</span> p3 = <span class="number">1</span> / (<span class="keyword">double</span>)(rest - <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                dp[i][j] += (dp[i + <span class="number">1</span>][j] + <span class="number">1</span>) * p2 * p3;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; rest - <span class="number">1</span> &gt;= j) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// 情况3：第二步选到已知颜色，于是我们失败一次然后直接消掉</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">double</span> p3 = j / (<span class="keyword">double</span>)(rest - <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                dp[i][j] += (dp[i + <span class="number">1</span>][j] + <span class="number">2</span>) * p2 * p3;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.10lf\n"</span>, dp[<span class="number">0</span>][<span class="number">0</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>概率期望</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>[NC 21337] 牛牛的回文串</title>
    <url>/2020/07/31/NC21337/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你一个字符串$S(|S|\leq 50)$，以及$m$个操作，这些操作可以分为：</p>
<ol>
<li>在任意位置增加一个字符$x$</li>
<li>删除一个字符$x$</li>
<li>将字符$x$改变成字符$y$</li>
</ol>
<p>每个操作都有一个代价$c_i$，求最少需要多少代价把$S$变成回文串。</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>有增删改操作乍一看无从下手，但是如果我们仔细想想回文串的性质还是能发现一些规律的。</p>
<p>对于字符串$S$来说，如果$|S| \leq 1$，那么$S$是回文串。同时有$S’ = xSx$，也就是两边加上相同的字符，那么$S’$也是回文串。那么反过来，如果知道$S[1], S[n]$相同，我们就可以把$S[1, n]$是不是回文串这个问题分解为$S[2, n-1]$是否是回文串。</p>
<p>这就提醒我们，可以用区间dp去求解这个问题。设$dp[i][j]$为将字符串$S$的$[i, j]$区间内的字符通过增删改变成回文串所需的最小代价，然后我们就可以利用大区间以来小区间结果的方式递推。</p>
<p>但是有个问题，增删改如何表示成状态的转移呢？以字符串$S = \text{aabc}$为例。<br>如果我们想让$S$变成回文串，先要保证$S$的左右端点相同，那么可以有以下几种方法：</p>
<ol>
<li>左边删去$a$，此时问题变成$S’=\text{abc}$变成回文串的最小代价，加上删除一个$a$的代价，即$dp[i+1, j] + del(a)$。</li>
<li>右边增加一个$a$，此时字符串变成 $\textbf{a}\text{abc}\textbf{a}$ ，那么问题被分解成了$S’=\text{abc}$变成回文串的最小代价，加上增加一个$a$的代价。此时我们相当于消去了左边的$a$，即$dp[i+1, j] + add(a)$。</li>
<li>我们把左边换成右边的字符，或者右边字符换成左边，即 $\text{aab}\textbf{a}$ 或 $\textbf{c}\text{abc}$，由于两端相等消掉，所以转移到$dp[i+1, j-1]$。</li>
<li>两端都换成一个其他字符，然后一起消掉，所以转移到$dp[i+1, j-1]$。</li>
</ol>
<p>其中方法1，2可以看成对一个字符的操作，所以我们只需要选增删字符$x$的最小代价。</p>
<p>但是这题还没完，因为题目给出了$m$个操作，所以不一定所有字符都可以变换，而且还有连环改变这种操作。所以为了求出每次字符变成另一个字符的最小代价，我们需要使用floyd最短路算法。同时，方法1，2还可以分解为：</p>
<ol>
<li>先增加再改变，$\text{aabc}\textbf{b} \implies {\text{aabc}\textbf{a}}$。</li>
<li>先改变再删除，$\textbf{x}\text{abc} \implies \text{abc}$。</li>
<li>增加连环改变，$\text{aabc}\textbf{b} \implies \text{aabc}\textbf{x} \implies \textbf{x}\text{abc}\textbf{x}$。</li>
</ol>
<p>尤其是最后一种，看了样例4才想到，算是比较难想的一种情况。总之，我们要保证每次增删改操作的代价都是最小的，然后进行dp代价才会最小。</p>
<p>还有一个要注意的地方是因为第三个分解方式的原因，如果使用的INF太大，会导致溢出，所以这里我把$\text{0x3f}$换成了$\text{0x1f}$。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>预处理需要花费$O(26^3)$的时间，dp需要$O(26n^2)$的时间，所以总时间复杂度大概是$O(26n^2)$</p>
<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ll G[MAXN][MAXN], c[MAXN], dp[MAXV][MAXV];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> text[MAXV], tmp[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line">ll add[MAXN], del[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">umin</span><span class="params">(ll&amp; x, ll v)</span> </span>&#123; x = min(x, v); &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Floyd最短路</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; k++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                G[i][j] = min(G[i][j], G[i][k] + G[k][j]);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 计算所有可能的分解方式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        c[i] = min(add[i], del[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (i != j) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// 分解1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                c[i] = min(c[i], add[j] + G[j][i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// 分解2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                c[i] = min(c[i], G[i][j] + del[j]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// 分解3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">26</span>; k++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    c[i] = min(c[i], G[i][k] + add[j] + G[j][k]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, text + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    n = <span class="built_in">strlen</span>(text + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) text[i] -= <span class="string">'a'</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(G, <span class="number">0x1f</span>, <span class="keyword">sizeof</span>(G));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(add, <span class="number">0x1f</span>, <span class="keyword">sizeof</span>(add));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(del, <span class="number">0x1f</span>, <span class="keyword">sizeof</span>(del));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x1f</span>, <span class="keyword">sizeof</span>(dp));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) G[i][i] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) dp[i][i] = dp[i][i - <span class="number">1</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, tmp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">char</span> c1, c2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (tmp[<span class="number">0</span>] == <span class="string">'a'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">scanf</span>(<span class="string">" %c %d"</span>, &amp;c1, &amp;x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            add[c1 - <span class="string">'a'</span>] = x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tmp[<span class="number">0</span>] == <span class="string">'e'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">scanf</span>(<span class="string">" %c %d"</span>, &amp;c1, &amp;x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            del[c1 - <span class="string">'a'</span>] = x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">scanf</span>(<span class="string">" %c %c %d"</span>, &amp;c1, &amp;c2, &amp;x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            G[c1 - <span class="string">'a'</span>][c2 - <span class="string">'a'</span>] = x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cal();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">2</span>; l &lt;= n; l++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - l + <span class="number">1</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> j = i + l - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (text[i] == text[j]) umin(dp[i][j], dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 方法1，2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            umin(dp[i][j], dp[i + <span class="number">1</span>][j] + c[text[i]]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            umin(dp[i][j], dp[i][j - <span class="number">1</span>] + c[text[j]]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 方法3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            umin(dp[i][j], dp[i + <span class="number">1</span>][j - <span class="number">1</span>] +</span></pre></td></tr><tr><td class="code"><pre><span class="line">                               min(G[text[i]][text[j]], G[text[j]][text[i]]));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 方法4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; <span class="number">26</span>; r++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                umin(dp[i][j],</span></pre></td></tr><tr><td class="code"><pre><span class="line">                     dp[i + <span class="number">1</span>][j - <span class="number">1</span>] + G[text[i]][r] + G[text[j]][r]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (dp[<span class="number">1</span>][n] == dp[<span class="number">0</span>][<span class="number">1</span>]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"-1\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[<span class="number">1</span>][n]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>牛客网</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>[CF1139D] Steps to One</title>
    <url>/2020/07/26/CF1139D/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>一开始有一个空集合$S$，你每次可以往里放入一个从$1$到$m$的数，如果里面的数的$\gcd$为1则停下。求期望多少次后会停下。</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先我们知道期望公式为$\sum_{x} xp(x)$，但是很可惜，由于步数可以到无穷，所以貌似不太好从这里入手。<br>于是我们考虑使用期望递推式，令$f(i)$为当前集合内元素$gcd$为$i$，期望需要多少步后停下。很显然$f(1)=0$，那么对于$m=2, f(2)$来说，总共$m$种选择，要么下一步加入的这个数是个偶数，那么又回到$f(2)$，要么是个奇数我们直接跳到$f(1)$的结果，所以$f(2) = 1 + \frac{f(2)}{2} + \frac{f(1)}{2}$。也就是说，对于$f(i)$，有：<br>$$<br>f(i) = 1 + \sum_{j=1}^{m} \frac{f(\gcd(i, j))}{m}<br>$$<br>由于$\gcd(i, j)$有可能等于$i$，所以我们要进行一些消元操作，把这些数移到右边。这样的数总共有$\lfloor\frac{m}{i}\rfloor$个，所以可以改写为：<br>$$<br>f(i) = 1 + \sum_{j=1, \gcd(i, j) \neq i}^{m} \frac{f(\gcd(i, j))}{m} + \frac{\lfloor\frac{m}{i}\rfloor f(i)}{m}\\<br>\frac{m - \lfloor\frac{m}{i}\rfloor}{m}f(i) = 1 + \sum_{j=1, \gcd(i, j) \neq i}^{m} \frac{f(\gcd(i, j))}{m} \\<br>$$<br>于是得到最终式子<br>$$<br>\begin{equation}<br>f(i) = \frac{m + \sum_{j=1, \gcd(i, j) \neq i}^{m} f(\gcd(i, j))}{m - \lfloor\frac{m}{i}\rfloor}<br>\end{equation}<br>$$<br>那么最终的答案就可以写成$Ans = 1+\frac{\sum_i^{m} f(i)}{m}$<br>然而这个式子不化简递推至少需要$O(m^2\log{m})$的时间复杂度，所以考虑枚举$\gcd(i, j)$，这个值一定是$i$的约数。<br>$$<br>\sum_{j=1}^{m} f(\gcd(i, j)) = \sum_{d|i} f(d) \sum_{j=1}^{m} [\gcd(i, j) == d]<br>$$<br>然后便是$\gcd$莫比乌斯反演的标准套路了<br>$$<br>\begin{align}<br>S &amp;= \sum_{d|i} f(d) \sum_{j=1}^{\lfloor \frac{m}{d} \rfloor} \bigg[\gcd\bigg(\frac{i}{d}, j\bigg) == 1\bigg] \\<br>&amp;= \sum_{d|i} f(d) \sum_{j=1}^{\lfloor \frac{m}{d} \rfloor} \sum_{g|\gcd(i/d, j) } \mu(g) \\<br>&amp;= \sum_{d|i} f(d) \sum_{g|i/d} \mu(g) \lfloor\frac{m}{dg} \rfloor<br>\end{align}<br>$$<br>然后又是老套路令$T=gd$，并且我们直接枚举$T$，此时$g = \frac{T}{d}$<br>$$<br>\begin{equation}<br>S = \sum_{T|i} \lfloor\frac{m}{T} \rfloor \sum_{d|T} \mu\bigg(\frac{T}{d}\bigg) f(d)<br>\end{equation}<br>$$<br>然后我们刨去$f(d=i)$的部分，但是观察到当$f(d=i)$的时候对整个式子的贡献就是它自己，因为$\mu(1)$和前面那坨都是1，而我们在推式子 $(1)$ 的时候已经把$f(d=i)$的贡献丢掉了，所以此时我们用直接 $(5)$ 替换掉 $(1)$ 中求贡献的部分即可。<br>$$<br>\begin{equation}<br>f(i) = \frac{m + \sum_{T|i} \lfloor\frac{m}{T} \rfloor \sum_{d|T} \mu(\frac{T}{d}) f(d)}{m - \lfloor\frac{m}{i}\rfloor}<br>\end{equation}<br>$$<br>此时还有一个小问题，就是如何快速求$g(T) = \sum_{d|T} \mu(\frac{T}{d}) f(d)$，其实很简单，每次我们求出一个$f(i)$，我们可以用类似埃氏筛的方法枚举倍数，然后把$\mu(\frac{T}{i}) f(i)$加到对应的$g(T)$上即可。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>每个数的约数，以及$\mu(i)$可以用欧拉筛和埃氏筛在$O(m)$时间内求出。<br>对于每个$f(i)$，先求约数，然后与$g(T)$进行计算，这个时间复杂度会被均摊到$O(m\log{m})$。<br>接下里每个$f(i)$还会枚举倍数，这个复杂度可以用调和级数计算$\sum_i \lfloor\frac{m}{i}\rfloor \leq O(m\ln{m})$。<br>所以总体复杂度为$O(m\log{m})$</p>
<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!nop[i]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            primes[tot++] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            mu[i] = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot &amp;&amp; primes[j] * i &lt;= N; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            nop[i * primes[j]] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                mu[i * primes[j]] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            mu[i * primes[j]] = -mu[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 求每个数的约数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= N; j += i) d[j].push_back(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sieve(m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> invM = getInv(m, MOD);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= m; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> d : d[i]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            F[i] += (ll)(m / d) * G[d] % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            F[i] %= MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        F[i] = (F[i] + m) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        F[i] = (ll)F[i] * getInv((m - m / i), MOD) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 递推G(T)的值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= m; j += i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            G[j] += mu[j / i] * F[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            G[j] %= MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sum = (sum + F[i]) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 把数值扳正</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (((ll)sum * invM + <span class="number">1</span>) % MOD + MOD) % MOD);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>数论</tag>
        <tag>概率</tag>
      </tags>
  </entry>
  <entry>
    <title>[CF442B] Andrey and Problem</title>
    <url>/2020/07/23/CF442B/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你一个长度为$n$的集合，集合中每个元素是$[0,1]$之间的概率，代表第$i$个元素有$p_i$的概率变成1。求如何选择这个集合的一个子集，使得最后只有一个数为$1$的概率最大，输出这个概率。</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>首先明确我们要求的其实是$P(X=1)$，也就是只有一个元素为1的概率，那么假设我们已经选择了集合$S$，那么<br>$$<br>P(S) = \sum_{i=1}^{|S|} p_i \prod_{j=1, i\neq j}^{|S|} (1 - p_j)<br>$$<br>那么假设我们现在要加入一个新元素$p_k$，那么概率会变成:<br>$$<br>\begin{align}<br>P(S’) &amp;= (1-p_k)\sum_{i=1}^{|S|} p_i \prod_{j=1, i\neq j}^{|S|} (1 - p_j) + p_k \prod_{j=1}^{|S|}(1-p_j) \\<br>P(S’) &amp;= (1 -p_k) P(S) + p_k\prod_{j=1}^{|S|}(1-p_j) \\<br>\Delta p&amp;= -p_k P(S)+ p_k\prod_{j=1}^{|S|}(1-p_j) \\<br>&amp;=p_k\bigg(-P(S)+\prod_{j=1}^{|S|}(1-p_j)\bigg)<br>\end{align}<br>$$<br>已知$p_k \in [0, 1]$，那么如果$\prod_{j=1}^{|S|}(1-p_j) &gt; P(S)$就会递增概率。而且递增量刚好是$p_k$倍这个差距。<br>我们知道$\prod_{j=1}^{|S|}(1-p_j)$和$P(S)$这两个函数的取值都在$[0, 1]$这个范围内，而$\prod_{j=1}^{|S|}(1-p_j)$必然随着选择元素增加而减少，而$P(S)$的值需要保持最优，也就是最大。由此可知，$f(S) = \prod_{j=1}^{|S|}(1-p_j) - P(S)$这个类似导数的东西一定会越来越小，那么我们一定要从$p_k$最大的元素开始取，这样才能保证取到最优解，否则收益一定没有最早取最大值要大，<br>但是这个结论我们需要一个比较严谨的证明，以后补上。。。<br>所以最终做法就是从最大值开始取元素，如果$P(S)$能继续增加就取它，否则就维持最大值。这个题数据范围$100$就是搞心态的。。。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>$O(n\log{n})$</p>
<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> A[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;A[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sort(A + <span class="number">1</span>, A + n + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> ans = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> invs = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">double</span> tmp = ans * (<span class="number">1</span> - A[i]) + A[i] * invs;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        invs *= (<span class="number">1</span> - A[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (tmp &lt; ans) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ans = max(ans, tmp);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.9lf"</span>, ans);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>概率</tag>
        <tag>贪心</tag>
        <tag>结论</tag>
      </tags>
  </entry>
  <entry>
    <title>快速傅里叶变换（FFT）</title>
    <url>/2020/07/19/fft/</url>
    <content><![CDATA[<h1 id="多项式乘法、卷积"><a href="#多项式乘法、卷积" class="headerlink" title="多项式乘法、卷积"></a>多项式乘法、卷积</h1><p>假设我们有两个多项式$f, g$<br>$$<br>f(x) = \sum_{i=0}^n a_ix^i\\<br>g(x) = \sum_{i=0}^m b_ix^i\\<br>$$</p>
<a id="more"></a>
<p>两个多项式的最高次项分别为$n$和$m$，那么两个多项式的乘积有<br>$$<br>f(x)g(x) = \sum_{i=0}^{n+m} \sum_{j=0}^{i} a_{j}b_{i-j}x^i<br>$$<br>我们可以把这种$c_i = \sum_{j=0}^{i} a_{j}b_{i-j}$这种形式的运算叫做卷积运算。朴素算法去计算这个卷积每一个$c_i$需要计算$i$项，加上外层的$n+m+1$项总共需要$O(n^2)$级别的时间复杂度。<br>为了加速这一过程，我们可以利用多项式本身的一些性质，其中一个很重要的性质就是我们取不同的$n+1$个数，分别插入多项式求出$f(x)$，那么求出来这$n$个值一定能唯一的确定这个多项式$f(x)$。<br>为什么能这样呢？我们可以把一个$n$阶多项式看做含有$n+1$个未知数的方程组，系数是未知数，$x^i$是未知数的系数。我们可以写成矩阵形式<br>$$<br> \left[<br>  \begin{matrix}<br>   1 &amp; x_0 &amp; x_0^2 &amp; \cdots \\<br>   1 &amp; x_1 &amp; x_1^2 &amp; \cdots \\<br>   1 &amp; x_2 &amp; x_2^2 &amp; \cdots \\<br>   \vdots &amp; \vdots &amp; \vdots &amp; \ddots<br>  \end{matrix}<br>   \right]<br>   =<br>    \left[<br>  \begin{matrix}<br>    y_0 \\<br>    y_1 \\<br>    y_2 \\<br>   \vdots<br>  \end{matrix}<br>   \right]<br>$$<br>由于$x_i$各不相同所以矩阵总能化为阶梯形矩阵，所以一定有且仅有一个解。所以如果我们能求出$f(x),g(x)$的点值表示法，我们就能求出$f(x)g(x)$的点值了，只要将他们点值分别相乘，只需要$O(n)$时间。</p>
<p>可惜的是，先不说解方程用的高斯消元需要$O(n^3)$的时间，连求出所有$y_i$的时间都已经有$O(n^2)$了。</p>
<h1 id="复平面与单位根"><a href="#复平面与单位根" class="headerlink" title="复平面与单位根"></a>复平面与单位根</h1><p>由于直接求$y_i$没有什么搞笑方法，我们就得利用多项式的其他性质了，比如所有项都带个次方$x^i$，那么如果我们能选取一些特殊的点值，使得我们能够利用这些次方项，是不是能加速求解的速度呢？</p>
<p>答案是，是的。只不过我们去的这些数不一定是实数，而是虚数。准确的说，是$n$次单位复根。$n$次单位复根其实就是方程$x^n=1$的所有根，它一定会有$n$个根，分别为：$\omega_{n}^{0}, \omega_{n}^{1}, \cdots, \omega_{n}^{n-1}$。复数域上的运算有一个性质，两个复数相乘等于它们的模长相乘，同时辐角相加的结果。我们知道$n$次单位根的模长都为1，所以不需要管大小，像$\omega_n^k$其实就是$\omega_n^1$转了$k$次的位置，也就是从x轴正半轴转了$\frac{n}{k}$个圆的位置。</p>
<p>那么这个复数在复平面上就代表了一个唯一的点，所以我们可以用二维平面的公式求出这个点的位置<br>$$<br>\omega_n^k = \bigg(\cos(\frac{2\pi}{k}), \sin(\frac{2\pi}{k})\bigg)<br>$$<br>。所以其实$n$次单位根是个啥？就是把半径为1的圆分成$n$份，圆上$n$个点的位置，第$k$个点就是从x轴正半轴数第几个位置，也就是$\omega_{n}^k$。</p>
<p>而我们的傅里叶变换，其实就是求出多项式$f(x)$（此时最高次项为n-1）<br>在$f(\omega_n^0), f(\omega_n^1), \cdots, f(\omega_n^{n-1})$这$n$个位置的值。</p>
<p>乍一看好像也不好求，但是我们之前说了，复数乘法其实就是绕着圆心转，次方就是转几次，那么这个多项式有很多个$x^i$，那么是不是提示了我们，其实有很多地方我们会转到相同的值上呢？比如说$(\omega_n^1)^2 =\omega_n^2$。</p>
<p>在此之前，我们先提出几个复数运算的引理，这些都很容易证明是正确的：<br>$$<br>\begin{align}<br>(\omega_n^k)^i &amp;= \omega_n^{ki} \\<br>\omega_n^{an+k} &amp;= \omega_n^{k} \\<br>\omega_{2n}^{2k} &amp;= \omega_{n}^k \\<br>\omega_n^{k + \frac{n}{2}} &amp;= -\omega_{n}^k<br>\end{align}<br>$$<br>最后一个引理的意思是，你在圆上转了半圈，那么得到的位置一定和原来的位置是相反的。有了这几个引理我们才能确定快速傅里叶变换这个算法是正确的。</p>
<h1 id="快速傅里叶变换"><a href="#快速傅里叶变换" class="headerlink" title="快速傅里叶变换"></a>快速傅里叶变换</h1><p>接下来我们正式开始讲解快速傅里叶变换FFT的实现方法。首先，对于一个$n$次多项式，我们一定可以分开奇偶项来分解成这个样子<br>$$<br>f(x) = \sum_{i=0}^n a_ix^i = \sum_{i=0}^{\frac{n}{2}} a_{2i}x^{2i} + \sum_{i=0}^{\frac{n}{2}} a_{2i+1}x^{2i+1}<br>$$<br>然后我们把$2i+1$也变成$2i$，此时有<br>$$<br>\begin{align}<br>f(x) &amp;= \bigg(\sum_{i=0}^{\frac{n}{2}} a_{2i}x^{2i}\bigg) + x\times \bigg(\sum_{i=0}^{\frac{n}{2}} a_{2i+1}x^{2i}\bigg) \\<br>A(x^2) &amp;=  \sum_{i=0}^{\frac{n}{2}} a_{2i}(x^2)^i\\<br>B(x^2) &amp;=  \sum_{i=0}^{\frac{n}{2}} a_{2i+1}(x^2)^i\\<br>f(x) &amp;= A(x^2) + xB(x^2) \\<br>\end{align}<br>$$<br>于是我们就把对于一个$n$阶多项式的变换转化成了对于两个$n/2$阶多项式的变换。<br>$$<br>f(\omega_n^k) = G(\omega_n^{2k}) + \omega_n^k H(\omega_n^{2k})<br>= G(\omega_{n/2}^{k}) + \omega_n^k H(\omega_{n/2}^{k})<br>$$<br>那么这样做的好处在哪呢？<br>此时$f(\omega_n^{k+n/2})$的值也可以立即得出<br>$$<br>f(\omega_n^{k+n/2}) = G(\omega_n^{2k+n}) + \omega_n^{k+n/2} H(\omega_n^{2k+n})<br>= G(\omega_{n/2}^{k}) - \omega_n^k H(\omega_{n/2}^{k})<br>$$<br>于是乎，如果我们只需要求出了前一半的$G(\omega_{n/2}^k),H(\omega_{n/2}^k)$，就可以在知道前一半的$f(\omega_{n}^{k})$同时立即填充后一半的$f(\omega_{n}^{k+n/2})$，在最上一层则可以填充所有的$f(x)$。<br>此时递归的方程可以写成<br>$$<br>T(n) = 2T(\frac{n}{2}) + n/2<br>$$<br>通过主定理展开得到$T(n) = O(n\log{n})$。<br>于是我们就可以写出以下递归代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> x, y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Complex() = <span class="keyword">default</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Complex(<span class="keyword">double</span> x, <span class="keyword">double</span> y) : x(x), y(y) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Complex <span class="keyword">operator</span>+(<span class="keyword">const</span> Complex&amp; c) <span class="keyword">const</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> Complex(x + c.x, y + c.y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Complex <span class="keyword">operator</span>-(<span class="keyword">const</span> Complex&amp; c) <span class="keyword">const</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> Complex(x - c.x, y - c.y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Complex <span class="keyword">operator</span>*(<span class="keyword">const</span> Complex&amp; c) <span class="keyword">const</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> Complex(x * c.x - y * c.y, x * c.y + y * c.x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fft</span><span class="params">(Complex* arr, <span class="keyword">int</span> len, <span class="keyword">bool</span> forward)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (len == <span class="number">1</span>) <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Complex* even = (Complex*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Complex) * len / <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Complex* odd = (Complex*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Complex) * len / <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += <span class="number">2</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        even[i / <span class="number">2</span>] = arr[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        odd[i / <span class="number">2</span>] = arr[i + <span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    fft(even, len / <span class="number">2</span>, forward);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    fft(odd, len / <span class="number">2</span>, forward);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">Complex <span class="title">wn</span><span class="params">(<span class="built_in">cos</span>(<span class="number">2</span> * PI / len), <span class="built_in">sin</span>(<span class="number">2</span> * PI / len))</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len / <span class="number">2</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Complex t = w * odd[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        arr[i] = even[i] + t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        arr[i + len / <span class="number">2</span>] = even[i] - t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        w = w * wn;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">free</span>(odd);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">free</span>(even);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>值得注意的是，由于每次都是递归处理两个大小为$\frac{n}{2}$的多项式，所以整个多项式的大小必须是二的次方$2^k$，如果不够可以考虑补0到二的次方。</p>
<h1 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h1><p>递归算法的复杂度已经达到了复杂度下限，但是我们可以让它的运行速度更快一点。这便是Cooley-Tukey的快速傅里叶变换算法。<br>优化的方法其实很简单，因为递归算法的瓶颈在于递归的额外开销，所以我们如果能把它转化为递推合并，就能加快速度。<br>因为每次递归我们都是把原多项式系数奇偶分类，所以递归到最后会形成一个原多项式系数的排列。通过观察规律，我们发现这个排列有这样一个性质：假设系数下标为$x$（从零开始），那么它在奇偶分类递归后会处于第$y$位，这个$y$等于$x$在原多项式大小$2^k$的$k$位二进制下反转的值。举个例子：假设原多项式是$2^4=16$个系数，那么对于第$2 = (0010)_2$个系数，变换之后的位置会是第$(0100)_2=4$位。而且这个规律在合并的时候是保持不变的，如此，我们就可以完全舍弃递归算法，在进行fft之前先对系数做一个重新排序。<br>反转二进制位我们可以用递推法实现，原理就是利用$x$右移一位的值。假设有$f((0010)_2)=(0100)_2$，那么$f((0100)_2)$就可以利用$f((0010)_2)$的值右移一位然后在倒着加上自己的最右一位的值得到。边界条件$f(0)=0$。<br>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; R); i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">           rev[i] = (rev[i &gt;&gt; <span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (R - <span class="number">1</span>));</span></pre></td></tr></table></figure>
<p>接下来就是利用这个排序后的系数进行变换了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transform</span><span class="params">(Complex* data, <span class="keyword">int</span> sign)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> len = <span class="number">1</span> &lt;&lt; R;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 重新排序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i &lt; rev[i]) swap(data[i], data[rev[i]]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 枚举一半的长度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt; len; k &lt;&lt;= <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 步长</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> step = k &lt;&lt; <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function">Complex <span class="title">unit</span><span class="params">(<span class="built_in">cos</span>(PI / k), sign * <span class="built_in">sin</span>(PI / k))</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i += step) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="function">Complex <span class="title">rt</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Complex t1 = data[i + j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                data[i + j] = t1 + rt * data[i + j + k];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                data[i + j + k] = t1 - rt * data[i + j + k];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                rt = rt * unit;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<h1 id="傅里叶逆变换"><a href="#傅里叶逆变换" class="headerlink" title="傅里叶逆变换"></a>傅里叶逆变换</h1><p>现在我们得到了多项式$f(x)$在$x = \omega_{n}^{k}$处的点值了，那么如何快速的从这个点值得到多项式的系数呢？先考虑列出的线性方程组$Ax=b$：<br>$$<br> \left[<br>  \begin{matrix}<br>   1 &amp; 1 &amp; 1 &amp; \cdots &amp; 1\\<br>   1 &amp; \omega_{n}^{1} &amp; \omega_{n}^{2} &amp; \cdots &amp; \omega_{n}^{(n-1)}\\<br>   1 &amp; \omega_{n}^{2} &amp; \omega_{n}^{4} &amp; \cdots &amp; \omega_{n}^{2(n-1)}\\<br>   \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\<br>   1 &amp; \omega_{n}^{(n-1)} &amp; \omega_{n}^{2(n-1)} &amp; \cdots &amp;\omega_{n}^{(n-1)^2}<br>  \end{matrix}<br>   \right]<br>   \left[<br>    \begin{matrix}<br>    a_0\\<br>    a_1\\<br>    a_2\\<br>    \vdots\\<br>    a_{n-1}<br>    \end{matrix}<br>   \right]<br>   =<br>    \left[<br>  \begin{matrix}<br>    y_0 \\<br>    y_1 \\<br>    y_2 \\<br>   \vdots \\<br>   y_{n-1} \\<br>  \end{matrix}<br>   \right]<br>$$<br>则$x =A^{-1}b$，所以只要求出大矩阵的逆与原点值向量相乘就是系数。<br>我们先来观察一下一个大小为8的矩阵：<br>$$<br> \left[<br>    \begin{matrix}<br>        1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 &amp; 1\\<br>        1 &amp; \omega_{n}^{1} &amp; \omega_{n}^{2} &amp; \omega_{n}^{3} &amp; \omega_{n}^{4} &amp; \omega_{n}^{5} &amp; \omega_{n}^{6} &amp; \omega_{n}^{7}\\<br>        1 &amp; \omega_{n}^{2} &amp; \omega_{n}^{4} &amp; \omega_{n}^{6} &amp; 1 &amp; \omega_{n}^{2} &amp; \omega_{n}^{4} &amp; \omega_{n}^{6}\\<br>        1 &amp; \omega_{n}^{3} &amp; \omega_{n}^{6} &amp; \omega_{n}^{1} &amp; \omega_{n}^{4} &amp; \omega_{n}^{7} &amp; \omega_{n}^{2} &amp; \omega_{n}^{5}\\<br>        1 &amp; \omega_{n}^{4} &amp; 1 &amp; \omega_{n}^{4} &amp; 1 &amp; \omega_{n}^{4} &amp; 1 &amp; \omega_{n}^{4}\\<br>        1 &amp; \omega_{n}^{5} &amp; \omega_{n}^{2} &amp; \omega_{n}^{7} &amp; \omega_{n}^{4} &amp; \omega_{n}^{1} &amp; \omega_{n}^{6} &amp; \omega_{n}^{3}\\<br>        1 &amp; \omega_{n}^{6} &amp; \omega_{n}^{4} &amp; \omega_{n}^{2} &amp; 1 &amp; \omega_{n}^{6} &amp; \omega_{n}^{4} &amp; \omega_{n}^{2}\\<br>        1 &amp; \omega_{n}^{7} &amp; \omega_{n}^{6} &amp; \omega_{n}^{5} &amp; \omega_{n}^{4} &amp; \omega_{n}^{3} &amp; \omega_{n}^{2} &amp; \omega_{n}^{1}\\<br>    \end{matrix}<br>\right]<br>$$<br>而这个大矩阵求逆以后的操作为多项式$B(x)$<br>$$<br>B(x) = \frac{1}{n} \sum_{i=0}^{n-1} y_i x^i<br>$$<br>的点值，只不过这次点值插入的是$-\omega_{n}^{k}$，其实就是相当于在复平面反着转回去的结果除以n。反着转和正着转区别不大，只是方向相反，所以我们仍然可以套用FFT的过程，只不过把单位根的转向变成负的即可。之前代码里面的<code>sign</code>参数其实就是为了逆变换的，如果<code>sign</code>为1就是正向变换，反之就是逆向变换。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>多项式</category>
      </categories>
      <tags>
        <tag>快速傅里叶变换</tag>
      </tags>
  </entry>
  <entry>
    <title>[CF1286A] Garland</title>
    <url>/2020/02/26/CF1286A/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>有一个由$1-n(n\leq 100)$构成的数列，其中部分被删除（删除的元素由$0$代替），请用被删除的元素补全这个数列，使这个数列中相邻元素奇偶性不同的对数最少。</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>这种又像贪心又像dp的题当然是要使用随机化算法了（其实是dp太难想了）。</p>
<p>首先先明确这道题要求的是什么，其实是这个式子：</p>
<p>$<br>f(a)=\sum\limits_{i=2}^{n} parity(a_{i-1}) \oplus parity(a_i)<br>$</p>
<p>由于缺失的数字要么是奇数，要么是偶数，所以问题转化为如何将这些奇数和偶数填进数组使得相邻两数之间的奇偶性不同的对数最少。</p>
<p>由于没有什么明显的性质，dp式子也不好推，看一下数据范围$n\leq100$，那么我们显然可以用爬山/模拟退火等随机化算法搞一搞。</p>
<p>我们先从估价函数开始分析，对于这道题估价函数只需要$O(n)$的复杂度，完全可以接受。</p>
<p>接下来我们考虑枚举后继状态的转移，运用爬山的思想，我们只需要选择后继状态里面$f(a’)$比当前状态小且最小的那个$a’$就行了。如果发现没有任何后继状态比这个状态更好我们就可以退出爬山了。具体的枚举方式可以是交换两个奇偶性不同的填充数字，形成一个新的排列。</p>
<p>我第一次尝试的就是<strong>随机化爬山</strong>算法。一般来说，使用随机爬山算法足以应付大部分随机化题目，但是发现爬山在本题有一个致命的缺陷。设状态$x$为当前最优状态，当$f(a’)=f(x)$的时候爬山算法是不会转移到$a’$的。但是这题的函数是可以长这个样子的</p>
<p><img src="https://cdn.luogu.com.cn/upload/image_hosting/317wgxgo.png" alt=""></p>
<p>于是随机爬山算法的很多起始点都会被这块平原阻挡，无法到达全局最优解。此时我们就需要对$f(a’)=f(x)$状态的转移进行优化，引入模拟退火的温度概念。每次遇到与当前最优解相同的状态都用一个概率$e^{-\frac{1}{T}}$去接受它，接受的概率会随着文读的下降而下降，而与模拟退火不同的是我们不接受任何不优的$a’$。因为这题的特殊性质，$f(a’)&lt;f(x)$基本上是不会产生更优解，反而会浪费计算资源的。</p>
<p>加入了这个优化以后就能以相当高的几率得到最优解，同时我并没有对运行时间进行什么优化，这个算法实际上还可以更快。具体实现可以参考我的代码：</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>$O(n^2 \times 玄学)$</p>
<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">mt19937 <span class="title">mt</span><span class="params">(<span class="number">15784371</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[MAXN], b[MAXN], p[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> bin[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 估价函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eval</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) a[b[i]] = p[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) cnt += (a[i - <span class="number">1</span>] &amp; <span class="number">1</span>) ^ (a[i] &amp; <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hill_climbing</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">bool</span> swp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans = eval();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> T = <span class="number">100</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">do</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        swp = <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; m; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (p[i] == p[j]) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                swap(p[i], p[j]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> e = eval();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (e &lt; ans) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="comment">// 遇到更优解一定转移</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    swp = <span class="literal">true</span>, ans = e;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e == ans) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="comment">// 如果解状态并不优，则机率接受它</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">double</span> p = <span class="built_in">exp</span>(<span class="number">-1</span> / T);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (mt.max() * p &gt; mt()) swp = <span class="literal">true</span>, ans = e;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="comment">// 否则回退状态</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                    swap(p[i], p[j]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        T *= <span class="number">0.85</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cnt++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 结合了爬山算法和模拟退火，要么局部最优解跳出，要么温度过低跳出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">while</span> (swp &amp;&amp; T &gt; <span class="number">1e-6</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(<span class="keyword">int</span>* a, <span class="keyword">int</span> sz)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = sz - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> j = mt() % (i + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        swap(a[i], a[j]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans = INF2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">20</span>; t++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        shuffle(p, m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ans = min(ans, hill_climbing());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// b数组代表第i个空是a数组的第几个元素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!a[i]) b[m++] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        bin[a[i]] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> odd = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!bin[i])</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (i &amp; <span class="number">1</span>) odd++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// p数组代表第i个空是奇数还是偶数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; odd; i++) p[i] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = odd + <span class="number">1</span>; i &lt; m; i++) p[i] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, search());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>随机化</tag>
      </tags>
  </entry>
  <entry>
    <title>[UVA1614] Hell on the Markets</title>
    <url>/2020/02/26/UVA1614/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你一个长度为$n(n\leq 10^5)$的序列$A$, 满足$1 \leq A_i \leq i$。求确定每个数的正负号，使得总和为$0$。</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>如果不考虑那个诡异的条件，显然我们只需要求出序列$A$的子集和是否可以等于总和的一半即可。但是子集和问题(Subset Sum)是一个著名的NPC问题，显然无法在满足时间限制的条件下得到解。</p>
<p>于是我们必须考虑如何使用$1 \leq A_i \leq i$这个条件。我一开始的猜想就是如果序列总和$S_n$是偶数，那么在这个限制条件下一定存在一个子集$a$使得$Sum(a) = S / 2$。但是我无法证明它，也没法找到一个合适的贪心方法找出这个子集。</p>
<p>看了别人的题解才发现这个结论需要变得更强一点：对于前缀和$S_i$，以及$1$到$S_i$的每个整数$x$，一定能从前$i$个元素中找出一个子集使得子集的和等于$x$。证明可以使用归纳法：</p>
<p>$\textbf{Base Case: }$ 当$i = 1$的时候，我们有$a_1 = 1$，那么我们可以用$a_1$，凑出$S_1$。</p>
<p>$\textbf{Inductive Hypothesis: }$ 假设对于整数$k$，我们有对于所有$1$到$S_k$的整数，都存在一个由前$k$个数组成的集合，使得集合的和为这个整数。</p>
<p>那么对于整数$k+1$，新加入的这个$a_{k+1}$有$1 \leq a_{k+1} \leq k + 1$。此时$S_{k+1} = S_k + a_{k + 1}$。对于所有$x \leq S_k$，我们都可以用前$k$个元素组成。那么我们只需要考虑对于所有$S_k + 1 \leq x \leq S_k + k + 1$我们如何去组合就行了。假设我们有$a_{k+1} = y$，$S_{k + 1} = S_k + y$，那么$S_k + j (j \in [1, y])$可以由组成$S_k + j - y$的集合中，添加一个$a_{k+1}$组成。由于$y\geq j$，所以所有的$S_k + j - y$集合都可以由前$k$个元素组成，新加的元素只需要贡献$y$。因此我们有对于所有$1$到$S_{k+1}$的整数，都存在一个由前$k+1$个数组成的集合，使得集合的和为这个整数。</p>
<p>于是此结论得证，我们一定可以凑出来$S_n/2$。但是怎样去凑呢？还是要利用这个结论。假设我们想用前$k$个元素凑出$x$，则一定有$x&lt;=S_k$，那么如果$0 \leq x-a_k \leq S_{k-1}$，则前$k-1$个元素一定能凑出$x-a_k$。由于$x\leq S_k$，所以一定满足$x-a_k \leq S_{k-1}$。如果出现$x-a_k$为负数的情况，那么一定有$x \leq S_{k-1}$，否则根据前缀和，无法出现负数。由于$x \leq S_k$一直保持，所以一定有$x\leq S_1=1$，所以$x$最后一定为$0$。</p>
<p>至此，我们得出了一个凑出子集和等于$S_n/2$的方法，从后往前选取$a_i$，如果$a_i$的选取会超出$S_n/2$，那么就不选，由于上面的证明，最后一定选取的元素和一定为$S_n/2$。至此，这道题终于被解决了，有两个结论和两个不显然的证明，实在是难想啊。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>$O(n)$</p>
<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line">ll pref[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pref[i] = pref[i - <span class="number">1</span>] + arr[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (pref[n] &amp; <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"No\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll st = pref[n] / <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; i--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (st - arr[i] &gt;= <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            st -= arr[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            arr[i] *= <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"Yes\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i != <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">" "</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>, arr[i] &lt; <span class="number">0</span> ? <span class="number">-1</span> : <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (~<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        solve();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>UVA</category>
      </categories>
      <tags>
        <tag>贪心</tag>
        <tag>结论</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title>[SDOI2012]任务安排</title>
    <url>/2020/02/10/SDOI2012Mission/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>有$n (n\leq 3\times10^5)$个任务需要被完成，你可以把这些任务全部分成任意多组，每组内的任务必须连续。同组任务会在同一时刻完成，所花时间为$\sum_{i=l}^{r}t_i$，同时每组任务开始有一个预热时间$s$。任务$i$完成的费用为完成时间乘以$c_i$，求如何分组能让费用最小。</p>
<a id="more"></a>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>既然要把所有任务都分组，那么我们只需要知道每个任务属于哪一个组所需费用最小即可。对于任务$i$，我们想要知道从之前哪个任务分过来费用最小。于是考虑动态规划，设$f(i)$为从$1~i$分组完成，所需的最少费用，答案则是$f(n)$。但是有个启动时间$s$不好处理，怎么办呢。利用费用提前思想，每次启动机器的时间一定会给后面的任务贡献费用，那么转移方程为：<br>$$<br>f(i) = \min_{j&lt;i}\{f(j) + (F_i - F_j) * T_i + s * (F_n - F_j) \}<br>$$<br>式子中$F_i$表示费用的前缀和，$T_i$表示时间的前缀和。</p>
<p>显然暴力寻找是$O(n^2)$，但是可以用斜率优化DP的套路去降时间复杂度。考虑到费用$F_i$是单调不减的，那么显然$j$越小需要的费用越大，这就让我们想到决策可能是随着$i$增大而单调不减的，打表也证实了这一点。由于决策单调性的存在，我们的目标可以转变成计算出什么时候需要更新决策。</p>
<p>于是考虑此时我们在$i$，决策$j$能替换掉原有决策$k$，根据单调性此时一定有$j&gt;k$，且<br>$$<br>f(j) + (F_i - F_j) * T_i + s * (F_n - F_j) \leq f(k) + (F_i - F_k) * T_i + s * (F_n - F_k)<br>$$<br>即<br>$$<br>f(j) + F_iT_i - F_jT_i + sF_n - sF_j \leq f(k) + F_iT_i - F_kT_i + sF_n - sF_k<br>$$<br>消掉不变的项<br>$$<br>f(j) - F_jT_i - sF_j \leq f(k) - F_kT_i - sF_k<br>$$<br>移项，尽量让带$T_i$的在左边，$j, k$在右边<br>$$<br>T_i(F_k - F_j) \leq f(k)- f(j) - sF_k + sF_j<br>$$<br>这里要格外小心，由于$j&gt;k$，一定有$F_j&gt;F_k$，即$F_k - F_j \leq 0$。此时等于$0$的情况必须特判，而小于$0$的情况需要让不等式变号！最终结果：<br>$$<br>T_i \geq \frac{f(k)- f(j) - sF_k + sF_j}{F_k - F_j}<br>$$<br>由此我们可以得出结论，令$slope(k, j) = \frac{f(k)- f(j) - sF_k + sF_j}{F_k - F_j}$。当$slope(k, j) \leq T_i$时，有$j$优于$k$（因为$j&gt;k$所以$j$会比较靠后，是更优解），此时这个$slope(k, j)$可以看成是点$k$到点$j$的斜率。</p>
<p>我们进一步分析这个斜率，假设当前$j$打败了$k$，新来了一个$i &gt; j$，如果有$slope(j, i) \leq slope(k,j)$那么此时$j$也不占优势了。因为无论后面的$T_{i+1}$值是多少，$slope(j, i)$都会比$slope(k,j)$更容易小于$T_{i+1}$，而此时$i$又比$j$打，那么$j$就再也打不过$i$了。此时清除$j$这个废物，不然整个序列就不符合后面的具有比前面更优的潜力这个性质了（即决策单调）。</p>
<p>整理一下得到的两个性质<br>$$<br>\begin{cases}<br>    slope(k, j) &amp;\leq T_i  &amp;\text{此时j替换k}\\<br>    slope(k, j) &amp;\geq slope(j, i)  &amp;\text{此时j比不过i}<br>\end{cases}<br>$$<br>根据这两个性质我们就可以写出一个单调队列，里面存储的就是位置$i$，最优决策则可以通过这两个性质取得。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 性质1，QQ是单调队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (l &lt; r &amp;&amp; slope(QQ[l], QQ[l + <span class="number">1</span>]) &lt;= T[i]) ++l;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> opt = QQ[l];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dp[i] = dp[opt] + ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 性质2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (l &lt; r &amp;&amp; slope(QQ[r - <span class="number">1</span>], QQ[r]) &gt;= slope(QQ[r], i)) --r;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    QQ[++r] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>但是仔细看这题的数据范围，$|t_i|\leq2^8$，啥意思，就是$t_i$可能是负数，也就是$T_i$并非单调增。我们的代码这一行<code>while (l &lt; r &amp;&amp; slope(QQ[l], QQ[l + 1]) &lt;= T[i]) ++l;</code>就是基于$T_i$是单调增的情况，我们去除之前一定不会比现在更优的点。但是如果$T_i$并非单调增，被去掉点有可能在此时是最优解，于是我们只能删掉这一行。</p>
<p>那么问题来了，我们怎么知道哪个点是最优解呢？首先，我们利用性质1和2维护了一个斜率单调下降的序列，那么对于一个$T_i$，只要知道满足$slope(j, j+1) \leq T_i$且最大的$j+1$，就是最优解。于是我们可以使用二分。二分找指定条件的方法我在之前的博客中介绍过，这里就不多讲了。</p>
<p>最后一个极其重要的点就是由于这题的毒瘤性质$c_i$可以是$0$，也就是$F_j-F_k$可能是$0$，这会严重影响决策正确性。因为$slope(k, j)$此时有可能是正无穷也有可能是负无穷（因为分子不一定是正的），它们显然会干扰性质1和2。此时我们就要想，当$c_k$为$0$的时候我们是包括它还是不包括它更好呢？显然是要包括啊，免费的你还不要！也就是说，当$j&gt;k$的时候，我们不要去替换成$j$，而是能留多久留多久，如果要替换那就直接越过$j$，此时$j$毫无卵用。于是我们最好就把$slope(j,k)$设为正无穷大，使得它无论怎样都不会成为最优解，这样就不会有错了。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(n\log{n})$</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// j &gt; k</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">slope</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> j)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (F[k] == F[j]) <span class="keyword">return</span> <span class="number">1.0</span> / <span class="number">0.0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> (dp[k] - dp[j] + s * (<span class="keyword">double</span>)(F[j] - F[k])) / (<span class="keyword">double</span>)(F[k] - F[j]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bSearch</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, ll v)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> QQ[l];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans = r;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (slope(QQ[mid + <span class="number">1</span>], QQ[mid]) &gt;= v)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ans = mid, r = mid - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            l = mid + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> QQ[ans];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    n = read&lt;ll&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    s = read&lt;ll&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll t = read&lt;ll&gt;(), c = read&lt;ll&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        T[i] = T[i - <span class="number">1</span>] + t, F[i] = F[i - <span class="number">1</span>] + c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> opt = bSearch(l, r, T[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dp[i] = dp[opt] + (F[i] - F[opt]) * T[i] + s * (F[n] - F[opt]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; slope(QQ[r - <span class="number">1</span>], QQ[r]) &gt;= slope(QQ[r], i)) --r;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        QQ[++r] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, dp[n]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>斜率DP</tag>
      </tags>
  </entry>
  <entry>
    <title>数论筛法</title>
    <url>/2020/01/20/eulersieve/</url>
    <content><![CDATA[<h1 id="欧拉筛-线性筛"><a href="#欧拉筛-线性筛" class="headerlink" title="欧拉筛/线性筛"></a>欧拉筛/线性筛</h1><p>之前的素数判定中，我们曾使用埃拉托斯特尼筛法(Sieve of Eratosthenes)，进行素数的筛选。但是这个算法的时间复杂度是$O(n\log{\log{n}})$的，因为每个数都被它筛了它的素因子个数那么多次。</p>
<a id="more"></a>

<h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>欧拉筛法（Euler’s sieve）就是减少这种重复的一种筛法，埃筛的方法是筛去素数的倍数，而欧拉筛的核心思想是筛去最小素因子为它的数。这样一对比下来，因为每个数只有一个最小素因子，所以时间复杂度显然是$O(n)$。</p>
<p>然而，欧拉筛法的实现是有一点技巧的，我当初尝试理解的时候还是费了一番功夫。假设我们有一个数$x$，有唯一质因数分解：$\prod_{k} p_k^{\alpha_k} \ (p_{k-1} &lt; p_k)$。此时欧拉筛会筛除一个$p_i*x$，$p_i \leq p_1$，$p_1$就是最小素因子，也就是说筛去的这个数的最小素因子会小于等于$x$的最小素因子，且是$x$的倍数。现在我们就要对于所有的$x$都筛掉这些倍数。</p>
<p>那么为什么每个数只会被筛一次呢？根据唯一分解定理，任何一个数的质因数排序后的序列一定是唯一的，那么假设$a\neq b$，并且他们删掉最小素因子后的数相同，那么它们的最小素因子一定不同。那么他们会被那个除掉最小素因子的数筛掉，然后就不会再被触及。</p>
<p>现在又有一个问题，怎么保证$x\in[2,p-1]$的合数全部被筛掉，没有遗漏呢？还是那个思路，因为小于$p$的数的最小素因子一定小于$p$，所以它一定会被小于$x/最小素因子$的数筛掉，这就保证了正确性。</p>
<p>实现的时候，我们筛到一个素数就要把它放到一个数组里面，此时素数的大小顺序非常重要，因为我们对于$x$需要查找所有小于等于$p_1$的素数，同时在等于$p_1$的时候停止查找。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> nop[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[MAXN / ln(MAXN)];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!nop[i]) primes[tot++] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot &amp;&amp; i * primes[j] &lt;= n; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            nop[i * primes[j]] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// i 整除 p_j 代表此时p_j已经是i的最小素因子</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!(i % primes[j])) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="扩展应用"><a href="#扩展应用" class="headerlink" title="扩展应用"></a>扩展应用</h2><p>欧拉筛在数论筛法里面用途非常广泛，尤其是对于积性函数，以欧拉函数筛为例，我们令$\varphi(x)=n\prod_k(\frac{p_k-1}{p_k})$，如果$x$是质数，那么$\varphi(x)=x-1$。同时$\varphi(pq) = \varphi(p) * \varphi(q) \ (p \perp q)$，也就是积性函数性质。</p>
<p>于是我们可以在筛到质数的时候把它的$\varphi(x)$设为$x-1$，否则，我们就需要去计算筛到合数的时候$\varphi(x)$值的变化。因为每次我们只加入一个质因数$p$，如果这个质因数不在原数的质因数分解中，那么显然答案要乘以$\varphi(p)$，否则就乘以$p$本身。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> nop[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[MAXN / ln(MAXN)], phi[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!nop[i]) primes[tot++] = i, phi[i] = i - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot &amp;&amp; i * primes[j] &lt;= n; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            nop[i * primes[j]] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!(i % primes[j])) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                phi[i * primes[j]] = primes[j] * phi[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                phi[i * primes[j]] = phi[primes[j]] * phi[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>质因数分解</title>
    <url>/2019/12/31/prime-factor/</url>
    <content><![CDATA[<h1 id="质因数分解"><a href="#质因数分解" class="headerlink" title="质因数分解"></a>质因数分解</h1><p>接着上一章的素数判定，这一章我们要讨论质因数分解的算法。</p>
<blockquote>
<p>算数基本定理，又称唯一分解定理：每个大于$1$的自然数，都可以写成质数次方的积，且这些质数从小到大排列后，仅存在这一种分解方式。</p>
</blockquote>
<p>换句话说，每个$n&gt;1$，都有唯一一种分解方式$\prod_{k} p_k^{\alpha_k} = n$。</p>
<a id="more"></a>
<h2 id="朴素方法"><a href="#朴素方法" class="headerlink" title="朴素方法"></a>朴素方法</h2><p>对于所有$p|n$，我们不断试除就可以了，与质数判定同理，我们不需要试超过$\sqrt{n}$的质数，因为这样的质数一定就是$n$本身，于是有代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;ll, ll&gt; factorize(ll x) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">map</span>&lt;ll, ll&gt; pcnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i * i &lt;= x; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) cnt++, x /= i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            pcnt[i] = cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 注意要把最后一个质数包括进去</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) pcnt[x] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> pcnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>注意我们可以直接在$n$上面做除法，而不用真的遍历到$\sqrt{n}$，因为发现一个质因数就可以把数据规模缩小，可以用哈希表把$log$消掉。这样，在最坏情况下这个算法时间复杂度是$O(\sqrt{n})$。当然，如果先把所有质数预处理出来，可以达到$O(\sqrt{\frac{n}{\log{n}}})$。</p>
<h2 id="Pollard’s-rho-算法"><a href="#Pollard’s-rho-算法" class="headerlink" title="Pollard’s rho 算法"></a>Pollard’s rho 算法</h2><h3 id="生日悖论-Birthday-Paradox"><a href="#生日悖论-Birthday-Paradox" class="headerlink" title="生日悖论 (Birthday Paradox)"></a>生日悖论 (Birthday Paradox)</h3><p>在介绍Pollard’s rho算法之前，我想先介绍一个概率学中的小问题：一个房间中要有多少人，出现两个人生日相同的概率大于等于$50\%$？</p>
<p>如果你是第一次看到这个问题，那么答案可能会让你惊讶：只需要$23$个人。这不是玄学，而是通过严谨的数学推理得出的，实验也证明了这一点。那么这个结果是如何得到的呢？</p>
<p>假设一年有$365$天，且每个人的生日是独立且均匀分布的，那么第一个人在第$x$天生日的概率是$\frac{1}{365}$，我们记为$Pr\{b_1=x\}$。那么现在来了第二个人，它的生日在第$x$天的概率$Pr\{b_2=x\}$也是$\frac{1}{365}$，此时两个人都在第$x$天的概率是<br>$$<br>Pr\{b_1=x \textbf{ and } b_2=x\} = \frac{1}{365^2}<br>$$<br>但是这个$x$我们可以取$365$个，于是两个人生日都在同一天的概率就是<br>$$<br>Pr\{b_1=b_2\} = 365\times \frac{1}{365^2} = \frac{1}{365}<br>$$<br>知道了任意两人生日相同的概率，就可以扩展到$k$个人中的两人生日相同的期望值，由于$k$个人中选$2$个，所以有:<br>$$<br>E = {k\choose2} \frac{1}{365} = \frac{k(k-1)}{730}<br>$$<br>所以期望存在至少一对生日相同的两人只需要$k=28$，$50\%$概率的计算由于比较复杂就不放上来了，但是可以推测，这个值一定会比$28$少。</p>
<p>于是我们可以知道，生日碰撞的概率是$O(\sqrt{n})$级别的，而不是我们下意识的$O(n)$。</p>
<h3 id="随机化算法"><a href="#随机化算法" class="headerlink" title="随机化算法"></a>随机化算法</h3><p>Pollard’s rho 算法的基本原理就是从待分解数$x$中任意找出两个数$a, b$，计算$gcd(|a - b|, x)$，当他们的$gcd$不是$1$的时候，我们就找到了$x$的一个因数。为什么是取两个呢？这就要利用我们上面说到的生日悖论了，因为只取一个$a$，此时$a|x$的几率很小，但是如果我们取两个数做差，出现$|a-b|$与$x$有公约数的几率就大很多了。事实上Pollard’s rho算法输出$x$的一个约数$p$的期望运行时间是$O(\sqrt{p})$。</p>
<p>那么如何选取这两个数呢？我们可以随机选取，但是Pollard’s rho算法使用的是一种二次剩余系的伪随机数生成函数<br>$$<br>f(x) = x^2 + c \pmod{n}<br>$$<br>为什么用这个函数呢？我没有在算法导论上看到具体说明，但是这个函数应该是对于Pollard’s rho算法的时间效率最优的函数。由于这个函数最后一定会出现循环，长得像希腊字母$\rho$，因此得名。</p>
<p><img src="/uploads/rho_cycle.jpg" width="30%" height="30%"></img><br>正因为这个性质，在出现环的时候我们也需要及时的退出并且换下一个随机数。我们可以使用Floyd判圈算法来判断是否出现了环，大意就是两个指针一个走一步一个走两步，如果有环那么两个指针一定会碰上，于是我们就可以有代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">f</span><span class="params">(ll x, ll c, ll p)</span> </span>&#123; <span class="keyword">return</span> (modmul(x, x, p) + c) % p; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">pollard_rho</span><span class="params">(ll x)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll c = mt() % (x - <span class="number">1</span>) + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll l = f(mt() % x, c, x), r = f(l, c, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// l是慢的指针，r是快的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (l != r) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll g = __gcd(<span class="built_in">abs</span>(l - r), x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (g &gt; <span class="number">1</span>) <span class="keyword">return</span> g;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        l = f(l, c, x), r = f(f(r, c, x), c, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如果$x$是个质数，那么我们可以用上一章的Miller–Rabin算法提前判掉，这样整个算法的期望时间复杂度就是$O(n^{0.25}\log{n})$了。</p>
<h3 id="常数优化"><a href="#常数优化" class="headerlink" title="常数优化"></a>常数优化</h3><p>上面的写法虽然时间复杂度是正确的，但是对于这道题还是不够的：<br>例题：<a href="https://www.luogu.com.cn/problem/P4718" target="_blank" rel="noopener">【模板】Pollard-Rho算法</a></p>
<p>我们还需要一些常数优化，Pollard’s rho算法的瓶颈就在于需要多少次才能得到一个约数$p$，以及找不到约数的时候做$gcd$的时间。前者并不好优化（玄学），但是减少$gcd$的次数却是可以做到的。</p>
<p>一个普遍的做法就是利用倍增的思想，先走完$2^k$步以后把$|a-b|$乘积统一进行$gcd$，然后换一个起点继续增加步数。如果出现乘积为$0$就说明我们遇到环了，此时退出并寻找下一个随机数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">pollard_rho</span><span class="params">(ll x)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll c = (ll)mt() % (x - <span class="number">1</span>) + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll s = <span class="number">0</span>, t = (ll)mt() % (x), val = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// i是步长</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;; i &lt;&lt;= <span class="number">1</span>, s = t, val = <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">1</span>; z &lt;= i; z++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            t = f(t, c, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            val = modmul(val, <span class="built_in">abs</span>(t - s), x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 如果遇到环了</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!val) <span class="keyword">return</span> x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 为了避免步数过长导致出不来结果，所以手动设定每127步计算一次</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!(z % <span class="number">127</span>)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ll g = __gcd(val, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (g &gt; <span class="number">1</span>) <span class="keyword">return</span> g;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll g = __gcd(val, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (g &gt; <span class="number">1</span>) <span class="keyword">return</span> g;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>随机化</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>素数判定</title>
    <url>/2019/12/31/prime-test/</url>
    <content><![CDATA[<blockquote>
<p>定义：对于一个大于$1$的正整数$p$，如果$p$是质数/素数，那么对于所有$a|p$，$a$要么是$1$，要么是$p$。</p>
</blockquote>
<p>那么对于一个数$x$，我们如何让计算机去判定它是不是质数/素数呢？</p>
<a id="more"></a>
<h1 id="素数判定"><a href="#素数判定" class="headerlink" title="素数判定"></a>素数判定</h1><h2 id="朴素方法"><a href="#朴素方法" class="headerlink" title="朴素方法"></a>朴素方法</h2><p>根据定义，我们只需要判断这个数$x$，除了$1$和$x$以外还有没有其他约数就好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(ll x)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt; x; i++) </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>这个算法的时间复杂度是$O(n)$，在极端情况下，$x$是质数的时候就需要扫遍$2~x$之间的所有值。但是实际上，我们并不需要扫到$x$，为什么呢？</p>
<p>考虑当$x$有一个约数$a$，$a|x$，那么一定有$\frac{x}{a}|x$。也就是说，每个约数都是对称的，对称中心就是$\sqrt{x}$。当$a\leq \sqrt{x}$存在一个对于$x$的约数的时候，$a &gt; \sqrt{x}$一定也存在一个$\frac{x}{a}$，反之则不存在。所以我们只需要扫到$\sqrt{x}$就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(ll x)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i * i &lt;= x; i++) </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>这个算法的时间复杂度是$O(\sqrt{n})$，还不错。</p>
<h2 id="筛法"><a href="#筛法" class="headerlink" title="筛法"></a>筛法</h2><p>但是在算法竞赛里面，经常有一类问题需要你对给出的$Q$个查询进行回答。此时如果查询范围很大，而次数又很多的话，上面的方法就会超时。</p>
<p>这时候就引出我们的埃氏筛/线性筛法。我们不从$x$出发去判断$x$是不是质数，而是从比较小的数开始，依次划掉这个数的倍数。因为质数的倍数一定不是质数（都有倍数了还怎么是质数），那么没有划掉的就是质数，直接$O(1)$判定即可。实现也非常简单</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> notprime[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> maxn)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxn; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (notprime[i]) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">2</span>; j &lt;= maxn; j += i) notprime[j] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>我之所以把数组定义成<code>notprime</code>是因为这样就不用把数组都初始化为$1$了。<br>这个算法的时间复杂度是多少呢？我们可以这样考虑，只有质数会进入第二个循环，而它会划掉所有它的倍数。那么也就是说，每个数最多会被划掉质因数个数那么多次。我们把一个数的质因数分解表示为$\prod_{k} p_k^{\alpha_k}$，则极端情况下，假设有$k$个不同质因数，则$n$的范围会是$2\times 3\times \dots \times p_k \geq k!$。而$k!$根据斯特林公式有<br>$$<br>n! \approx \sqrt{2\pi n}\bigg(\frac{n}{e}\bigg)^n \leq n^n<br>$$<br>那么$k$相对于$n$就是$O(\log{\log{n}})$级别的了，所以总复杂度是$O(n\log{\log{n}})$。这个复杂度与线性几乎没有差别了，虽然还有更高级的$O(n)$线性筛，但是这不是重点。</p>
<h2 id="Miller–Rabin-素性测试"><a href="#Miller–Rabin-素性测试" class="headerlink" title="Miller–Rabin 素性测试"></a>Miller–Rabin 素性测试</h2><p>Miller-Rabin 素性测试是一个更高级的素数判定算法，为什么叫素性测试呢？因为这个算法也很难保证一定能测出这个数是不是质数，只能说它很像质数，有多像呢？非常非常像。</p>
<p>但是对于算法竞赛的数据范围来说，这个算法是可以<strong>准确</strong>判定出这个数是不是质数的。</p>
<h3 id="Fermat小定理"><a href="#Fermat小定理" class="headerlink" title="Fermat小定理"></a>Fermat小定理</h3><blockquote>
<p>如果$p$是质数，对于一个数$a \in [1, p-1]$，有<br>$$<br>a^{p-1} \equiv 1\pmod{p}<br>$$</p>
</blockquote>
<p>如果我们想知道$n$是否是素数，我们在中间选取$a$，看看上面等式是否成立。如果$a^{n-1} \not\equiv 1\pmod{n}$，那么$n$一定不是质数。但是注意，这个定理的逆命题不一定成立，也就是说，$a^{n-1} \equiv 1\pmod{n}$不一定表示$n$是质数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fermat</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> n == <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= TEST_TIME; ++i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> a = rand() % (n - <span class="number">2</span>) + <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 快速幂求得a^&#123;n-1&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (fastExp(a, n - <span class="number">1</span>, n) != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>事实上，有一类数满足</p>
<blockquote>
<p>$n$是合数，对于与$n$互质的数$b$，$b^{n-1}\equiv 1\pmod{n}$</p>
</blockquote>
<p>这样的数被称为Carmichael数，是费马测试的大敌，但是由于Carmichael比质数少得多，所以仍然有方法去应对它。它的一个等价定义：</p>
<blockquote>
<p>一个正合成数$n$是卡迈克尔数，当且仅当$n$无平方数约数且对于所有$n$的素因数$p$，$p-1|n-1$。</p>
</blockquote>
<h3 id="二次探测定理"><a href="#二次探测定理" class="headerlink" title="二次探测定理"></a>二次探测定理</h3><p>假设我们有$x^2 \equiv 1\pmod{p}$，$p$为素数，那么该式子可以化为<br>$$<br>(x - 1)(x + 1) \equiv 0\pmod{p}<br>$$<br>那么$p$能整除$(x - 1)(x + 1)$，此时$(x-1)$或者$(x+1)$能被质数$p$整除，有$x \equiv 1\pmod{p}$或者$x\equiv-1\pmod{p}$。</p>
<p>那么我们假设$n&gt;2$是个质数，那么它一定是个奇数，且$n-1$一定可以被写成$d2^s$的形式，其中$s$是正整数，$d$是奇数。根据费马小定理，那么就有$a^{d2^s} \equiv1\pmod{n}$，同时，根据以上性质，对于$i \in [1, s-1]$，有<br>$$<br>    a^{d2^i} \equiv-1\pmod{n}\\<br>    a^d \equiv 1\pmod{n}<br>$$<br>所以我们可以不断对$a^{n-1}$取平方根后，判断是否出现不符合以上性质的根就知道它是否像质数了。同样，这个引理的逆命题也存在反例，但是由于Carmichael数的性质，它通不过平方探测，所以与费马小定理结合起来效果很不错。</p>
<p>但是即使这样，我们也只能说像是质数，事实上Miller–Rabin有$4^{-k}$的错误率，$k$是选取的基数$a$的数量。好消息是，在算法竞赛范围内$n\leq2^{64}$，选取$8$个素数作为基数就可以准确判定了。</p>
<p>时间复杂度：算法竞赛内用<code>__int128_t</code>可以达到$O(k\log{n})$，但是对于大整数一般是$O(k\log^3{n})$，可以用$FFT$优化到$O(k\log^2{n}\log{\log{n}}\log{\log{\log{n}}})$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">modmul</span><span class="params">(ll a, ll b, ll p)</span> </span>&#123; <span class="keyword">return</span> (<span class="keyword">__int128_t</span>)a * (<span class="keyword">__int128_t</span>)b % p; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">fastExp</span><span class="params">(ll x, ll p, ll mod)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    x %= mod;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll ans = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (p) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>) ans = modmul(ans, x, mod);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        x = modmul(x, x, mod);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">miller_rabin</span><span class="params">(ll x)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (x == <span class="number">2</span> || x == <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span> || !(x &amp; <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll <span class="built_in">pow</span> = <span class="number">0</span>, u = x - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (!(u &amp; <span class="number">1</span>)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">pow</span>++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> p = primes[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (p &gt;= x) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll v = fastExp(p, u, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (v == <span class="number">1</span> || v == x - <span class="number">1</span>) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (; j &lt; <span class="built_in">pow</span>; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            v = modmul(v, v, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (v == x - <span class="number">1</span>) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (j == <span class="built_in">pow</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>例题：<a href="https://loj.ac/problem/143" target="_blank" rel="noopener">质数判定</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>[CF1097D] Makoto and a Blackboard</title>
    <url>/2019/12/25/CF1097D/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>一开始有一个整数$n(n\leq 10^{15})$，你可以执行以下操作$k(k\leq 10^4)$次：把$n$替换成$n$的任意一个约数(包括$1$和$n$)，假设每个约数都有相同概率被选中。现在问你$k$次操作后剩下这个数的期望值是多少。</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>我们知道期望公式为$\sum{x*p(x)}$，在这道题中，由于$x$的范围是离散且确定的，我们只需要知道每个$x$出现的概率就行了。</p>
<p>我们可以画一张图来看看转移的过程，以$6$为例：<br><img src="/uploads/cf1097d1.png" width="30%" height="30%"></img><br>我们可以得出几个有用的信息：</p>
<ul>
<li>图中所有节点都为原数$n$的约数</li>
<li>每个节点只会转移到小于等于它的数</li>
<li>因为$k$有限，这个流程可以直接模拟</li>
</ul>
<p>于是我们就可以用动态规划，令$f(i, x)$为第$i$轮时，得到数字为$x$的概率，可得：<br>$$<br>    f(i + 1, y) = f(i + 1, y) + f(i, x) * \frac{1}{|d(x)|} (y \in d(x))<br>$$<br>于是这题就解决了……</p>
<p>但是等等，这个玩意复杂度是多少呢？我们花$O(\sqrt{n})$预处理出来约数，约数个数大约是$O(\log{n})$，都在时间范围内。状态数量是$O(k\log{n})$，转移是$O(\log{n})$，合在一起$O(k\log^2{n})$但是交上去会T掉，为什么呢？</p>
<p>因为因数个数虽然是$O(\log{n})$，但是常数巨大，一般来说一个数的质因数分解可以表示为$\prod_k{(p_k^{\alpha_k})}$那么它会有$\prod_k{(\alpha_k+1})$个因数。</p>
<p>那么假如我给出$n=2^{20}\times3^{20}$，足足会有$21\times21=441$个因数，那么$10^4\times441^2=1.6*10^9$这不T到天上去？<br>那么接下来就要引出我写这篇博客的意义了，首先把我们刚刚得到的递推式优化一下。<br>$$<br>    f(i+1, y) = \sum_{ky|n} \frac{f(i, ky)}{|d(ky)|}<br>$$<br>而形如$g(n) = \sum_{d|n} f(d)$这类函数给我们的提示就是它很有可能是积性的，由于地方太小就不写证明了。当$f(i, x)$是积性函数的时候，$f(i,x)=\prod_{k} f(i, p_k^{\alpha_k})$。于是我们可以分别计算对于$n$的每个质因数的$f(i, p^{\alpha_k})$，然后把他们乘起来。此时时间复杂度为$O(k\sum{\alpha_i^2})$，此前为$O(k\prod{(\alpha_i+1)})$，对于$2^{20}\times3^{20}$来说，只需要$10^4\times800=8\times10^6$，是一个巨大的提升。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>$O(k\sum{\alpha_i^2})$</p>
<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll x = n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 获取质因数以及其指数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i &gt; x) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (x % i == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            x /= i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cnt++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (cnt) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            divs.push_back(&#123;i, cnt&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) divs.push_back(&#123;x, <span class="number">1</span>&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll ans = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 最外层是每个质因数p^i形式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> pair : divs) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> cnt = pair.second;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 滚动数组优化空间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">memset</span>(dp[<span class="number">0</span>], <span class="number">0</span>, <span class="keyword">sizeof</span>(dp[<span class="number">0</span>]));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dp[<span class="number">0</span>][cnt] = <span class="number">1L</span>L;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 从这里开始是每个状态的转移</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">memset</span>(dp[(i &amp; <span class="number">1</span>) ^ <span class="number">1</span>], <span class="number">0</span>, <span class="keyword">sizeof</span>(dp[<span class="number">0</span>]));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= cnt; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= j; s++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    dp[(i &amp; <span class="number">1</span>) ^ <span class="number">1</span>][s] +=</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        getInv(j + <span class="number">1</span>, MOD) * dp[i &amp; <span class="number">1</span>][j] % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (dp[(i &amp; <span class="number">1</span>) ^ <span class="number">1</span>][s] &gt; MOD) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        dp[(i &amp; <span class="number">1</span>) ^ <span class="number">1</span>][s] -= MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll tmp = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll pw = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cnt; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            tmp += (pw * dp[k &amp; <span class="number">1</span>][i] % MOD);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (tmp &gt; MOD) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                tmp -= MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            pw = pw * pair.first % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ans = (ans * tmp) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>概率期望</tag>
        <tag>动态规划</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>[SDOI2009] 虔诚的墓主人</title>
    <url>/2019/12/10/SDOI09Grave/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>一个$N \times M (N, M \leq 10^9)$的地图上有$W (W \leq 10^5)$棵树。对于图上没有树的点，如果在这个点上下左右都至少有$k (1 \leq k \leq 10)$个点，那么它会贡献${L\choose{k}} *  {R\choose{k}} * {U\choose{k}}* {D\choose{k}}$点虔诚度，问这个地图上所有虔诚度之和模$2147483648$（有毒）的值。</p>
<a id="more"></a>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题意很清晰，但是$N,M$的规模过于庞大，普通的模拟肯定不行了。但是我们注意到$W$的值并没有很大，所以实际上能贡献虔诚度的点只有$O(W^2)$个。但是这么多点一个个统计仍然太多了，所以很自然的我们想到了用扫描线法。</p>
<p>扫描线的统计仍然不是很直观，所以我们需要画一个图，假设我们现在的地图是这样的：<br><img src="/uploads/sdoi09grave1.png" alt="初始地图"><br>那么显然中间那个点是一个可以统计的点，如果我们记某个点$p$上方的树的数量为$U(p)$，下方为$D(p)$，左右分别为$L(p), R(p)$。那么这个点的虔诚度为${L(p)\choose{k}} *  {R(p)\choose{k}} * {U(p)\choose{k}}* {D(p)\choose{k}} = 1$。如果我们再加两个点，然后把目光集中在那根竖线上：<br><img src="/uploads/sdoi09grave3.png" alt="初始地图"><br>我们可以发现可以贡献虔诚度的点会在竖线的线段与其左右两边的横线的交点上。除此之外，我们知道在这条竖线（不包括两端）上的点$U(p)$和$D(p)$的值是完全相等的。如果我们回到那个公式，统计所有点的贡献：<br>$$<br>\begin{align}<br>S &amp; = \sum_{p} {L(p)\choose{k}} *  {R(p)\choose{k}} * {U(p)\choose{k}}* {D(p)\choose{k}}\\<br>&amp; = {U(p)\choose{k}} * {D(p)\choose{k}} * \bigg(\sum_{p} {L(p)\choose{k}} *  {R(p)\choose{k}}\bigg)<br>\end{align}<br>$$<br>根据求和公式的分配率可以推出来。这个公式意味着我们可以先得出一段竖线的${U(p)\choose{k}} * {D(p)\choose{k}}$值，然后乘以这个竖线区域所包含的所有横线的${L(p)\choose{k}} *  {R(p)\choose{k}}$就是这个区域所有的虔诚度贡献。竖线上的$U(p)$和$D(p)$可以通过从上到下以及预处理的方式求出来，现在问题在于怎么求出竖线上的横线贡献的$L(p), R(p)$：<br>$$<br>\sum_{i = l}^{r} {L(p[i])\choose{k}} *  {R(p[i])\choose{k}}<br>$$<br>可以看出这其实是一个区间查询问题，对于横线来说$L(p), R(p)$也可以通过从左到右的方式算出来，但是问题是每个横线区域与竖线的位置是密切相关的，随着向右边移动而变化：<br><img src="/uploads/sdoi09grave4.png" alt="扫描线"><br>这个时候扫描线的优势就出来了，我们可以把所有树的位置按照$x$坐标排序，如果$x$坐标相同则按照$y$坐标排序。然后我们从左到右，从上到下扫描，先统计个数，再更新横线的$L(p), R(p)$，最后把${L(p[i])\choose{k}} *  {R(p[i])\choose{k}}$放进区间查询的数据结构里面。因为这个虔诚度是可以加起来的所以区间查询用树状数组就足够了。<br><img src="/uploads/sdoi09grave5.gif" alt="动态演示"></p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(W\log{W})$，分别在排序和树状数组查询上。</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cntX[MAXN * <span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cntY[MAXN * <span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> curY[MAXN * <span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">FenwickTree tree;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> tot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tot);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 组合数打表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= min(i, <span class="number">10</span>); j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            C[i][j] = (C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> x, y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        points[i].x = x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        points[i].y = y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        discrete.add(x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        discrete.add(y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    discrete.discretize();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sort(points, points + tot);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cnt++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i == tot || points[i].x != points[i + <span class="number">1</span>].x) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> xx = discrete.get(points[i].x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 横坐标为xx的点共有多少个</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            cntX[xx] = cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cnt = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        points[i].x = discrete.get(points[i].x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        points[i].y = discrete.get(points[i].y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 纵坐标为y的点共有多少个</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        cntY[points[i].y]++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll ans = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> curX = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 当前y坐标左边有多少个点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        curX++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i &amp;&amp; points[i].x != points[i - <span class="number">1</span>].x) curX = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i != tot &amp;&amp; points[i].x == points[i + <span class="number">1</span>].x) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> l = points[i].y, r = points[i + <span class="number">1</span>].y - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (l &lt; r) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ll U = choose(curX, k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ll D = choose(cntX[points[i].x] - curX, k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ll sum = ((tree.getSum(r) - tree.getSum(l)) % MOD + MOD) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ans = (ans + (sum * U % MOD) * D % MOD) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        curY[points[i].y]++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll now = choose(curY[points[i].y], k) *</span></pre></td></tr><tr><td class="code"><pre><span class="line">                 choose(cntY[points[i].y] - curY[points[i].y], k) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll pre =</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ((tree.getSum(points[i].y) - tree.getSum(points[i].y - <span class="number">1</span>)) % MOD +</span></pre></td></tr><tr><td class="code"><pre><span class="line">             MOD) %</span></pre></td></tr><tr><td class="code"><pre><span class="line">            MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 注意只计算当前的总和，而不是之前的所有和</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        tree.increase(points[i].y, (now - pre + MOD) % MOD);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>扫描线</tag>
        <tag>组合数学</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>二分法杂谈</title>
    <url>/2019/12/09/binary-search/</url>
    <content><![CDATA[<p>学算法一年了，做了很多题，但是对于二分法这块一直不是很明白。 有时候遇到二分答案的问题经常要调好长时间才能写对，有些时候就是看别人二分是怎么写的就照抄，但是并不清楚为什么这么写是对的。今天总结了一下二分法的几种情况以及它们的思路。</p>
<a id="more"></a>

<h2 id="二分的写法"><a href="#二分的写法" class="headerlink" title="二分的写法"></a>二分的写法</h2><p>网上的二分法普遍有两种写法，一种是左闭右开<code>[l, r)</code>的写法，一种是左闭右闭<code>[l, r]</code>的写法。左闭右开写法的优点是上下界比较宽松，不会出现死循环，而且最终答案$l,r$都可以用。但是缺点就是对于将要介绍的四种情况，转移时的$\pm 1$的位置变换很令人头疼。所以这里我将要使用的是后一种方式，但是左闭右闭一定要注意转移的写法<code>l = mid + 1</code>和<code>r = mid - 1</code>，此时$\pm 1$都是固定的，但是最优解可能不在区间内，所以需要一个外层变量<code>ans</code>来确保得到的是最优解。这种写法的优点是非常好想。</p>
<h2 id="二分法四种情况"><a href="#二分法四种情况" class="headerlink" title="二分法四种情况"></a>二分法四种情况</h2><p>需要二分答案的时候，要先确保数据具有单调性。也就是说给定一个集合$S$，里面有一个需要寻找的答案，那么有：如果$S_i$满足条件，那么所有$S_j(j\geq i)$（或者$j\leq i$），都满足条件，并且如果$S_i$不满足条件，则所有$S_j(j&lt;i)$（或者$j&gt;i$）都不满足条件，那么这个数据就具有单调性。</p>
<p>在单调的数据下，我们需要找一个满足条件的答案就可以用二分法。我们都学过二分搜索查找一个数，但是有时候我们不是查找一个数，而是找一个满足条件的最小/最大值呢？如果满足条件值并不存在呢？我们把所有情况分成四种以便区分。假设数据是一个非降序列，那么他们分别是：不小于条件最小位置，严格大于等于条件最小位置，不大于条件的最大位置，严格小于条件的最大位置。</p>
<h3 id="不小于条件最小位置"><a href="#不小于条件最小位置" class="headerlink" title="不小于条件最小位置"></a>不小于条件最小位置</h3><p>假如给定一个非降序列：$S={1,1,4,4,5,6,7,8}$，假如我们想知道$S_i \geq 3$的最小位置，在此处显然是位置$3$，而不是位置$4$。在这种情况下，我们二分法找到$S_i$满足$S_i \geq 3$以后仍然要往更小的范围去寻找，这样才能保证是最小位置，那么在二分写法里面，就是将$r$的值缩小，那么最后一个满足条件的$mid$就是答案。由此可得一个写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans = n + <span class="number">1</span>; <span class="comment">// 如果目标不存在就返回一个不存在的位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= k) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        	ans = min(ans, mid);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            r = mid - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            l = mid + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="严格大于条件最小位置"><a href="#严格大于条件最小位置" class="headerlink" title="严格大于条件最小位置"></a>严格大于条件最小位置</h3><p>我们换一个非降序列：$S={1,1,3,4,5,6,7,8}$，假如我们想知道$S_i &gt; 3$的最小位置，那么我们可以看出应该是位置$4$，那么我们只需要把<code>if (arr[mid] &gt;= k)</code>改成<code>if (arr[mid] &gt; k)</code>就行了。</p>
<h3 id="不大于条件的最大位置"><a href="#不大于条件的最大位置" class="headerlink" title="不大于条件的最大位置"></a>不大于条件的最大位置</h3><p>假设这个序列是$S={1,1,3,3,3,6,7,8}$，然后我们要找一个$S_i \leq 3$的最大位置，那么我们可以看出应该是位置$5$。在此条件下，如果我们找到一个$S_i \leq 3$我们仍然需要往后找以确保能找到最大位置。那么在二分写法里面就是将$l$增大，那么我们只需要在此时找到最大的那个$mid$就是答案，写法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="comment">// 如果目标不存在就返回一个不存在的位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (arr[mid] &lt;= k) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        	ans = max(ans, mid);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            l = mid + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            r = mid - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="严格小于条件最大位置"><a href="#严格小于条件最大位置" class="headerlink" title="严格小于条件最大位置"></a>严格小于条件最大位置</h3><p>我们只需要把<code>if (arr[mid] &lt; k)</code>改成<code>if (arr[mid] &lt;= k)</code>就行了。</p>
<h3 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h3><p>对于序列并非升序的情况，我们可以将它转化为升序思考。绝大部分二分的题都可以归结为这四种情况，像最大的最小值就是满足条件的最大位置，最小的最大值就是满足条件的最小位置。只要想清楚自己想要二分出来的答案是什么样的就可以轻松A掉题了。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>二分法</category>
      </categories>
      <tags>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>[ICPC NAQ2018] Problem L: Longest Life</title>
    <url>/2019/12/04/NAQ18L/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>正常情况下每分钟你的生命就会流失一分钟（废话），但是现在科技这么发达你有（$N \leq 10^5$）次改变生命流失速度的机会，这些机会会出现在$N$个不同的时间点上。但是如果你改变了生命流失速率，那么你就会瞬间流失 $C$ 分钟的生命。如果你能够自由选择是否接受这些机会，问你最晚的死亡时间是什么时候。</p>
<a id="more"></a>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>如果用动态规划的方式去求解，那么可以很容易得到一个DP方程，如果我们设 $f(i) =$ 以第$i$个药片作为最后使用的药片的最晚死亡时间。那么转移方程就应该是：<br>$$f(i) = \max \{g(i, k)\} \ (0 \leq k &lt; i)$$</p>
<p>$g(i, k)$就表示之前使用了第$k$个药片，换成第$i$个药片以后所能存活的最长时间。如果我们把整个过程看做一个线性函数斜率不断改变的过程，那么$y$坐标就是不做改变应该存活的时间，而$x$轴就代表实际存活的时间。于是有图</p>
<p><img src="/uploads/naq18L1.png" alt="药剂效果"></p>
<p>我们要求的就是两个直线触及天花板的那个点的横坐标。</p>
<p>假设一开始死亡时间为$T$，药片出现时间为$t[i]$，改变的斜率为$k[i]$，那么有</p>
<p>$$g(i, k) = t[i] +  \frac{T-\text{使用i时的高度}}{k[i]}$$</p>
<p>合并到DP方程展开后就是：<br>$$<br>f(i)= \max \bigg( t[i]+\frac{T-(k[j]t[j]+T-k[j]f(j)+k[j](t[i]-t[j]) + C)}{k[i]} \bigg)<br>$$<br>化简一下<br>$$<br>f(i)= \max \bigg( t[i]-\frac{C+k[j](t[i]-f(j))}{k[i]} \bigg)<br>$$<br>其中$1 \leq k&lt;i$，如果看不懂的话手动推一下就好了。</p>
<p>但是观察一下数据范围，$10^5$ 显然对于这个$O(N^2)$ 的DP来说太大了，但是我们观察到$t[i]$是单调上升的，而且对于进来的不同$k[i]$，有一部分斜率比之前最小值要大的显然不能构成最优解，也就是说，这里面$j$的选择是可以优化的。那么如果想让程序不超时，我们需要一个$O(1)$的最优解选择方法，那么就要想到斜率DP。</p>
<p>我们继续优化这个式子，假设现在有两个药片$s, j$且$s &lt; j &lt; i$。那么假设$j$是比$s$更优的选择，那么一定满足：<br>$$t[i]&gt; \frac{k[s]f(s)-k[j]f(j)}{k[s]-k[j]}$$<br>当这个条件满足的时候，我们知道选择第$j$个药片比第$s$个药片要优。<br>如果我们定义$slope(s, j) = $上面这个式子，也就是相当于点$s$到点$j$的斜率，那我们需要判断满足这个条件的点具有的特征。假设对于三个点$s &lt; j &lt; i$并且$slope(s, j) &gt; slope(j, i)$，那么我们可以判断点$j$一定不会形成最优解。<br>剩下的就是用单调队列维护下凸包的操作了，但是要注意不要把$k[i]$不单调的点也算进去，具体见代码。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(N)$，因为每个元素只会进队列一次，出列一次。</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里我用了long double来防止精度不够</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> LD;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pill</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LD ks;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Pill() &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Pill(ll t, ll x, ll y) : t(t), ks(y / (LD)x) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Pill&amp; b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> t &lt; b.t; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Pill&gt; pills;</span></pre></td></tr><tr><td class="code"><pre><span class="line">LD dp[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟了一个队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> QQ[MAXN * <span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 斜率计算</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">LD <span class="title">slope</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> j)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> (pills[j].ks * dp[j] - pills[s].ks * dp[s]) /</span></pre></td></tr><tr><td class="code"><pre><span class="line">           (pills[j].ks - pills[s].ks);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;n, &amp;m, &amp;k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll t, x, y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;t, &amp;x, &amp;y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pills.emplace_back(t, x, y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pills.emplace_back(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sort(pills.begin(), pills.end());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dp[<span class="number">0</span>] = n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    QQ[<span class="number">1</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LD minn = <span class="number">1e30</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (pills[i].ks &gt;= minn) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; slope(QQ[l], QQ[l + <span class="number">1</span>]) &lt;= pills[i].t) ++l;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> opt = QQ[l];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        LD ki = pills[i].ks;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        LD kj = pills[opt].ks;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 根据公式从dp[j]计算dp[i]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        LD newx = (LD)pills[i].t - (k + kj * (pills[i].t - dp[opt])) / ki;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dp[i] = max(dp[i], newx);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; slope(QQ[r - <span class="number">1</span>], QQ[r]) &gt;= slope(QQ[r], i)) r--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        QQ[++r] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        minn = min(minn, pills[i].ks);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LD ans = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ans = max(ans, dp[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.7Lf"</span>, ans);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>斜率DP</tag>
      </tags>
  </entry>
  <entry>
    <title>[洛谷P3067] 平衡的奶牛群</title>
    <url>/2019/12/04/LuoguP3067/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你$n(n\leq20)$个数，从中任意选出一些数，记为集合$S$，使得存在一种$s \in S$满足$sum(s) == sum(\bar{s})$。求这样的选数方案有多少种。</p>
<a id="more"></a>

<p>介绍一种解这道题的新思路：利用$bitset$。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>先从暴力算法开始，我们只需要枚举所有集合以及他们的子集，如果发现子集以及其补集的和相等，那么这个集合就是一种方案。</p>
<p>更具体的说，假设$P$是原集合，$S$是$P$的所有子集。如果对于所有$s \in S$ 的子集有 $sum(s) == sum(\bar{s})$，那么$S$就贡献一个答案。</p>
<p>于是我们可以写出如下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s1 = i; s1; s1 = (s1 - <span class="number">1</span>) &amp; i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (sum[s1] == sum[i ^ s1]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ans++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>子集求和是$O(n2^n)$但是枚举子集的子集是$O(3^n)$的，显然会TLE的死死的。</p>
<p>于是我们会想到折半枚举，假设我们能枚举前一半和后一半的所有子集，那么应该怎么确定哪些子集是符合条件的呢？</p>
<p>假设对于一个集合$S_1$我们有一个子集$s_1$和补集$\bar{s_1}$，同时我们有另一个集合$S_2$和子集$s_2$和$\bar{s_2}$，如果这个集合能合并，那么我们需要有</p>
<ul>
<li>$S_1 \cap S_2 = \emptyset$</li>
<li>$sum(s_1) + sum(s_2) == sum(\bar{s_1}) + sum(\bar{s_2})$</li>
</ul>
<p>第一个条件用折半枚举可以保证。对于第二个来说，假设我们有$sum(s_1)-sum(\bar{s_1})=d$，那么如果$sum(\bar{s_2})-sum(s_2)=d$，那么就满足了第二个条件。</p>
<p>于是我们可以枚举左边的所有可能，然后记录有多少个集合具有差值$d$。然后在枚举右边的时候，对于每个右边子集，找到它的子集总共能匹配多少个左边子集。为了表述清晰，设$S_l$为左边集合的子集，$S_r$为右边集合的子集。对于每个右边集合的子集$s_r \subset S_r$，以及它的子集$ss_r \subset s_r$，我们要求：<br>$$<br>    \sum_{s_r}|\bigcap_{ss_r\in s_r}{s_l\text{使得}ss_r\text{可以与左边合并}}|<br>$$</p>
<p>所以我们要求差值为$d$集合的并集，但是集合个数有$2^{\frac{n}{2}}$个，无法用状态压缩($int$和long long)表示。于是我们就想到了使用$bitset$，$2^{\frac{n}{2}}$在这道题中仅有$1024$，$bitset$实现中每个集合所占空间仅有$\frac{1024}{8} = 128$字节。</p>
<p>我们再来计算一下总共可能会有多少种差值，不好计算但是可以估算出是小于$3^{10}=6\times10^4$的，也就是最坏也只是$sum$数组的内存级别。</p>
<p>于是我们只要维护一个<code>map&lt;int,bitset&lt;1024&gt;&gt;</code>就可以了。</p>
<p>以下是这种解法对应的代码：</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>折半枚举的复杂度是$3^{n/2}$，另一半查询的复杂度是因为有map所以是$\log$级别。<br>加上预处理以后的时间复杂度<br>$$<br>O(n2^n+3^{\frac{n}{2}}\log{3^{\frac{n}{2}}})<br>$$</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">25</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, k;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum[(<span class="number">1</span> &lt;&lt; <span class="number">20</span>) + <span class="number">5</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">bitset</span>&lt;1024&gt;&gt; mpp;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 求出所有子集的和</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> ((i &gt;&gt; j) &amp; <span class="number">1</span>) sum[i] += arr[j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 枚举左边</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> mid = n / <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; mid); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s1 = i;; s1 = (s1 - <span class="number">1</span>) &amp; i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            mpp[sum[s1 ^ i] - sum[s1]].<span class="built_in">set</span>(i, <span class="literal">true</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!s1) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 枚举右边</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; (n - mid)); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">bitset</span>&lt;1024&gt; sss(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 这里我刻意保留了子集为空的情况</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s1 = i;; s1 = (s1 - <span class="number">1</span>) &amp; i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> diff = sum[s1 &lt;&lt; mid] - sum[(s1 ^ i) &lt;&lt; mid];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            sss |= mpp[diff];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!s1) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 对答案的贡献就是这个集合的大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        ans += sss.count();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 要减去左边右边都是空集的情况</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans - <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>中途相遇/折半枚举</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>[CF1238E] Keyboard Purchase</title>
    <url>/2019/12/04/CF1238E/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你一个文本串$S(len(S) \leq 10^5)$，由前$m(m\leq20)$个小写字母组成。要你求一种键盘的排列，使得打出这个文本串的消耗最小。这个消耗$cost$的计算方式为相邻字符的键盘距离之和，也就是$\sum_{i=2}^{n} |pos_{s_i-1}-pos_{s_i}|$。只需要输出这个最小消耗就行。</p>
<a id="more"></a>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>打比赛时候以为是一道贪心题，结果怎么做都不对，后来看到$(m\leq20)$就在想状压DP，但是完全不会做这种对于排列的DP。因为无法确定这个字符应该插入到什么位置，也就没法计算$cost$。<br>赛后看题解才知道原来DP还可以有预先计算$cost$这种操作，那么公式也就很好想了。<br>我们先预处理文本串$S$中相邻字符对出现的次数。设$f(S)$为当前使用了集合为$S$的字符进行排列，所能产生的最小$cost$。当我们加入一个新字符的时候，我们除了计算当前最小值，还要把还没有使用过的字符与使用过的字符所产生的$cost$也加进去，由此可得：<br>$$<br>\begin{aligned}<br>f(S) &amp;=\min\{f(S-\{j\})\} &amp; [j\in S]\\<br>f(S) &amp;= f(S) + cost(i, j) &amp; [i \in S,j\in \overline{S}]\\<br>\end{aligned}<br>$$<br>那么整体最小值就是$f(S的全集)$了。<br>顺便吐槽一下状压$O(m^22^m)$都$4\times10^8$了，结果$CF$神机居然$0.5$秒就跑出来了也是可以，我还以为会超时。。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(m^22^m+S)$</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录点对的数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt[<span class="number">25</span>][<span class="number">25</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">ll dp[(<span class="number">1</span> &lt;&lt; <span class="number">20</span>) + <span class="number">5</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, text);</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">char</span> a = text[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">char</span> b = text[i + <span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (a == b) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cnt[a - <span class="string">'a'</span>][b - <span class="string">'a'</span>]++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cnt[b - <span class="string">'a'</span>][a - <span class="string">'a'</span>]++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dp));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; (<span class="number">1</span> &lt;&lt; k); s++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> ((s &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                dp[s] = min(dp[s], dp[s ^ (<span class="number">1</span> &lt;&lt; i)]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!((s &gt;&gt; i) &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// 未访问的点的贡献</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> ((~s &gt;&gt; j) &amp; <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    dp[s] += cnt[i][j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[(<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>状态压缩DP</tag>
      </tags>
  </entry>
  <entry>
    <title>[ICPC NAQ2019] Problem L: Traveling Merchant</title>
    <url>/2019/12/03/NAQ19L/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>一条线上有$N(N\leq10^5)$个城市，标号从$1$到$N$。每个城市物价根据星期的不同而有所不同，具体来说，每个城市有原价$v_i$，变动$d_i$，周一到周日的变化量为$\{+0, +v_i, +2v_i, +3v_i, +2v_i, +v_i, +0\}$。现在有$Q(\leq 10^5)$个询问，每个询问商人会从$l$号城市往$r$号城市旅行，$l$有可能大于$r$，此时要逆行。求次旅行最大的差价$(price_j-price_i)$其中$(j &gt; i)$是多少。</p>
<a id="more"></a>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>$10^5$数据量+$10^5$查询，那么很明显直接模拟是不行的，但是这题题意看起来用线段树也不太好维护（有可能是我太菜了不会）。于是有没有又好维护跑的又快的数据结构呢？于是祭出分块大法。</p>
<p>我们可以把所有城市按照标号分成$\sqrt{N}$块，每一块内存储3个信息:<br>$$\{整块内最大价格，整块内最小价格，整块内最大差价\}$$<br>这样查询的时候可以两端直接模拟，中间根据这三个信息更新最大差价，每次查询复杂度不会超过$O(\sqrt{N})$。</p>
<p>由于有星期这个设定，所以我们要维护$7$重块，每个块信息代表当从第$k$天开始从左到右（反向旅行同理）旅行的信息。这个问题便迎刃而解了，看官方题解好像是用的线段树，但是感觉应该很难写，我用分块一发就过了，线段树不知道要调多久。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(N+Q\sqrt{N})$</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100005</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, k;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Info</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> v, d, b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 块信息，最大值，最小值，最大差值，左右延伸范围</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> maxx;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> minn;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> maxprofit;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> lft;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> rgt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> raise[<span class="number">7</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> CASE;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 正向旅行块</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Block blocks[<span class="number">7</span>][<span class="number">505</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 反向旅行块</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Block blocks2[<span class="number">7</span>][<span class="number">505</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> B;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Info cities[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 正向计算</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> d, <span class="keyword">int</span>&amp; maxx, <span class="keyword">int</span>&amp; minn, <span class="keyword">int</span>&amp; maxprofit)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt;= r; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> day = (j - l + d) % <span class="number">7</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> price = cities[j].v + raise[day] * cities[j].d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        minn = min(minn, price);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        maxprofit = max(maxprofit, price - minn);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        maxx = max(maxx, price);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 反向计算</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal2</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> l, <span class="keyword">int</span> d, <span class="keyword">int</span>&amp; maxx, <span class="keyword">int</span>&amp; minn, <span class="keyword">int</span>&amp; maxprofit)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = r; j &gt;= l; j--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> day = (r - j + d) % <span class="number">7</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> price = cities[j].v + raise[day] * cities[j].d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        minn = min(minn, price);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        maxprofit = max(maxprofit, price - minn);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        maxx = max(maxx, price);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 同样也是一正一反</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query2</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> l)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> d = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> maxx = <span class="number">0</span>, minn = <span class="number">1e9</span>, prof = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> rs = max(l, blocks2[<span class="number">0</span>][cities[r].b].lft);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cal2(r, rs, d, maxx, minn, prof);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    d = (d + r - rs + <span class="number">1</span>) % <span class="number">7</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cities[r].b - <span class="number">1</span>; i &gt;= cities[l].b + <span class="number">1</span>; i--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        prof = max(prof, blocks2[d][i].maxx - minn);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        minn = min(minn, blocks2[d][i].minn);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        prof = max(prof, blocks2[d][i].maxprofit);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        maxx = max(maxx, blocks2[d][i].maxx);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        d = (d + blocks2[d][i].rgt - blocks2[d][i].lft + <span class="number">1</span>) % <span class="number">7</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (cities[l].b != cities[r].b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> ls = min(r, blocks2[<span class="number">0</span>][cities[l].b].rgt);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cal2(ls, l, d, maxx, minn, prof);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> prof;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> d = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ls = min(r, blocks[<span class="number">0</span>][cities[l].b].rgt);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> maxx = <span class="number">0</span>, minn = <span class="number">1e9</span>, prof = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cal(l, ls, d, maxx, minn, prof);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    d = (d + ls - l + <span class="number">1</span>) % <span class="number">7</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cities[l].b + <span class="number">1</span>; i &lt;= cities[r].b - <span class="number">1</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        prof = max(prof, blocks[d][i].maxx - minn);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        minn = min(minn, blocks[d][i].minn);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        prof = max(prof, blocks[d][i].maxprofit);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        maxx = max(maxx, blocks[d][i].maxx);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        d = (d + blocks[d][i].rgt - blocks[d][i].lft + <span class="number">1</span>) % <span class="number">7</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (cities[l].b != cities[r].b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> rs = max(l, blocks[<span class="number">0</span>][cities[r].b].lft);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cal(rs, r, d, maxx, minn, prof);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> prof;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    B = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n) + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> cnt = (n + B - <span class="number">1</span>) / B;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;cities[i].v, &amp;cities[i].d);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cities[i].b = (i - <span class="number">1</span>) / B + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">7</span>; d++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 确定块的左右边界</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            blocks[d][i].lft = B * (i - <span class="number">1</span>) + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            blocks[d][i].rgt = B * i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            blocks2[d][i].lft = B * (i - <span class="number">1</span>) + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            blocks2[d][i].rgt = B * i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> l = blocks[d][i].lft, r = blocks[d][i].rgt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Block&amp; cur = blocks[d][i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cur.maxx = <span class="number">0</span>, cur.minn = <span class="number">1e9</span>, cur.maxprofit = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Block&amp; cur2 = blocks2[d][i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cur2.maxx = <span class="number">0</span>, cur2.minn = <span class="number">1e9</span>, cur2.maxprofit = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cal(l, r, d, cur.maxx, cur.minn, cur.maxprofit);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cal2(r, l, d, cur2.maxx, cur2.minn, cur2.maxprofit);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (m--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> l, r;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (l &lt;= r) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(l, r));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query2(l, r));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>[ICPC NAQ2019] Problem E: NVMLS</title>
    <url>/2019/12/03/NVMLS/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你$N$个大写字母组成的单词和一串大写非元音字母所组成的字符串（$L\leq 3\times 10^5$）。已知字符串$L$是由给出单词的非元音字母组成的，求将这个字符串还原回正常单词以后，元音字母数量最多的一个原串。数据保证$\sum_{i=0}^{n} len(s_i) \leq 10^5$。</p>
<a id="more"></a>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于模式串$L$和匹配串的数据很大，所以普通匹配肯定是不行的。可以考虑$AC$自动机或者Hash，但是我$AC$自动机写挂了所以改用$Hash$了。同时匹配结束以后我们还需要用$DP$来获取元音字母最多的还原串。<br>假设我们已经获取每个位置上的匹配串，假设位置$i$的所有匹配串为$m_i$，每个匹配串的元音字母数量为$v[j]$，匹配长度为$l[j]$。那么可得$DP$公式：<br>$$<br>f(i)=\max_{j \in m_i}\{f(i-l[j]+v[j])+v[j]\}<br>$$<br>那么$f(L)$就是最多的元音数量。因为题目要输出这个还原串，所以我们在$DP$的时候还要记录每一个状态是由哪一个匹配串转移而来的，这样就可以从后往前构造原串。</p>
<p>如果我们考虑这个$DP$的时间复杂度，会发现它很有可能是$O(NL)$的，显然会超时。但是仔细一想我们会发现，对于每一个位置，长度为$x$的匹配串有且仅能有一个，那么我们其实只需要枚举长度就好了。对于一个总长度不超过$N$的单词集合，长度的种类最多只有$O(\sqrt{N})$种。因为$\sum_{i=1}^k{i}=N$可得$\frac{k(k+1)}{2}=N$，解得$k=\sqrt{2N+0.25}-0.5$。<br>如果每个位置只有最多$O(\sqrt{N})$个匹配串，那么总复杂度$O(L\sqrt{N})$就可以接受了。<br>对于维护$\sqrt{N}$个长度的$Hash$我们也可以动态的$O(L)$时间来实现，只要在超出长度的时候$hash - pow[len]$就可以了。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(L\sqrt{N})$</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">300005</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, k;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> CASE;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 单词字符串信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node2</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span> str;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ull hash1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll hash2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 长度离散化结构</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Discretization</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; xp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator xend;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> xend - xp.begin(); &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; xp.push_back(val); &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">discretize</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sort(xp.begin(), xp.end());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        xend = unique(xp.begin(), xp.end());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> lower_bound(xp.begin(), xend, val) - xp.begin() + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get2</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123; <span class="keyword">return</span> xp[num - <span class="number">1</span>]; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Discretization dis;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> text[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串hash匹配表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hashList[MAXN * <span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 原单词信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Node2 strList[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 每个位置匹配的串</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; matches[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> opt[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">removeVowel</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">int</span>&amp; cnt)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cnt = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : str) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (c == <span class="string">'A'</span> || c == <span class="string">'E'</span> || c == <span class="string">'I'</span> || c == <span class="string">'O'</span> || c == <span class="string">'U'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cnt++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            res.push_back(c);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 我用了双hash，一个自然溢出一个模数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ull powh[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line">ll powh2[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hasher</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ull hashB1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll hashB2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> cnt1;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        powh[<span class="number">0</span>] = powh2[<span class="number">0</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAXN; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            powh[i] = powh[i - <span class="number">1</span>] * <span class="number">277L</span>L;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            powh2[i] = powh2[i - <span class="number">1</span>] * <span class="number">1999L</span>L % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Hasher() &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB1 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB2 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removel</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> len)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB1 -= powh[len] * (ull)c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB2 -= (powh2[len] * c) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB2 %= MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (hashB2 &lt; <span class="number">0</span>) hashB2 += MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertr</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB1 *= powh[<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB1 += c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB2 = (hashB2 * powh2[<span class="number">1</span>]) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB2 += c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB2 %= MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Hasher hasher;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Hasher dynHash[<span class="number">505</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; sss;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    hasher.init();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> tot = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, text);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(text)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">string</span> rem = removeVowel(s, cnt);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!sss.count(rem) || cnt &gt; sss[rem]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            sss[rem] = cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            hasher.clear();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> a : rem) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                hasher.insertr(a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            strList[tot] = &#123;s, hasher.hashB1, hasher.hashB2, cnt&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            hashList[hasher.hashB1 % (MAXN * <span class="number">2</span>)].push_back(tot);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            tot++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            dis.add(rem.size());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dis.discretize();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, text + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    n = <span class="built_in">strlen</span>(text + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dp[i] = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> sz = dis.size();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = sz; j &gt;= <span class="number">1</span>; j--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 动态维护每个长度的hash</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            dynHash[j].insertr(text[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> len = dis.get2(j);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (i &gt; len) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                dynHash[j].removel(text[i - len], len);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (i &gt;= len) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> loc = dynHash[j].hashB1 % (MAXN * <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// hash匹配</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> v : hashList[loc]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    Node2&amp; nd = strList[v];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (nd.hash2 == dynHash[j].hashB2) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        matches[i].push_back(v);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : matches[i]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Node2&amp; nd = strList[a];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> p = i - nd.str.size() + nd.cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (dp[p] &gt;= <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> nx = dp[p] + nd.cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (dp[i] &lt; nx) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    dp[i] = nx;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    opt[i] = a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> k = n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 构造原串</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        res.push_back(opt[k]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> d = strList[opt[k]].str.size() - strList[opt[k]].cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        k -= d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = res.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, strList[res[i]].str.c_str());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>字符串哈希</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>你好，世界</title>
    <url>/2019/12/03/hello-world/</url>
    <content><![CDATA[<p>欢迎，这里是DXTsT，又名小裙子。<br>这个博客用来记录一些算法，黑科技等等，反正就是杂七杂八的东西。<br>在别的地方写过的文章，都会陆续搬到这里来，包括fs49.org</p>
<h3 id="注意，本博客的所有题解代码都不保证能够直接提交AC，只是截取了部分核心代码，能不能AC还是要靠自己！"><a href="#注意，本博客的所有题解代码都不保证能够直接提交AC，只是截取了部分核心代码，能不能AC还是要靠自己！" class="headerlink" title="注意，本博客的所有题解代码都不保证能够直接提交AC，只是截取了部分核心代码，能不能AC还是要靠自己！"></a>注意，本博客的所有题解代码都不保证能够直接提交AC，只是截取了部分核心代码，能不能AC还是要靠自己！</h3><a id="more"></a>]]></content>
  </entry>
</search>
