<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>[SDOI2012]任务安排</title>
    <url>/2020/02/10/slopeDP/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>有$n (n\leq 3\times10^5)$个任务需要被完成，你可以把这些任务全部分成任意多组，每组内的任务必须连续。同组任务会在同一时刻完成，所花时间为$\sum_{i=l}^{r}t_i$，同时每组任务开始有一个预热时间$s$。任务$i$完成的费用为完成时间乘以$c_i$，求如何分组能让费用最小。</p>
<a id="more"></a>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>既然要把所有任务都分组，那么我们只需要知道每个任务属于哪一个组所需费用最小即可。对于任务$i$，我们想要知道从之前哪个任务分过来费用最小。于是考虑动态规划，设$f(i)$为从$1~i$分组完成，所需的最少费用，答案则是$f(n)$。但是有个启动时间$s$不好处理，怎么办呢。利用费用提前思想，每次启动机器的时间一定会给后面的任务贡献费用，那么转移方程为：<br>$$<br>f(i) = \min_{j&lt;i}\{f(j) + (F[i] - F[j]) * T[i] + s * (F[n] - F[j]) \}<br>$$</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(W\log{W})$，分别在排序和树状数组查询上。</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cntX[MAXN * <span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cntY[MAXN * <span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> curY[MAXN * <span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">FenwickTree tree;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> tot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tot);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 组合数打表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= min(i, <span class="number">10</span>); j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            C[i][j] = (C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> x, y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        points[i].x = x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        points[i].y = y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        discrete.add(x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        discrete.add(y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    discrete.discretize();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sort(points, points + tot);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cnt++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i == tot || points[i].x != points[i + <span class="number">1</span>].x) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> xx = discrete.get(points[i].x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 横坐标为xx的点共有多少个</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            cntX[xx] = cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cnt = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        points[i].x = discrete.get(points[i].x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        points[i].y = discrete.get(points[i].y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 纵坐标为y的点共有多少个</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        cntY[points[i].y]++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll ans = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> curX = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 当前y坐标左边有多少个点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        curX++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i &amp;&amp; points[i].x != points[i - <span class="number">1</span>].x) curX = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i != tot &amp;&amp; points[i].x == points[i + <span class="number">1</span>].x) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> l = points[i].y, r = points[i + <span class="number">1</span>].y - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (l &lt; r) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ll U = choose(curX, k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ll D = choose(cntX[points[i].x] - curX, k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ll sum = ((tree.getSum(r) - tree.getSum(l)) % MOD + MOD) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ans = (ans + (sum * U % MOD) * D % MOD) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        curY[points[i].y]++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll now = choose(curY[points[i].y], k) *</span></pre></td></tr><tr><td class="code"><pre><span class="line">                 choose(cntY[points[i].y] - curY[points[i].y], k) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll pre =</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ((tree.getSum(points[i].y) - tree.getSum(points[i].y - <span class="number">1</span>)) % MOD +</span></pre></td></tr><tr><td class="code"><pre><span class="line">             MOD) %</span></pre></td></tr><tr><td class="code"><pre><span class="line">            MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 注意只计算当前的总和，而不是之前的所有和</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        tree.increase(points[i].y, (now - pre + MOD) % MOD);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>斜率DP</tag>
      </tags>
  </entry>
  <entry>
    <title>数论筛法</title>
    <url>/2020/01/20/eulersieve/</url>
    <content><![CDATA[<h1 id="欧拉筛-线性筛"><a href="#欧拉筛-线性筛" class="headerlink" title="欧拉筛/线性筛"></a>欧拉筛/线性筛</h1><p>之前的素数判定中，我们曾使用埃拉托斯特尼筛法(Sieve of Eratosthenes)，进行素数的筛选。但是这个算法的时间复杂度是$O(n\log{\log{n}})$的，因为每个数都被它筛了它的素因子个数那么多次。</p>
<a id="more"></a>

<h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>欧拉筛法（Euler’s sieve）就是减少这种重复的一种筛法，埃筛的方法是筛去素数的倍数，而欧拉筛的核心思想是筛去最小素因子为它的数。这样一对比下来，因为每个数只有一个最小素因子，所以时间复杂度显然是$O(n)$。</p>
<p>然而，欧拉筛法的实现是有一点技巧的，我当初尝试理解的时候还是费了一番功夫。假设我们有一个数$x$，有唯一质因数分解：$\prod_{k} p_k^{\alpha_k} \ (p_{k-1} &lt; p_k)$。此时欧拉筛会筛除一个$p_i*x$，$p_i \leq p_1$，$p_1$就是最小素因子，也就是说筛去的这个数的最小素因子会小于等于$x$的最小素因子，且是$x$的倍数。现在我们就要对于所有的$x$都筛掉这些倍数。</p>
<p>那么为什么每个数只会被筛一次呢？根据唯一分解定理，任何一个数的质因数排序后的序列一定是唯一的，那么假设$a\neq b$，并且他们删掉最小素因子后的数相同，那么它们的最小素因子一定不同。那么他们会被那个除掉最小素因子的数筛掉，然后就不会再被触及。</p>
<p>现在又有一个问题，怎么保证$x\in[2,p-1]$的合数全部被筛掉，没有遗漏呢？还是那个思路，因为小于$p$的数的最小素因子一定小于$p$，所以它一定会被小于$x/最小素因子$的数筛掉，这就保证了正确性。</p>
<p>实现的时候，我们筛到一个素数就要把它放到一个数组里面，此时素数的大小顺序非常重要，因为我们对于$x$需要查找所有小于等于$p_1$的素数，同时在等于$p_1$的时候停止查找。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> nop[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[MAXN / ln(MAXN)];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!nop[i]) primes[tot++] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot &amp;&amp; i * primes[j] &lt;= n; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            nop[i * primes[j]] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// i 整除 p_j 代表此时p_j已经是i的最小素因子</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!(i % primes[j])) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h2 id="扩展应用"><a href="#扩展应用" class="headerlink" title="扩展应用"></a>扩展应用</h2><p>欧拉筛在数论筛法里面用途非常广泛，尤其是对于积性函数，以欧拉函数筛为例，我们令$\varphi(x)=n\prod_k(\frac{p_k-1}{p_k})$，如果$x$是质数，那么$\varphi(x)=x-1$。同时$\varphi(pq) = \varphi(p) * \varphi(q) \ (p \perp q)$，也就是积性函数性质。</p>
<p>于是我们可以在筛到质数的时候把它的$\varphi(x)$设为$x-1$，否则，我们就需要去计算筛到合数的时候$\varphi(x)$值的变化。因为每次我们只加入一个质因数$p$，如果这个质因数不在原数的质因数分解中，那么显然答案要乘以$\varphi(p)$，否则就乘以$p$本身。</p>
<p>代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> nop[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> primes[MAXN / ln(MAXN)], phi[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> tot = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    phi[<span class="number">1</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!nop[i]) primes[tot++] = i, phi[i] = i - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; tot &amp;&amp; i * primes[j] &lt;= n; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            nop[i * primes[j]] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!(i % primes[j])) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                phi[i * primes[j]] = primes[j] * phi[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                phi[i * primes[j]] = phi[primes[j]] * phi[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>质因数分解</title>
    <url>/2019/12/31/prime-factor/</url>
    <content><![CDATA[<h1 id="质因数分解"><a href="#质因数分解" class="headerlink" title="质因数分解"></a>质因数分解</h1><p>接着上一章的素数判定，这一章我们要讨论质因数分解的算法。</p>
<blockquote>
<p>算数基本定理，又称唯一分解定理：每个大于$1$的自然数，都可以写成质数次方的积，且这些质数从小到大排列后，仅存在这一种分解方式。</p>
</blockquote>
<p>换句话说，每个$n&gt;1$，都有唯一一种分解方式$\prod_{k} p_k^{\alpha_k} = n$。</p>
<a id="more"></a>
<h2 id="朴素方法"><a href="#朴素方法" class="headerlink" title="朴素方法"></a>朴素方法</h2><p>对于所有$p|n$，我们不断试除就可以了，与质数判定同理，我们不需要试超过$\sqrt{n}$的质数，因为这样的质数一定就是$n$本身，于是有代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;ll, ll&gt; factorize(ll x) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">map</span>&lt;ll, ll&gt; pcnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i * i &lt;= x; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">while</span> (x % i == <span class="number">0</span>) cnt++, x /= i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            pcnt[i] = cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 注意要把最后一个质数包括进去</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) pcnt[x] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> pcnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>注意我们可以直接在$n$上面做除法，而不用真的遍历到$\sqrt{n}$，因为发现一个质因数就可以把数据规模缩小，可以用哈希表把$log$消掉。这样，在最坏情况下这个算法时间复杂度是$O(\sqrt{n})$。当然，如果先把所有质数预处理出来，可以达到$O(\sqrt{\frac{n}{\log{n}}})$。</p>
<h2 id="Pollard’s-rho-算法"><a href="#Pollard’s-rho-算法" class="headerlink" title="Pollard’s rho 算法"></a>Pollard’s rho 算法</h2><h3 id="生日悖论-Birthday-Paradox"><a href="#生日悖论-Birthday-Paradox" class="headerlink" title="生日悖论 (Birthday Paradox)"></a>生日悖论 (Birthday Paradox)</h3><p>在介绍Pollard’s rho算法之前，我想先介绍一个概率学中的小问题：一个房间中要有多少人，出现两个人生日相同的概率大于等于$50\%$？</p>
<p>如果你是第一次看到这个问题，那么答案可能会让你惊讶：只需要$23$个人。这不是玄学，而是通过严谨的数学推理得出的，实验也证明了这一点。那么这个结果是如何得到的呢？</p>
<p>假设一年有$365$天，且每个人的生日是独立且均匀分布的，那么第一个人在第$x$天生日的概率是$\frac{1}{365}$，我们记为$Pr\{b_1=x\}$。那么现在来了第二个人，它的生日在第$x$天的概率$Pr\{b_2=x\}$也是$\frac{1}{365}$，此时两个人都在第$x$天的概率是<br>$$<br>Pr\{b_1=x \textbf{ and } b_2=x\} = \frac{1}{365^2}<br>$$<br>但是这个$x$我们可以取$365$个，于是两个人生日都在同一天的概率就是<br>$$<br>Pr\{b_1=b_2\} = 365\times \frac{1}{365^2} = \frac{1}{365}<br>$$<br>知道了任意两人生日相同的概率，就可以扩展到$k$个人中的两人生日相同的期望值，由于$k$个人中选$2$个，所以有:<br>$$<br>E = {k\choose2} \frac{1}{365} = \frac{k(k-1)}{730}<br>$$<br>所以期望存在至少一对生日相同的两人只需要$k=28$，$50\%$概率的计算由于比较复杂就不放上来了，但是可以推测，这个值一定会比$28$少。</p>
<p>于是我们可以知道，生日碰撞的概率是$O(\sqrt{n})$级别的，而不是我们下意识的$O(n)$。</p>
<h3 id="随机化算法"><a href="#随机化算法" class="headerlink" title="随机化算法"></a>随机化算法</h3><p>Pollard’s rho 算法的基本原理就是从待分解数$x$中任意找出两个数$a, b$，计算$gcd(|a - b|, x)$，当他们的$gcd$不是$1$的时候，我们就找到了$x$的一个因数。为什么是取两个呢？这就要利用我们上面说到的生日悖论了，因为只取一个$a$，此时$a|x$的几率很小，但是如果我们取两个数做差，出现$|a-b|$与$x$有公约数的几率就大很多了。事实上Pollard’s rho算法输出$x$的一个约数$p$的期望运行时间是$O(\sqrt{p})$。</p>
<p>那么如何选取这两个数呢？我们可以随机选取，但是Pollard’s rho算法使用的是一种二次剩余系的伪随机数生成函数<br>$$<br>f(x) = x^2 + c \pmod{n}<br>$$<br>为什么用这个函数呢？我没有在算法导论上看到具体说明，但是这个函数应该是对于Pollard’s rho算法的时间效率最优的函数。由于这个函数最后一定会出现循环，长得像希腊字母$\rho$，因此得名。</p>
<p><img src="/uploads/rho_cycle.jpg" width="30%" height="30%"></img><br>正因为这个性质，在出现环的时候我们也需要及时的退出并且换下一个随机数。我们可以使用Floyd判圈算法来判断是否出现了环，大意就是两个指针一个走一步一个走两步，如果有环那么两个指针一定会碰上，于是我们就可以有代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">f</span><span class="params">(ll x, ll c, ll p)</span> </span>&#123; <span class="keyword">return</span> (modmul(x, x, p) + c) % p; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">pollard_rho</span><span class="params">(ll x)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll c = mt() % (x - <span class="number">1</span>) + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll l = f(mt() % x, c, x), r = f(l, c, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// l是慢的指针，r是快的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (l != r) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll g = __gcd(<span class="built_in">abs</span>(l - r), x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (g &gt; <span class="number">1</span>) <span class="keyword">return</span> g;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        l = f(l, c, x), r = f(f(r, c, x), c, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>如果$x$是个质数，那么我们可以用上一章的Miller–Rabin算法提前判掉，这样整个算法的期望时间复杂度就是$O(n^{0.25}\log{n})$了。</p>
<h3 id="常数优化"><a href="#常数优化" class="headerlink" title="常数优化"></a>常数优化</h3><p>上面的写法虽然时间复杂度是正确的，但是对于这道题还是不够的：<br>例题：<a href="https://www.luogu.com.cn/problem/P4718" target="_blank" rel="noopener">【模板】Pollard-Rho算法</a></p>
<p>我们还需要一些常数优化，Pollard’s rho算法的瓶颈就在于需要多少次才能得到一个约数$p$，以及找不到约数的时候做$gcd$的时间。前者并不好优化（玄学），但是减少$gcd$的次数却是可以做到的。</p>
<p>一个普遍的做法就是利用倍增的思想，先走完$2^k$步以后把$|a-b|$乘积统一进行$gcd$，然后换一个起点继续增加步数。如果出现乘积为$0$就说明我们遇到环了，此时退出并寻找下一个随机数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ll <span class="title">pollard_rho</span><span class="params">(ll x)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll c = (ll)mt() % (x - <span class="number">1</span>) + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll s = <span class="number">0</span>, t = (ll)mt() % (x), val = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// i是步长</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;; i &lt;&lt;= <span class="number">1</span>, s = t, val = <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> z = <span class="number">1</span>; z &lt;= i; z++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            t = f(t, c, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            val = modmul(val, <span class="built_in">abs</span>(t - s), x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 如果遇到环了</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!val) <span class="keyword">return</span> x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 为了避免步数过长导致出不来结果，所以手动设定每127步计算一次</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!(z % <span class="number">127</span>)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ll g = __gcd(val, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (g &gt; <span class="number">1</span>) <span class="keyword">return</span> g;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll g = __gcd(val, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (g &gt; <span class="number">1</span>) <span class="keyword">return</span> g;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>搜索</tag>
        <tag>随机化</tag>
      </tags>
  </entry>
  <entry>
    <title>素数判定</title>
    <url>/2019/12/31/prime-test/</url>
    <content><![CDATA[<blockquote>
<p>定义：对于一个大于$1$的正整数$p$，如果$p$是质数/素数，那么对于所有$a|p$，$a$要么是$1$，要么是$p$。</p>
</blockquote>
<p>那么对于一个数$x$，我们如何让计算机去判定它是不是质数/素数呢？</p>
<a id="more"></a>
<h1 id="素数判定"><a href="#素数判定" class="headerlink" title="素数判定"></a>素数判定</h1><h2 id="朴素方法"><a href="#朴素方法" class="headerlink" title="朴素方法"></a>朴素方法</h2><p>根据定义，我们只需要判断这个数$x$，除了$1$和$x$以外还有没有其他约数就好了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(ll x)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt; x; i++) </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>这个算法的时间复杂度是$O(n)$，在极端情况下，$x$是质数的时候就需要扫遍$2~x$之间的所有值。但是实际上，我们并不需要扫到$x$，为什么呢？</p>
<p>考虑当$x$有一个约数$a$，$a|x$，那么一定有$\frac{x}{a}|x$。也就是说，每个约数都是对称的，对称中心就是$\sqrt{x}$。当$a\leq \sqrt{x}$存在一个对于$x$的约数的时候，$a &gt; \sqrt{x}$一定也存在一个$\frac{x}{a}$，反之则不存在。所以我们只需要扫到$\sqrt{x}$就可以了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(ll x)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i * i &lt;= x; i++) </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>这个算法的时间复杂度是$O(\sqrt{n})$，还不错。</p>
<h2 id="筛法"><a href="#筛法" class="headerlink" title="筛法"></a>筛法</h2><p>但是在算法竞赛里面，经常有一类问题需要你对给出的$Q$个查询进行回答。此时如果查询范围很大，而次数又很多的话，上面的方法就会超时。</p>
<p>这时候就引出我们的埃氏筛/线性筛法。我们不从$x$出发去判断$x$是不是质数，而是从比较小的数开始，依次划掉这个数的倍数。因为质数的倍数一定不是质数（都有倍数了还怎么是质数），那么没有划掉的就是质数，直接$O(1)$判定即可。实现也非常简单</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> notprime[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sieve</span><span class="params">(<span class="keyword">int</span> maxn)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= maxn; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (notprime[i]) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i * <span class="number">2</span>; j &lt;= maxn; j += i) notprime[j] = <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>我之所以把数组定义成<code>notprime</code>是因为这样就不用把数组都初始化为$1$了。<br>这个算法的时间复杂度是多少呢？我们可以这样考虑，只有质数会进入第二个循环，而它会划掉所有它的倍数。那么也就是说，每个数最多会被划掉质因数个数那么多次。我们把一个数的质因数分解表示为$\prod_{k} p_k^{\alpha_k}$，则极端情况下，假设有$k$个不同质因数，则$n$的范围会是$2\times 3\times \dots \times p_k \geq k!$。而$k!$根据斯特林公式有<br>$$<br>n! \approx \sqrt{2\pi n}\bigg(\frac{n}{e}\bigg)^n \leq n^n<br>$$<br>那么$k$相对于$n$就是$O(\log{\log{n}})$级别的了，所以总复杂度是$O(n\log{\log{n}})$。这个复杂度与线性几乎没有差别了，虽然还有更高级的$O(n)$线性筛，但是这不是重点。</p>
<h2 id="Miller–Rabin-素性测试"><a href="#Miller–Rabin-素性测试" class="headerlink" title="Miller–Rabin 素性测试"></a>Miller–Rabin 素性测试</h2><p>Miller-Rabin 素性测试是一个更高级的素数判定算法，为什么叫素性测试呢？因为这个算法也很难保证一定能测出这个数是不是质数，只能说它很像质数，有多像呢？非常非常像。</p>
<p>但是对于算法竞赛的数据范围来说，这个算法是可以<strong>准确</strong>判定出这个数是不是质数的。</p>
<h3 id="Fermat小定理"><a href="#Fermat小定理" class="headerlink" title="Fermat小定理"></a>Fermat小定理</h3><blockquote>
<p>如果$p$是质数，对于一个数$a \in [1, p-1]$，有<br>$$<br>a^{p-1} \equiv 1\pmod{p}<br>$$</p>
</blockquote>
<p>如果我们想知道$n$是否是素数，我们在中间选取$a$，看看上面等式是否成立。如果$a^{n-1} \not\equiv 1\pmod{n}$，那么$n$一定不是质数。但是注意，这个定理的逆命题不一定成立，也就是说，$a^{n-1} \equiv 1\pmod{n}$不一定表示$n$是质数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fermat</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> n == <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= TEST_TIME; ++i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> a = rand() % (n - <span class="number">2</span>) + <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 快速幂求得a^&#123;n-1&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (fastExp(a, n - <span class="number">1</span>, n) != <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>事实上，有一类数满足</p>
<blockquote>
<p>$n$是合数，对于与$n$互质的数$b$，$b^{n-1}\equiv 1\pmod{n}$</p>
</blockquote>
<p>这样的数被称为Carmichael数，是费马测试的大敌，但是由于Carmichael比质数少得多，所以仍然有方法去应对它。它的一个等价定义：</p>
<blockquote>
<p>一个正合成数$n$是卡迈克尔数，当且仅当$n$无平方数约数且对于所有$n$的素因数$p$，$p-1|n-1$。</p>
</blockquote>
<h3 id="二次探测定理"><a href="#二次探测定理" class="headerlink" title="二次探测定理"></a>二次探测定理</h3><p>假设我们有$x^2 \equiv 1\pmod{p}$，$p$为素数，那么该式子可以化为<br>$$<br>(x - 1)(x + 1) \equiv 0\pmod{p}<br>$$<br>那么$p$能整除$(x - 1)(x + 1)$，此时$(x-1)$或者$(x+1)$能被质数$p$整除，有$x \equiv 1\pmod{p}$或者$x\equiv-1\pmod{p}$。</p>
<p>那么我们假设$n&gt;2$是个质数，那么它一定是个奇数，且$n-1$一定可以被写成$d2^s$的形式，其中$s$是正整数，$d$是奇数。根据费马小定理，那么就有$a^{d2^s} \equiv1\pmod{n}$，同时，根据以上性质，对于$i \in [1, s-1]$，有<br>$$<br>    a^{d2^i} \equiv-1\pmod{n}\\<br>    a^d \equiv 1\pmod{n}<br>$$<br>所以我们可以不断对$a^{n-1}$取平方根后，判断是否出现不符合以上性质的根就知道它是否像质数了。同样，这个引理的逆命题也存在反例，但是由于Carmichael数的性质，它通不过平方探测，所以与费马小定理结合起来效果很不错。</p>
<p>但是即使这样，我们也只能说像是质数，事实上Miller–Rabin有$4^{-k}$的错误率，$k$是选取的基数$a$的数量。好消息是，在算法竞赛范围内$n\leq2^{64}$，选取$8$个素数作为基数就可以准确判定了。</p>
<p>时间复杂度：算法竞赛内用<code>__int128_t</code>可以达到$O(k\log{n})$，但是对于大整数一般是$O(k\log^3{n})$，可以用$FFT$优化到$O(k\log^2{n}\log{\log{n}}\log{\log{\log{n}}})$。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">modmul</span><span class="params">(ll a, ll b, ll p)</span> </span>&#123; <span class="keyword">return</span> (<span class="keyword">__int128_t</span>)a * (<span class="keyword">__int128_t</span>)b % p; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">fastExp</span><span class="params">(ll x, ll p, ll mod)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    x %= mod;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll ans = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (p) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>) ans = modmul(ans, x, mod);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        x = modmul(x, x, mod);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        p &gt;&gt;= <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">miller_rabin</span><span class="params">(ll x)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (x == <span class="number">2</span> || x == <span class="number">3</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">2</span> || !(x &amp; <span class="number">1</span>)) <span class="keyword">return</span> <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll <span class="built_in">pow</span> = <span class="number">0</span>, u = x - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (!(u &amp; <span class="number">1</span>)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">pow</span>++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        u &gt;&gt;= <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> p = primes[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (p &gt;= x) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll v = fastExp(p, u, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (v == <span class="number">1</span> || v == x - <span class="number">1</span>) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (; j &lt; <span class="built_in">pow</span>; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            v = modmul(v, v, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (v == x - <span class="number">1</span>) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (j == <span class="built_in">pow</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

<p>例题：<a href="https://loj.ac/problem/143" target="_blank" rel="noopener">质数判定</a></p>
]]></content>
      <categories>
        <category>算法</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>[CF1097D] Makoto and a Blackboard</title>
    <url>/2019/12/25/CF1097D/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>一开始有一个整数$n(n\leq 10^{15})$，你可以执行以下操作$k(k\leq 10^4)$次：把$n$替换成$n$的任意一个约数(包括$1$和$n$)，假设每个约数都有相同概率被选中。现在问你$k$次操作后剩下这个数的期望值是多少。</p>
<a id="more"></a>

<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>我们知道期望公式为$\sum{x*p(x)}$，在这道题中，由于$x$的范围是离散且确定的，我们只需要知道每个$x$出现的概率就行了。</p>
<p>我们可以画一张图来看看转移的过程，以$6$为例：<br><img src="/uploads/cf1097d1.png" width="30%" height="30%"></img><br>我们可以得出几个有用的信息：</p>
<ul>
<li>图中所有节点都为原数$n$的约数</li>
<li>每个节点只会转移到小于等于它的数</li>
<li>因为$k$有限，这个流程可以直接模拟</li>
</ul>
<p>于是我们就可以用动态规划，令$f(i, x)$为第$i$轮时，得到数字为$x$的概率，可得：<br>$$<br>    f(i + 1, y) = f(i + 1, y) + f(i, x) * \frac{1}{|d(x)|} (y \in d(x))<br>$$<br>于是这题就解决了……</p>
<p>但是等等，这个玩意复杂度是多少呢？我们花$O(\sqrt{n})$预处理出来约数，约数个数大约是$O(\log{n})$，都在时间范围内。状态数量是$O(k\log{n})$，转移是$O(\log{n})$，合在一起$O(k\log^2{n})$但是交上去会T掉，为什么呢？</p>
<p>因为因数个数虽然是$O(\log{n})$，但是常数巨大，一般来说一个数的质因数分解可以表示为$\prod_k{(p_k^{\alpha_k})}$那么它会有$\prod_k{(\alpha_k+1})$个因数。</p>
<p>那么假如我给出$n=2^{20}\times3^{20}$，足足会有$21\times21=441$个因数，那么$10^4\times441^2=1.6*10^9$这不T到天上去？<br>那么接下来就要引出我写这篇博客的意义了，首先把我们刚刚得到的递推式优化一下。<br>$$<br>    f(i+1, y) = \sum_{ky|n} \frac{f(i, ky)}{|d(ky)|}<br>$$<br>而形如$g(n) = \sum_{d|n} f(d)$这类函数给我们的提示就是它很有可能是积性的，由于地方太小就不写证明了。当$f(i, x)$是积性函数的时候，$f(i,x)=\prod_{k} f(i, p_k^{\alpha_k})$。于是我们可以分别计算对于$n$的每个质因数的$f(i, p^{\alpha_k})$，然后把他们乘起来。此时时间复杂度为$O(k\sum{\alpha_i^2})$，此前为$O(k\prod{(\alpha_i+1)})$，对于$2^{20}\times3^{20}$来说，只需要$10^4\times800=8\times10^6$，是一个巨大的提升。</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>$O(k\sum{\alpha_i^2})$</p>
<h1 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h1><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;n, &amp;k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll x = n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 获取质因数以及其指数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (ll i = <span class="number">2</span>; i * i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i &gt; x) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (x % i == <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            x /= i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cnt++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (cnt) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            divs.push_back(&#123;i, cnt&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">1</span>) divs.push_back(&#123;x, <span class="number">1</span>&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll ans = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 最外层是每个质因数p^i形式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> pair : divs) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> cnt = pair.second;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 滚动数组优化空间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">memset</span>(dp[<span class="number">0</span>], <span class="number">0</span>, <span class="keyword">sizeof</span>(dp[<span class="number">0</span>]));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dp[<span class="number">0</span>][cnt] = <span class="number">1L</span>L;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 从这里开始是每个状态的转移</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">memset</span>(dp[(i &amp; <span class="number">1</span>) ^ <span class="number">1</span>], <span class="number">0</span>, <span class="keyword">sizeof</span>(dp[<span class="number">0</span>]));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= cnt; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">0</span>; s &lt;= j; s++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    dp[(i &amp; <span class="number">1</span>) ^ <span class="number">1</span>][s] +=</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        getInv(j + <span class="number">1</span>, MOD) * dp[i &amp; <span class="number">1</span>][j] % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (dp[(i &amp; <span class="number">1</span>) ^ <span class="number">1</span>][s] &gt; MOD) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        dp[(i &amp; <span class="number">1</span>) ^ <span class="number">1</span>][s] -= MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll tmp = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll pw = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= cnt; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            tmp += (pw * dp[k &amp; <span class="number">1</span>][i] % MOD);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (tmp &gt; MOD) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                tmp -= MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            pw = pw * pair.first % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ans = (ans * tmp) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld"</span>, ans);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>概率期望</tag>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>[SDOI2009] 虔诚的墓主人</title>
    <url>/2019/12/10/SDOI09Grave/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>一个$N \times M (N, M \leq 10^9)$的地图上有$W (W \leq 10^5)$棵树。对于图上没有树的点，如果在这个点上下左右都至少有$k (1 \leq k \leq 10)$个点，那么它会贡献${L\choose{k}} *  {R\choose{k}} * {U\choose{k}}* {D\choose{k}}$点虔诚度，问这个地图上所有虔诚度之和模$2147483648$（有毒）的值。</p>
<a id="more"></a>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>题意很清晰，但是$N,M$的规模过于庞大，普通的模拟肯定不行了。但是我们注意到$W$的值并没有很大，所以实际上能贡献虔诚度的点只有$O(W^2)$个。但是这么多点一个个统计仍然太多了，所以很自然的我们想到了用扫描线法。</p>
<p>扫描线的统计仍然不是很直观，所以我们需要画一个图，假设我们现在的地图是这样的：<br><img src="/uploads/sdoi09grave1.png" alt="初始地图"><br>那么显然中间那个点是一个可以统计的点，如果我们记某个点$p$上方的树的数量为$U(p)$，下方为$D(p)$，左右分别为$L(p), R(p)$。那么这个点的虔诚度为${L(p)\choose{k}} *  {R(p)\choose{k}} * {U(p)\choose{k}}* {D(p)\choose{k}} = 1$。如果我们再加两个点，然后把目光集中在那根竖线上：<br><img src="/uploads/sdoi09grave3.png" alt="初始地图"><br>我们可以发现可以贡献虔诚度的点会在竖线的线段与其左右两边的横线的交点上。除此之外，我们知道在这条竖线（不包括两端）上的点$U(p)$和$D(p)$的值是完全相等的。如果我们回到那个公式，统计所有点的贡献：<br>$$<br>\begin{align}<br>S &amp; = \sum_{p} {L(p)\choose{k}} *  {R(p)\choose{k}} * {U(p)\choose{k}}* {D(p)\choose{k}}\\<br>&amp; = {U(p)\choose{k}} * {D(p)\choose{k}} * \bigg(\sum_{p} {L(p)\choose{k}} *  {R(p)\choose{k}}\bigg)<br>\end{align}<br>$$<br>根据求和公式的分配率可以推出来。这个公式意味着我们可以先得出一段竖线的${U(p)\choose{k}} * {D(p)\choose{k}}$值，然后乘以这个竖线区域所包含的所有横线的${L(p)\choose{k}} *  {R(p)\choose{k}}$就是这个区域所有的虔诚度贡献。竖线上的$U(p)$和$D(p)$可以通过从上到下以及预处理的方式求出来，现在问题在于怎么求出竖线上的横线贡献的$L(p), R(p)$：<br>$$<br>\sum_{i = l}^{r} {L(p[i])\choose{k}} *  {R(p[i])\choose{k}}<br>$$<br>可以看出这其实是一个区间查询问题，对于横线来说$L(p), R(p)$也可以通过从左到右的方式算出来，但是问题是每个横线区域与竖线的位置是密切相关的，随着向右边移动而变化：<br><img src="/uploads/sdoi09grave4.png" alt="扫描线"><br>这个时候扫描线的优势就出来了，我们可以把所有树的位置按照$x$坐标排序，如果$x$坐标相同则按照$y$坐标排序。然后我们从左到右，从上到下扫描，先统计个数，再更新横线的$L(p), R(p)$，最后把${L(p[i])\choose{k}} *  {R(p[i])\choose{k}}$放进区间查询的数据结构里面。因为这个虔诚度是可以加起来的所以区间查询用树状数组就足够了。<br><img src="/uploads/sdoi09grave5.gif" alt="动态演示"></p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(W\log{W})$，分别在排序和树状数组查询上。</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cntX[MAXN * <span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cntY[MAXN * <span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> curY[MAXN * <span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">FenwickTree tree;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> tot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;tot);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 组合数打表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    C[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        C[i][<span class="number">0</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= min(i, <span class="number">10</span>); j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            C[i][j] = (C[i - <span class="number">1</span>][j] + C[i - <span class="number">1</span>][j - <span class="number">1</span>]) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> x, y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        points[i].x = x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        points[i].y = y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        discrete.add(x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        discrete.add(y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    discrete.discretize();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sort(points, points + tot);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cnt++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i == tot || points[i].x != points[i + <span class="number">1</span>].x) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> xx = discrete.get(points[i].x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 横坐标为xx的点共有多少个</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            cntX[xx] = cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cnt = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        points[i].x = discrete.get(points[i].x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        points[i].y = discrete.get(points[i].y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 纵坐标为y的点共有多少个</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        cntY[points[i].y]++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll ans = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> curX = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tot; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 当前y坐标左边有多少个点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        curX++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i &amp;&amp; points[i].x != points[i - <span class="number">1</span>].x) curX = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i != tot &amp;&amp; points[i].x == points[i + <span class="number">1</span>].x) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> l = points[i].y, r = points[i + <span class="number">1</span>].y - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (l &lt; r) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ll U = choose(curX, k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ll D = choose(cntX[points[i].x] - curX, k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ll sum = ((tree.getSum(r) - tree.getSum(l)) % MOD + MOD) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ans = (ans + (sum * U % MOD) * D % MOD) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        curY[points[i].y]++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll now = choose(curY[points[i].y], k) *</span></pre></td></tr><tr><td class="code"><pre><span class="line">                 choose(cntY[points[i].y] - curY[points[i].y], k) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll pre =</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ((tree.getSum(points[i].y) - tree.getSum(points[i].y - <span class="number">1</span>)) % MOD +</span></pre></td></tr><tr><td class="code"><pre><span class="line">             MOD) %</span></pre></td></tr><tr><td class="code"><pre><span class="line">            MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 注意只计算当前的总和，而不是之前的所有和</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        tree.increase(points[i].y, (now - pre + MOD) % MOD);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>各省省选</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>扫描线</tag>
        <tag>组合数学</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>二分法杂谈</title>
    <url>/2019/12/09/binary-search/</url>
    <content><![CDATA[<p>学算法一年了，做了很多题，但是对于二分法这块一直不是很明白。 有时候遇到二分答案的问题经常要调好长时间才能写对，有些时候就是看别人二分是怎么写的就照抄，但是并不清楚为什么这么写是对的。今天总结了一下二分法的几种情况以及它们的思路。</p>
<a id="more"></a>

<h2 id="二分的写法"><a href="#二分的写法" class="headerlink" title="二分的写法"></a>二分的写法</h2><p>网上的二分法普遍有两种写法，一种是左闭右开<code>[l, r)</code>的写法，一种是左闭右闭<code>[l, r]</code>的写法。左闭右开写法的优点是上下界比较宽松，不会出现死循环，而且最终答案$l,r$都可以用。但是缺点就是对于将要介绍的四种情况，转移时的$\pm 1$的位置变换很令人头疼。所以这里我将要使用的是后一种方式，但是左闭右闭一定要注意转移的写法<code>l = mid + 1</code>和<code>r = mid - 1</code>，此时$\pm 1$都是固定的，但是最优解可能不在区间内，所以需要一个外层变量<code>ans</code>来确保得到的是最优解。这种写法的优点是非常好想。</p>
<h2 id="二分法四种情况"><a href="#二分法四种情况" class="headerlink" title="二分法四种情况"></a>二分法四种情况</h2><p>需要二分答案的时候，要先确保数据具有单调性。也就是说给定一个集合$S$，里面有一个需要寻找的答案，那么有：如果$S_i$满足条件，那么所有$S_j(j\geq i)$（或者$j\leq i$），都满足条件，并且如果$S_i$不满足条件，则所有$S_j(j&lt;i)$（或者$j&gt;i$）都不满足条件，那么这个数据就具有单调性。</p>
<p>在单调的数据下，我们需要找一个满足条件的答案就可以用二分法。我们都学过二分搜索查找一个数，但是有时候我们不是查找一个数，而是找一个满足条件的最小/最大值呢？如果满足条件值并不存在呢？我们把所有情况分成四种以便区分。假设数据是一个非降序列，那么他们分别是：不小于条件最小位置，严格大于等于条件最小位置，不大于条件的最大位置，严格小于条件的最大位置。</p>
<h3 id="不小于条件最小位置"><a href="#不小于条件最小位置" class="headerlink" title="不小于条件最小位置"></a>不小于条件最小位置</h3><p>假如给定一个非降序列：$S={1,1,4,4,5,6,7,8}$，假如我们想知道$S_i \geq 3$的最小位置，在此处显然是位置$3$，而不是位置$4$。在这种情况下，我们二分法找到$S_i$满足$S_i \geq 3$以后仍然要往更小的范围去寻找，这样才能保证是最小位置，那么在二分写法里面，就是将$r$的值缩小，那么最后一个满足条件的$mid$就是答案。由此可得一个写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans = n + <span class="number">1</span>; <span class="comment">// 如果目标不存在就返回一个不存在的位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= k) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        	ans = min(ans, mid);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            r = mid - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            l = mid + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="严格大于条件最小位置"><a href="#严格大于条件最小位置" class="headerlink" title="严格大于条件最小位置"></a>严格大于条件最小位置</h3><p>我们换一个非降序列：$S={1,1,3,4,5,6,7,8}$，假如我们想知道$S_i &gt; 3$的最小位置，那么我们可以看出应该是位置$4$，那么我们只需要把<code>if (arr[mid] &gt;= k)</code>改成<code>if (arr[mid] &gt; k)</code>就行了。</p>
<h3 id="不大于条件的最大位置"><a href="#不大于条件的最大位置" class="headerlink" title="不大于条件的最大位置"></a>不大于条件的最大位置</h3><p>假设这个序列是$S={1,1,3,3,3,6,7,8}$，然后我们要找一个$S_i \leq 3$的最大位置，那么我们可以看出应该是位置$5$。在此条件下，如果我们找到一个$S_i \leq 3$我们仍然需要往后找以确保能找到最大位置。那么在二分写法里面就是将$l$增大，那么我们只需要在此时找到最大的那个$mid$就是答案，写法如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binary_search</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>; <span class="comment">// 如果目标不存在就返回一个不存在的位置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (arr[mid] &lt;= k) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        	ans = max(ans, mid);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            l = mid + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            r = mid - <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> ans;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="严格小于条件最大位置"><a href="#严格小于条件最大位置" class="headerlink" title="严格小于条件最大位置"></a>严格小于条件最大位置</h3><p>我们只需要把<code>if (arr[mid] &lt; k)</code>改成<code>if (arr[mid] &lt;= k)</code>就行了。</p>
<h3 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h3><p>对于序列并非升序的情况，我们可以将它转化为升序思考。绝大部分二分的题都可以归结为这四种情况，像最大的最小值就是满足条件的最大位置，最小的最大值就是满足条件的最小位置。只要想清楚自己想要二分出来的答案是什么样的就可以轻松A掉题了。</p>
]]></content>
      <categories>
        <category>算法</category>
        <category>二分法</category>
      </categories>
      <tags>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>[ICPC NAQ2018] Problem L: Longest Life</title>
    <url>/2019/12/04/NAQ18L/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>正常情况下每分钟你的生命就会流失一分钟（废话），但是现在科技这么发达你有（$N \leq 10^5$）次改变生命流失速度的机会，这些机会会出现在$N$个不同的时间点上。但是如果你改变了生命流失速率，那么你就会瞬间流失 $C$ 分钟的生命。如果你能够自由选择是否接受这些机会，问你最晚的死亡时间是什么时候。</p>
<a id="more"></a>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>如果用动态规划的方式去求解，那么可以很容易得到一个DP方程，如果我们设 $f(i) =$ 以第$i$个药片作为最后使用的药片的最晚死亡时间。那么转移方程就应该是：<br>$$f(i) = \max \{g(i, k)\} \ (0 \leq k &lt; i)$$</p>
<p>$g(i, k)$就表示之前使用了第$k$个药片，换成第$i$个药片以后所能存活的最长时间。如果我们把整个过程看做一个线性函数斜率不断改变的过程，那么$y$坐标就是不做改变应该存活的时间，而$x$轴就代表实际存活的时间。于是有图</p>
<p><img src="/uploads/naq18L1.png" alt="药剂效果"></p>
<p>我们要求的就是两个直线触及天花板的那个点的横坐标。</p>
<p>假设一开始死亡时间为$T$，药片出现时间为$t[i]$，改变的斜率为$k[i]$，那么有</p>
<p>$$g(i, k) = t[i] +  \frac{T-\text{使用i时的高度}}{k[i]}$$</p>
<p>合并到DP方程展开后就是：<br>$$<br>f(i)= \max \bigg( t[i]+\frac{T-(k[j]t[j]+T-k[j]f(j)+k[j](t[i]-t[j]) + C)}{k[i]} \bigg)<br>$$<br>化简一下<br>$$<br>f(i)= \max \bigg( t[i]-\frac{C+k[j](t[i]-f(j))}{k[i]} \bigg)<br>$$<br>其中$1 \leq k&lt;i$，如果看不懂的话手动推一下就好了。</p>
<p>但是观察一下数据范围，$10^5$ 显然对于这个$O(N^2)$ 的DP来说太大了，但是我们观察到$t[i]$是单调上升的，而且对于进来的不同$k[i]$，有一部分斜率比之前最小值要大的显然不能构成最优解，也就是说，这里面$j$的选择是可以优化的。那么如果想让程序不超时，我们需要一个$O(1)$的最优解选择方法，那么就要想到斜率DP。</p>
<p>我们继续优化这个式子，假设现在有两个药片$s, j$且$s &lt; j &lt; i$。那么假设$j$是比$s$更优的选择，那么一定满足：<br>$$t[i]&gt; \frac{k[s]f(s)-k[j]f(j)}{k[s]-k[j]}$$<br>当这个条件满足的时候，我们知道选择第$j$个药片比第$s$个药片要优。<br>如果我们定义$slope(s, j) = $上面这个式子，也就是相当于点$s$到点$j$的斜率，那我们需要判断满足这个条件的点具有的特征。假设对于三个点$s &lt; j &lt; i$并且$slope(s, j) &gt; slope(j, i)$，那么我们可以判断点$j$一定不会形成最优解。<br>剩下的就是用单调队列维护下凸包的操作了，但是要注意不要把$k[i]$不单调的点也算进去，具体见代码。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(N)$，因为每个元素只会进队列一次，出列一次。</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里我用了long double来防止精度不够</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">double</span> LD;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pill</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LD ks;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Pill() &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Pill(ll t, ll x, ll y) : t(t), ks(y / (LD)x) &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Pill&amp; b) <span class="keyword">const</span> &#123; <span class="keyword">return</span> t &lt; b.t; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;Pill&gt; pills;</span></pre></td></tr><tr><td class="code"><pre><span class="line">LD dp[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟了一个队列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> QQ[MAXN * <span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 斜率计算</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">LD <span class="title">slope</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> j)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> (pills[j].ks * dp[j] - pills[s].ks * dp[s]) /</span></pre></td></tr><tr><td class="code"><pre><span class="line">           (pills[j].ks - pills[s].ks);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;n, &amp;m, &amp;k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ll t, x, y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>, &amp;t, &amp;x, &amp;y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        pills.emplace_back(t, x, y);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pills.emplace_back(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sort(pills.begin(), pills.end());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dp[<span class="number">0</span>] = n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    QQ[<span class="number">1</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LD minn = <span class="number">1e30</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (pills[i].ks &gt;= minn) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; slope(QQ[l], QQ[l + <span class="number">1</span>]) &lt;= pills[i].t) ++l;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> opt = QQ[l];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        LD ki = pills[i].ks;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        LD kj = pills[opt].ks;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 根据公式从dp[j]计算dp[i]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        LD newx = (LD)pills[i].t - (k + kj * (pills[i].t - dp[opt])) / ki;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dp[i] = max(dp[i], newx);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">while</span> (l &lt; r &amp;&amp; slope(QQ[r - <span class="number">1</span>], QQ[r]) &gt;= slope(QQ[r], i)) r--;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        QQ[++r] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        minn = min(minn, pills[i].ks);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    LD ans = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ans = max(ans, dp[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.7Lf"</span>, ans);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>斜率DP</tag>
      </tags>
  </entry>
  <entry>
    <title>[洛谷P3067] 平衡的奶牛群</title>
    <url>/2019/12/04/LuoguP3067/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你$n(n\leq20)$个数，从中任意选出一些数，记为集合$S$，使得存在一种$s \in S$满足$sum(s) == sum(\bar{s})$。求这样的选数方案有多少种。</p>
<a id="more"></a>

<p>介绍一种解这道题的新思路：利用$bitset$。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>先从暴力算法开始，我们只需要枚举所有集合以及他们的子集，如果发现子集以及其补集的和相等，那么这个集合就是一种方案。</p>
<p>更具体的说，假设$P$是原集合，$S$是$P$的所有子集。如果对于所有$s \in S$ 的子集有 $sum(s) == sum(\bar{s})$，那么$S$就贡献一个答案。</p>
<p>于是我们可以写出如下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s1 = i; s1; s1 = (s1 - <span class="number">1</span>) &amp; i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (sum[s1] == sum[i ^ s1]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ans++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>子集求和是$O(n2^n)$但是枚举子集的子集是$O(3^n)$的，显然会TLE的死死的。</p>
<p>于是我们会想到折半枚举，假设我们能枚举前一半和后一半的所有子集，那么应该怎么确定哪些子集是符合条件的呢？</p>
<p>假设对于一个集合$S_1$我们有一个子集$s_1$和补集$\bar{s_1}$，同时我们有另一个集合$S_2$和子集$s_2$和$\bar{s_2}$，如果这个集合能合并，那么我们需要有</p>
<ul>
<li>$S_1 \cap S_2 = \emptyset$</li>
<li>$sum(s_1) + sum(s_2) == sum(\bar{s_1}) + sum(\bar{s_2})$</li>
</ul>
<p>第一个条件用折半枚举可以保证。对于第二个来说，假设我们有$sum(s_1)-sum(\bar{s_1})=d$，那么如果$sum(\bar{s_2})-sum(s_2)=d$，那么就满足了第二个条件。</p>
<p>于是我们可以枚举左边的所有可能，然后记录有多少个集合具有差值$d$。然后在枚举右边的时候，对于每个右边子集，找到它的子集总共能匹配多少个左边子集。为了表述清晰，设$S_l$为左边集合的子集，$S_r$为右边集合的子集。对于每个右边集合的子集$s_r \subset S_r$，以及它的子集$ss_r \subset s_r$，我们要求：<br>$$<br>    \sum_{s_r}|\bigcap_{ss_r\in s_r}{s_l\text{使得}ss_r\text{可以与左边合并}}|<br>$$</p>
<p>所以我们要求差值为$d$集合的并集，但是集合个数有$2^{\frac{n}{2}}$个，无法用状态压缩($int$和long long)表示。于是我们就想到了使用$bitset$，$2^{\frac{n}{2}}$在这道题中仅有$1024$，$bitset$实现中每个集合所占空间仅有$\frac{1024}{8} = 128$字节。</p>
<p>我们再来计算一下总共可能会有多少种差值，不好计算但是可以估算出是小于$3^{10}=6\times10^4$的，也就是最坏也只是$sum$数组的内存级别。</p>
<p>于是我们只要维护一个<code>map&lt;int,bitset&lt;1024&gt;&gt;</code>就可以了。</p>
<p>以下是这种解法对应的代码：</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>折半枚举的复杂度是$3^{n/2}$，另一半查询的复杂度是因为有map所以是$\log$级别。<br>加上预处理以后的时间复杂度<br>$$<br>O(n2^n+3^{\frac{n}{2}}\log{3^{\frac{n}{2}}})<br>$$</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">25</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, k;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum[(<span class="number">1</span> &lt;&lt; <span class="number">20</span>) + <span class="number">5</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">bitset</span>&lt;1024&gt;&gt; mpp;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;arr[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 求出所有子集的和</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> ((i &gt;&gt; j) &amp; <span class="number">1</span>) sum[i] += arr[j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 枚举左边</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> mid = n / <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; mid); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s1 = i;; s1 = (s1 - <span class="number">1</span>) &amp; i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            mpp[sum[s1 ^ i] - sum[s1]].<span class="built_in">set</span>(i, <span class="literal">true</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!s1) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 枚举右边</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; (n - mid)); i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">bitset</span>&lt;1024&gt; sss(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 这里我刻意保留了子集为空的情况</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s1 = i;; s1 = (s1 - <span class="number">1</span>) &amp; i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> diff = sum[s1 &lt;&lt; mid] - sum[(s1 ^ i) &lt;&lt; mid];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            sss |= mpp[diff];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!s1) <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// 对答案的贡献就是这个集合的大小</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        ans += sss.count();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 要减去左边右边都是空集的情况</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans - <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>洛谷</category>
      </categories>
      <tags>
        <tag>中途相遇/折半枚举</tag>
        <tag>搜索</tag>
      </tags>
  </entry>
  <entry>
    <title>[CF1238E] Keyboard Purchase</title>
    <url>/2019/12/04/CF1238E/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你一个文本串$S(len(S) \leq 10^5)$，由前$m(m\leq20)$个小写字母组成。要你求一种键盘的排列，使得打出这个文本串的消耗最小。这个消耗$cost$的计算方式为相邻字符的键盘距离之和，也就是$\sum_{i=2}^{n} |pos_{s_i-1}-pos_{s_i}|$。只需要输出这个最小消耗就行。</p>
<a id="more"></a>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>打比赛时候以为是一道贪心题，结果怎么做都不对，后来看到$(m\leq20)$就在想状压DP，但是完全不会做这种对于排列的DP。因为无法确定这个字符应该插入到什么位置，也就没法计算$cost$。<br>赛后看题解才知道原来DP还可以有预先计算$cost$这种操作，那么公式也就很好想了。<br>我们先预处理文本串$S$中相邻字符对出现的次数。设$f(S)$为当前使用了集合为$S$的字符进行排列，所能产生的最小$cost$。当我们加入一个新字符的时候，我们除了计算当前最小值，还要把还没有使用过的字符与使用过的字符所产生的$cost$也加进去，由此可得：<br>$$<br>\begin{aligned}<br>f(S) &amp;=\min\{f(S-\{j\})\} &amp; [j\in S]\\<br>f(S) &amp;= f(S) + cost(i, j) &amp; [i \in S,j\in \overline{S}]\\<br>\end{aligned}<br>$$<br>那么整体最小值就是$f(S的全集)$了。<br>顺便吐槽一下状压$O(m^22^m)$都$4\times10^8$了，结果$CF$神机居然$0.5$秒就跑出来了也是可以，我还以为会超时。。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(m^22^m+S)$</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录点对的数量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt[<span class="number">25</span>][<span class="number">25</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">ll dp[(<span class="number">1</span> &lt;&lt; <span class="number">20</span>) + <span class="number">5</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, text);</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">char</span> a = text[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">char</span> b = text[i + <span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (a == b) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cnt[a - <span class="string">'a'</span>][b - <span class="string">'a'</span>]++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cnt[b - <span class="string">'a'</span>][a - <span class="string">'a'</span>]++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dp));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> s = <span class="number">1</span>; s &lt; (<span class="number">1</span> &lt;&lt; k); s++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> ((s &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                dp[s] = min(dp[s], dp[s ^ (<span class="number">1</span> &lt;&lt; i)]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (!((s &gt;&gt; i) &amp; <span class="number">1</span>)) <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// 未访问的点的贡献</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> ((~s &gt;&gt; j) &amp; <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    dp[s] += cnt[i][j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, dp[(<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span>]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>Codeforces</category>
      </categories>
      <tags>
        <tag>状态压缩DP</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>[ICPC NAQ2019] Problem L: Traveling Merchant</title>
    <url>/2019/12/03/NAQ19L/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>一条线上有$N(N\leq10^5)$个城市，标号从$1$到$N$。每个城市物价根据星期的不同而有所不同，具体来说，每个城市有原价$v_i$，变动$d_i$，周一到周日的变化量为$\{+0, +v_i, +2v_i, +3v_i, +2v_i, +v_i, +0\}$。现在有$Q(\leq 10^5)$个询问，每个询问商人会从$l$号城市往$r$号城市旅行，$l$有可能大于$r$，此时要逆行。求次旅行最大的差价$(price_j-price_i)$其中$(j &gt; i)$是多少。</p>
<a id="more"></a>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>$10^5$数据量+$10^5$查询，那么很明显直接模拟是不行的，但是这题题意看起来用线段树也不太好维护（有可能是我太菜了不会）。于是有没有又好维护跑的又快的数据结构呢？于是祭出分块大法。</p>
<p>我们可以把所有城市按照标号分成$\sqrt{N}$块，每一块内存储3个信息:<br>$$\{整块内最大价格，整块内最小价格，整块内最大差价\}$$<br>这样查询的时候可以两端直接模拟，中间根据这三个信息更新最大差价，每次查询复杂度不会超过$O(\sqrt{N})$。</p>
<p>由于有星期这个设定，所以我们要维护$7$重块，每个块信息代表当从第$k$天开始从左到右（反向旅行同理）旅行的信息。这个问题便迎刃而解了，看官方题解好像是用的线段树，但是感觉应该很难写，我用分块一发就过了，线段树不知道要调多久。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(N+Q\sqrt{N})$</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">100005</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, k;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Info</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> v, d, b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 块信息，最大值，最小值，最大差值，左右延伸范围</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Block</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> maxx;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> minn;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> maxprofit;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> lft;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> rgt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> raise[<span class="number">7</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> CASE;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 正向旅行块</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Block blocks[<span class="number">7</span>][<span class="number">505</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 反向旅行块</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Block blocks2[<span class="number">7</span>][<span class="number">505</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> B;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Info cities[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 正向计算</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> d, <span class="keyword">int</span>&amp; maxx, <span class="keyword">int</span>&amp; minn, <span class="keyword">int</span>&amp; maxprofit)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = l; j &lt;= r; j++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> day = (j - l + d) % <span class="number">7</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> price = cities[j].v + raise[day] * cities[j].d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        minn = min(minn, price);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        maxprofit = max(maxprofit, price - minn);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        maxx = max(maxx, price);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 反向计算</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cal2</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> l, <span class="keyword">int</span> d, <span class="keyword">int</span>&amp; maxx, <span class="keyword">int</span>&amp; minn, <span class="keyword">int</span>&amp; maxprofit)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = r; j &gt;= l; j--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> day = (r - j + d) % <span class="number">7</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> price = cities[j].v + raise[day] * cities[j].d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        minn = min(minn, price);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        maxprofit = max(maxprofit, price - minn);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        maxx = max(maxx, price);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 同样也是一正一反</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query2</span><span class="params">(<span class="keyword">int</span> r, <span class="keyword">int</span> l)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> d = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> maxx = <span class="number">0</span>, minn = <span class="number">1e9</span>, prof = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> rs = max(l, blocks2[<span class="number">0</span>][cities[r].b].lft);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cal2(r, rs, d, maxx, minn, prof);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    d = (d + r - rs + <span class="number">1</span>) % <span class="number">7</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cities[r].b - <span class="number">1</span>; i &gt;= cities[l].b + <span class="number">1</span>; i--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        prof = max(prof, blocks2[d][i].maxx - minn);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        minn = min(minn, blocks2[d][i].minn);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        prof = max(prof, blocks2[d][i].maxprofit);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        maxx = max(maxx, blocks2[d][i].maxx);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        d = (d + blocks2[d][i].rgt - blocks2[d][i].lft + <span class="number">1</span>) % <span class="number">7</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (cities[l].b != cities[r].b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> ls = min(r, blocks2[<span class="number">0</span>][cities[l].b].rgt);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cal2(ls, l, d, maxx, minn, prof);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> prof;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> d = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> ls = min(r, blocks[<span class="number">0</span>][cities[l].b].rgt);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> maxx = <span class="number">0</span>, minn = <span class="number">1e9</span>, prof = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cal(l, ls, d, maxx, minn, prof);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    d = (d + ls - l + <span class="number">1</span>) % <span class="number">7</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = cities[l].b + <span class="number">1</span>; i &lt;= cities[r].b - <span class="number">1</span>; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        prof = max(prof, blocks[d][i].maxx - minn);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        minn = min(minn, blocks[d][i].minn);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        prof = max(prof, blocks[d][i].maxprofit);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        maxx = max(maxx, blocks[d][i].maxx);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        d = (d + blocks[d][i].rgt - blocks[d][i].lft + <span class="number">1</span>) % <span class="number">7</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (cities[l].b != cities[r].b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> rs = max(l, blocks[<span class="number">0</span>][cities[r].b].lft);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cal(rs, r, d, maxx, minn, prof);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> prof;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    B = (<span class="keyword">int</span>)<span class="built_in">sqrt</span>(n) + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> cnt = (n + B - <span class="number">1</span>) / B;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;cities[i].v, &amp;cities[i].d);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cities[i].b = (i - <span class="number">1</span>) / B + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">7</span>; d++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 确定块的左右边界</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            blocks[d][i].lft = B * (i - <span class="number">1</span>) + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            blocks[d][i].rgt = B * i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            blocks2[d][i].lft = B * (i - <span class="number">1</span>) + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            blocks2[d][i].rgt = B * i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> l = blocks[d][i].lft, r = blocks[d][i].rgt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Block&amp; cur = blocks[d][i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cur.maxx = <span class="number">0</span>, cur.minn = <span class="number">1e9</span>, cur.maxprofit = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Block&amp; cur2 = blocks2[d][i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cur2.maxx = <span class="number">0</span>, cur2.minn = <span class="number">1e9</span>, cur2.maxprofit = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cal(l, r, d, cur.maxx, cur.minn, cur.maxprofit);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cal2(r, l, d, cur2.maxx, cur2.minn, cur2.maxprofit);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (m--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> l, r;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (l &lt;= r) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query(l, r));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query2(l, r));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>题解</category>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>分块</tag>
      </tags>
  </entry>
  <entry>
    <title>[ICPC NAQ2019] Problem E: NVMLS</title>
    <url>/2019/12/03/NVMLS/</url>
    <content><![CDATA[<h1 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h1><p>给你$N$个大写字母组成的单词和一串大写非元音字母所组成的字符串（$L\leq 3\times 10^5$）。已知字符串$L$是由给出单词的非元音字母组成的，求将这个字符串还原回正常单词以后，元音字母数量最多的一个原串。数据保证$\sum_{i=0}^{n} len(s_i) \leq 10^5$。</p>
<a id="more"></a>

<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>由于模式串$L$和匹配串的数据很大，所以普通匹配肯定是不行的。可以考虑$AC$自动机或者Hash，但是我$AC$自动机写挂了所以改用$Hash$了。同时匹配结束以后我们还需要用$DP$来获取元音字母最多的还原串。<br>假设我们已经获取每个位置上的匹配串，假设位置$i$的所有匹配串为$m_i$，每个匹配串的元音字母数量为$v[j]$，匹配长度为$l[j]$。那么可得$DP$公式：<br>$$<br>f(i)=\max_{j \in m_i}\{f(i-l[j]+v[j])+v[j]\}<br>$$<br>那么$f(L)$就是最多的元音数量。因为题目要输出这个还原串，所以我们在$DP$的时候还要记录每一个状态是由哪一个匹配串转移而来的，这样就可以从后往前构造原串。</p>
<p>如果我们考虑这个$DP$的时间复杂度，会发现它很有可能是$O(NL)$的，显然会超时。但是仔细一想我们会发现，对于每一个位置，长度为$x$的匹配串有且仅能有一个，那么我们其实只需要枚举长度就好了。对于一个总长度不超过$N$的单词集合，长度的种类最多只有$O(\sqrt{N})$种。因为$\sum_{i=1}^k{i}=N$可得$\frac{k(k+1)}{2}=N$，解得$k=\sqrt{2N+0.25}-0.5$。<br>如果每个位置只有最多$O(\sqrt{N})$个匹配串，那么总复杂度$O(L\sqrt{N})$就可以接受了。<br>对于维护$\sqrt{N}$个长度的$Hash$我们也可以动态的$O(L)$时间来实现，只要在超出长度的时候$hash - pow[len]$就可以了。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>$O(L\sqrt{N})$</p>
<h2 id="参考代码"><a href="#参考代码" class="headerlink" title="参考代码"></a>参考代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">300005</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, k;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> CASE;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 单词字符串信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node2</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span> str;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ull hash1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll hash2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 长度离散化结构</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Discretization</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; xp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator xend;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> xend - xp.begin(); &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123; xp.push_back(val); &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">discretize</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sort(xp.begin(), xp.end());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        xend = unique(xp.begin(), xp.end());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> lower_bound(xp.begin(), xend, val) - xp.begin() + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get2</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123; <span class="keyword">return</span> xp[num - <span class="number">1</span>]; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Discretization dis;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> text[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串hash匹配表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; hashList[MAXN * <span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 原单词信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Node2 strList[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 每个位置匹配的串</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; matches[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dp[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> opt[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">removeVowel</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str, <span class="keyword">int</span>&amp; cnt)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">string</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cnt = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : str) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (c == <span class="string">'A'</span> || c == <span class="string">'E'</span> || c == <span class="string">'I'</span> || c == <span class="string">'O'</span> || c == <span class="string">'U'</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            cnt++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            res.push_back(c);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 我用了双hash，一个自然溢出一个模数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ull powh[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line">ll powh2[MAXN];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Hasher</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ull hashB1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ll hashB2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> cnt1;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        powh[<span class="number">0</span>] = powh2[<span class="number">0</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; MAXN; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            powh[i] = powh[i - <span class="number">1</span>] * <span class="number">277L</span>L;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            powh2[i] = powh2[i - <span class="number">1</span>] * <span class="number">1999L</span>L % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Hasher() &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB1 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB2 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removel</span><span class="params">(<span class="keyword">char</span> c, <span class="keyword">int</span> len)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB1 -= powh[len] * (ull)c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB2 -= (powh2[len] * c) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB2 %= MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (hashB2 &lt; <span class="number">0</span>) hashB2 += MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insertr</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB1 *= powh[<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB1 += c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB2 = (hashB2 * powh2[<span class="number">1</span>]) % MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB2 += c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hashB2 %= MOD;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Hasher hasher;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Hasher dynHash[<span class="number">505</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; sss;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCALLL</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"in"</span>, <span class="string">"r"</span>, <span class="built_in">stdin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    freopen(<span class="string">"out"</span>, <span class="string">"w"</span>, <span class="built_in">stdout</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    hasher.init();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> tot = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, text);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(text)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">string</span> rem = removeVowel(s, cnt);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (!sss.count(rem) || cnt &gt; sss[rem]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            sss[rem] = cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            hasher.clear();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> a : rem) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                hasher.insertr(a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            strList[tot] = &#123;s, hasher.hashB1, hasher.hashB2, cnt&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            hashList[hasher.hashB1 % (MAXN * <span class="number">2</span>)].push_back(tot);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            tot++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            dis.add(rem.size());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dis.discretize();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>, text + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    n = <span class="built_in">strlen</span>(text + <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dp[i] = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> sz = dis.size();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = sz; j &gt;= <span class="number">1</span>; j--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// 动态维护每个长度的hash</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            dynHash[j].insertr(text[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> len = dis.get2(j);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (i &gt; len) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                dynHash[j].removel(text[i - len], len);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (i &gt;= len) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> loc = dynHash[j].hashB1 % (MAXN * <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">// hash匹配</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> v : hashList[loc]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    Node2&amp; nd = strList[v];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">if</span> (nd.hash2 == dynHash[j].hashB2) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        matches[i].push_back(v);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : matches[i]) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Node2&amp; nd = strList[a];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> p = i - nd.str.size() + nd.cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (dp[p] &gt;= <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> nx = dp[p] + nd.cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (dp[i] &lt; nx) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    dp[i] = nx;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    opt[i] = a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> k = n;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 构造原串</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        res.push_back(opt[k]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">int</span> d = strList[opt[k]].str.size() - strList[opt[k]].cnt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        k -= d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = res.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, strList[res[i]].str.c_str());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="built_in">printf</span>(<span class="string">" "</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>题解</category>
        <category>ICPC</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
        <tag>字符串哈希</tag>
        <tag>AC自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>你好，世界</title>
    <url>/2019/12/03/hello-world/</url>
    <content><![CDATA[<p>欢迎，这里是DXTsT，又名小裙子。<br>这个博客用来记录一些算法，黑科技等等，反正就是杂七杂八的东西。<br>在别的地方写过的文章，都会陆续搬到这里来，包括fs49.org</p>
<h3 id="注意，本博客的所有题解代码都不保证能够直接提交AC，只是截取了部分核心代码，能不能AC还是要靠自己！"><a href="#注意，本博客的所有题解代码都不保证能够直接提交AC，只是截取了部分核心代码，能不能AC还是要靠自己！" class="headerlink" title="注意，本博客的所有题解代码都不保证能够直接提交AC，只是截取了部分核心代码，能不能AC还是要靠自己！"></a>注意，本博客的所有题解代码都不保证能够直接提交AC，只是截取了部分核心代码，能不能AC还是要靠自己！</h3><a id="more"></a>]]></content>
  </entry>
</search>
